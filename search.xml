<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VSCode 快速切换工作区</title>
    <url>/Tools/VSCode%20%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E5%8C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文就是为解决 VSCode 快速切换不同的工作区问题（VSCode 目前只允许<strong>一次打开一个工作区实例</strong>）。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="VSCode-快速切换工作区"><a class="header-anchor" href="#VSCode-快速切换工作区">#</a>VSCode 快速切换工作区</h3>
<ol>
<li>
<p><strong>手动创建 VSCode 工作区</strong></p>
<ul>
<li>将工作区文件夹添加到工作区，另存为 <code>custom.code-workspace</code>文件，通过文件打开工作区间。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用 VSCode 插件 Workspace Explorer</strong>【推荐】</p>
<ul>
<li>通过插件手动配置不同工作区，实现快速切换不同的工作区。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="手动创建-VSCode-工作区"><a class="header-anchor" href="#手动创建-VSCode-工作区">#</a>手动创建 VSCode 工作区</h4>
<ul>
<li>
<p>将工作区文件夹添加到工作区，另存为 <code>custom.code-workspace</code>文件，通过文件打开工作区间。<br>
<br></p>
</li>
<li>
<p>通过 <code>Ctrl + Shif + P</code> 打开Open Workspace Settings(json)任务编辑工作区文件和工作区设置。</p>
</li>
</ul>
<hr>
<h4 id="使用-VSCode-插件-Workspace-Explorer"><a class="header-anchor" href="#使用-VSCode-插件-Workspace-Explorer">#</a>使用 VSCode 插件 Workspace Explorer</h4>
<ul>
<li>
<p>安装插件 <a href="https://marketplace.visualstudio.com/items?itemName=tomsaunders.vscode-workspace-explorer" rel="external nofollow noreferrer">Workspace Explorer</a></p>
</li>
<li>
<p><a href="https://github.com/sirfuzzalot/workspace-explorer?tab=readme-ov-file#opening-a-workspace-using-command-palette" rel="external nofollow noreferrer">Workspace Explorer Github 文档</a><br>
<br></p>
</li>
<li>
<p>配置 Workspace Explorer</p>
<ul>
<li>设置<strong>自定义图标目录路径</strong>和<strong>工作区文件目录</strong>，并开启自定义图片搜索
<ul>
<li>需注意：windows 平台不能设置路径为盘符根目录即（如 D:\）<br>
<br></li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E9%85%8D%E7%BD%AEWorkspaceExplorer.png" alt="配置 Workspace Explorer"><br>
<br></p>
<ul>
<li>关于自定义图标可以从<a href="https://www.flaticon.com/" rel="external nofollow noreferrer">Flaticon</a>下载。<br>
<br></li>
</ul>
</li>
<li>
<p>最终效果<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20240924151131.png" alt="Workspace"></p>
</li>
</ul>
<hr>
<h4 id="Thanks"><a class="header-anchor" href="#Thanks">#</a>Thanks</h4>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=tomsaunders.vscode-workspace-explorer" rel="external nofollow noreferrer">Workspace Explorer</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 解决端口占用</title>
    <url>/Tools/Windows%20%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>Windows 解决端口占用问题。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="Windows-解决端口占用的方法"><a class="header-anchor" href="#Windows-解决端口占用的方法">#</a>Windows 解决端口占用的方法</h3>
<ul>
<li>
<p><strong>终止占用进程</strong></p>
<ul>
<li>使用命令查找占用端口的进程并终止它。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>更改端口号</strong></p>
<ul>
<li>在应用程序或服务的配置文件中更改端口号，避免与其他进程冲突。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>重新启动计算机</strong></p>
<ul>
<li>重启计算机可以清除端口占用情况，特别是当端口被僵尸进程占用时。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>检查防火墙设置</strong></p>
<ul>
<li>确保防火墙设置允许使用该端口，或添加规则以开放端口。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>查看网络配置</strong></p>
<ul>
<li>在某些情况下，网络配置或代理设置可能影响端口使用，检查并调整相关设置。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="终止占用进程"><a class="header-anchor" href="#终止占用进程">#</a>终止占用进程</h4>
<ul>
<li>
<p><strong>查找占用端口的进程的PID</strong></p>
<ul>
<li>运行cmd/powershell, 查找5000端口的 PID， 下图箭头即为PID
<ul>
<li>执行<code>netstat -aon|findstr :5000|findstr LISTEN</code><br>
<br></li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/FindPort.png" alt="FindPort"><br>
<br></p>
</li>
<li>
<p><strong>根据PID查找进程</strong></p>
<ul>
<li>接下来打开任务管理器，查找PID为6916的应用程序<br>
<br><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/FindProcess.png" alt="FindProcess"><br>
<br></li>
</ul>
</li>
<li>
<p><strong>重点：补充</strong></p>
<ul>
<li>
<p><strong>当占用进程为系统进程（即PID 4）或者是无法结束的进程（即服务）</strong></p>
<ul>
<li>运行cmd/powershell, <code>tasklist /svc | findstr</code> + PID 或者 服务名称，得到服务名称和PID：<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/FindService.png" alt="FindService"></li>
<li>然后以管理员权限运行cmd/powershell, 输入<code>net stop 服务名称 /y</code>停掉对应服务<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/StopService.png" alt="StopService"><br>
<br></li>
</ul>
</li>
<li>
<p><strong>当占用进程为PID4且没有服务名称</strong></p>
<ul>
<li>运行命令<code>netsh http show servicestate</code>查看进程PID对应的服务</li>
<li>然后运行<code>net stop 服务名称 /y</code>停掉对应服务即可<br>
<br></li>
</ul>
</li>
<li>
<p><strong>关于443端口若被vmware-hostd.exe占用</strong></p>
<ul>
<li>打开vmwre &gt; 首选项 &gt; 共享虚拟机 &gt; 禁用共享, 或者自行修改为其他端口</li>
<li>针对VMWARE16/更新版本,可以编辑（C:\ProgramData\VMware\hostd\proxy.xml），将httpsPort改成非443/80就行<br>
<br></li>
</ul>
</li>
<li>
<p><strong>当查询不到端口被任何进程占用</strong></p>
<ul>
<li>即 <code>netstat -aon|findstr :端口号|findstr LISTEN</code> 查询不到端口被任何进程占用且无法监听,可能是LSP<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="LSP（Layered Service Provider）是 Windows 平台上的一种技术，允许开发人员在(应用层)网络协议栈中插入自定义的层来实现网络数据的处理和管理。这可以包括数据包过滤、监控、修改等功能。
">[1]</span></a></sup>被劫持的原因。</li>
<li>然后以管理员权限运行cmd/powershell, 输入<code>netsh winsock reset</code>, 重启电脑</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="更改端口号"><a class="header-anchor" href="#更改端口号">#</a>更改端口号</h4>
<ul>
<li>
<p>例如：Hexo可以通过更改本地服务器端口号解决端口占用</p>
<ul>
<li>bash 运行<code>hexo server -p 5000</code> 命令或者在 _config.yml中添加下面代码：<br>
<br></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="检查防火墙设置"><a class="header-anchor" href="#检查防火墙设置">#</a>检查防火墙设置</h4>
<ul>
<li>当端口被防火墙阻止时
<ul>
<li>可以选择“高级安全Windows防火墙”，新建“入站规则”，指定规则类型为端口并输入端口号配置即可解决端口问题。</li>
</ul>
</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">LSP（Layered Service Provider）是 Windows 平台上的一种技术，允许开发人员在(应用层)网络协议栈中插入自定义的层来实现网络数据的处理和管理。这可以包括数据包过滤、监控、修改等功能。<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Port</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 快速创建 Hexo 文章</title>
    <url>/Blog/VSCode%20%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%20Hexo%20%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>使用VSCode快速创建带有Front-matter格式的Markdown文档。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="VSCode-快速创建-Hexo-文章"><a class="header-anchor" href="#VSCode-快速创建-Hexo-文章">#</a>VSCode 快速创建 Hexo 文章</h3>
<ol>
<li>
<p><strong>使用 Hexo CLI</strong></p>
<ul>
<li>在终端中运行 <code>hexo new post &lt;post-title&gt;</code> 命令来创建新文章。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用代码片段</strong>（Snippets）</p>
<ul>
<li>设置自定义代码片段来插入文章的基本结构。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用自定义脚本任务</strong></p>
<ul>
<li>在 tasks.json 文件中配置一个任务，运行 Hexo 的新建文章命令。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用插件 vscode-hexo-utils</strong></p>
<ul>
<li>使用专门的 Hexo 插件，如 <a href="https://github.com/0x-jerry/vscode-hexo-utils?tab=readme-ov-file" rel="external nofollow noreferrer">vscode-hexo-utils</a>，来生成文章模板。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="使用-Hexo-CLI"><a class="header-anchor" href="#使用-Hexo-CLI">#</a>使用 Hexo CLI</h4>
<ul>
<li>
<p><strong>使用VSCode终端</strong></p>
<ul>
<li>使用快捷键 Ctrl+` 打开VSCode集成终端</li>
<li>在终端中使用 Git Bash 终端并运行命令 <code>hexo new post &quot;Title&quot;</code>
<ul>
<li>关于hexo常用命令：<a href="./Hexo%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.md">Hexo 常用操作</a><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>关于集成终端显示此系统上禁止运行脚本问题</strong></p>
<ul>
<li>
<p>通常是由于 Windows 的执行策略限制了脚本的执行<br>
<br></p>
</li>
<li>
<p>解决方案：</p>
<ul>
<li>打开 PowerShell 以管理员身份运行</li>
<li>使用<code>Get-ExecutionPolicy</code>命令检查当前的执行策略</li>
<li>使用<code>Set-ExecutionPolicy RemoteSigned</code>命令更改策略为 RemoteSigned 或者使用<code>Set-ExecutionPolicy Unrestricted</code> 命令更改策略为 Unrestricted<br>
<br></li>
</ul>
</li>
<li>
<p>关于这三种策略：</p>
<ul>
<li><strong>Restricted</strong>
<ul>
<li>是 PowerShell 的默认执行策略，该策略下 PowerShell 只能运行交互式命令，不能执行脚本文件（.ps1 文件）或配置文件</li>
</ul>
</li>
<li><strong>RemoteSigned</strong>
<ul>
<li>要求所有从互联网下载的脚本必须经过签名才能执行，但本地创建的脚本可以不需要签名</li>
</ul>
</li>
<li><strong>Unrestricted</strong>
<ul>
<li>不限制脚本的来源或签名，允许所有脚本（包括从互联网下载的未签名脚本）运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="使用自定义代码片段（推荐）"><a class="header-anchor" href="#使用自定义代码片段（推荐）">#</a>使用自定义代码片段（推荐）</h4>
<ul>
<li>
<p><strong>创建代码块</strong></p>
<ul>
<li>打开 VSCode，进入 “文件” &gt; “首选项” &gt; “用户代码片段”</li>
<li>选择 “New Global Snippets file” 或 “New Snippets file for &lt;your_workspace&gt;”（如果只在某个工作区有效）。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>添加代码片段</strong></p>
<ul>
<li>默认会在&lt;your_workspace&gt;/.vscode下创建Enter.code-snippets文件(建议在.gitignore文件中忽略该文件夹)</li>
<li><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" rel="external nofollow noreferrer">自定义代码片段官方文档</a><br>
<br></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Hexo Post Template&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexopost&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;---&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;title: $&#123;TM_FILENAME_BASE&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;date: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;updated: &#123;&#123; updated &#125;&#125;&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="string">&quot;categories: $&#123;2:category1&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;tags: $&#123;3:tag1&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;keywords: $&#123;4:keyword1&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;author: shuguang2000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;comments: true&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;---&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;- $&#123;1:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;\n&lt;!--more--&gt;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;------\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;### Topic Introduction\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;1. $&#123;5:One&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;   - $&#123;6:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&lt;br&gt;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;2. $&#123;7:Two&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;   - $&#123;8:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&lt;br&gt;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;------\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;#### Topic\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;- $&#123;9:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&lt;br&gt;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;- $&#123;10:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&lt;br&gt;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;------\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;#### Thanks\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;- $&#123;11:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&lt;br&gt;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;- $&#123;12:pass&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;&lt;br&gt;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Template for Hexo post&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>使用代码块</strong></p>
<ul>
<li>使用 <code>Ctrl+N</code> 快捷键新建一个文件，输入我们上面定义好的代码前缀（即：hexopost）即可快速插入。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>补充</strong>【推荐】</p>
<ul>
<li>可使用自定义快捷键实现不用输入前缀，即可快速在任意文件中插入自定义代码片段（这里使用的是 <code>Ctrl+Alt+M</code> ），并通过 Tab 键快速修改内容。
<ul>
<li>打开 VSCode，进入 “文件” &gt; “首选项” &gt; “键盘快捷方式” &gt; “打开键盘快捷方式JSON” &gt; <code>keybindings.json</code></li>
<li>或者是打开<code>keybindings.json</code>文件（默认在<code>C:\Users\&lt;your_username&gt;\AppData\Roaming\Code\User</code>下）添加下面JSON代码：<br>
<br></li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+m&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editor.action.insertSnippet&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editorTextFocus&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;langId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;markdown&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hexo Post Template&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="使用自定义任务"><a class="header-anchor" href="#使用自定义任务">#</a>使用自定义任务</h4>
<ul>
<li>
<p><strong>准备工作</strong></p>
<ul>
<li>
<p>配置默认终端配置为： <code>Git Bash</code></p>
<ul>
<li>在xxx.code-workspace文件中添加如下代码：<br>
<br></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.defaultProfile.linux&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.defaultProfile.osx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.defaultProfile.windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Git Bash&quot;</span><span class="punctuation">,</span> <span class="comment">// 如果你在 Windows 上使用 Git Bash</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<br>
</li>
<li>
<p>在&lt;your_workspace&gt;/.vscode下创建 <code>tasks.json</code> 文件, 编辑生成的 <code>tasks.json</code> 文件，添加一个新任务来运行 Hexo 命令：<br>
<br></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Create Hexo Post&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;-c&quot;</span><span class="punctuation">,</span> <span class="comment">//用于指定要执行的命令字符串</span></span><br><span class="line">      <span class="string">&quot;hexo new $&#123;input:postTitle&#125;&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;postTitle&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;promptString&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enter the title of the new post&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<ul>
<li><strong>运行任务</strong>
<ul>
<li>
<p><code>Ctrl + Shift + P</code> 选择<code>Takes: Run Task</code>运行标签为 Create Hexo Post 的任务。</p>
</li>
<li>
<p><a href="https://code.visualstudio.com/docs/editor/tasks" rel="external nofollow noreferrer">VSCode自定义任务文档</a></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="使用插件-vscode-hexo-utils"><a class="header-anchor" href="#使用插件-vscode-hexo-utils">#</a>使用插件 vscode-hexo-utils</h4>
<ul>
<li>
<p>使用 VSCode 插件 <a href="https://github.com/0x-jerry/vscode-hexo-utils?tab=readme-ov-file" rel="external nofollow noreferrer">vscode-hexo-utils</a></p>
<ul>
<li>安装后在插件扩展设置中，设置时间格式<code>YYYY-MM-DD HH:mm:ss</code>。<br>
<br></li>
</ul>
</li>
<li>
<p>侧边栏 Hexo 图标点开再点击加号输入标题即可快速创建模板文章（默认模板是scaffolds/post.md）。</p>
</li>
</ul>
<hr>
<h4 id="总结"><a class="header-anchor" href="#总结">#</a>总结</h4>
<ul>
<li>
<p><strong>使用 Hexo CLI</strong></p>
<ul>
<li>适合简单的创建模板。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用代码片段</strong>（Snippets）</p>
<ul>
<li>适合快速插入简单的模板。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用自定义脚本任务</strong></p>
<ul>
<li>适合更复杂的模板生成或批量创建。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用插件 vscode-hexo-utils</strong></p>
<ul>
<li>能集成 Hexo 特性，并使用更多的功能，比如图片上传，文章分类显示等。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Thanks"><a class="header-anchor" href="#Thanks">#</a>Thanks</h4>
<ul>
<li>
<p><a href="https://code.visualstudio.com/docs/editor/tasks" rel="external nofollow noreferrer">Integrate with External Tools via Tasks</a><br>
<br></p>
</li>
<li>
<p><a href="https://code.visualstudio.com/docs/editor/tasks" rel="external nofollow noreferrer">Snippets in Visual Studio Code</a><br>
<br></p>
</li>
<li>
<p><a href="https://github.com/0x-jerry/vscode-hexo-utils?tab=readme-ov-file" rel="external nofollow noreferrer">vscode-hexo-utils</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>学习的心得</title>
    <url>/Study/%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>学习方法的总结和思路梳理。<br>
<br></li>
</ul>
<span id="more"></span>
<hr>
<h3 id="学习的心得"><a class="header-anchor" href="#学习的心得">#</a>学习的心得</h3>
<ol>
<li>
<p><strong>可行性分析</strong></p>
<ul>
<li>能不能解决，或者说是用什么方法解决。</li>
<li>确保方案正确，一定能解决，只是自己不会。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>寻找具体方案</strong></p>
<ul>
<li>博客或者ChatGPT问</li>
<li>中文互联网比较烂，要逐渐习惯阅读英文文档。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>尝试解决问题</strong></p>
<ul>
<li>一般是一个小时以上<br>
<br></li>
</ul>
</li>
<li>
<p><strong>保留解决方案</strong></p>
<ul>
<li>给再次解决问题提供方便。</li>
<li>尽可能简略，更多是解决方案和思路。（介绍+文档链接）
<ul>
<li>最忌讳的是把自己都不愿意看的东西写在里面。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>笔记保留方案</strong></p>
<ul>
<li>博客园/第三方博客</li>
<li>Github个人博客/本地保存<br>
<br></li>
</ul>
</li>
<li>
<p><strong>熟练使用Markdown语法【建议】</strong></p>
<ul>
<li>方便记笔记<br>
<br></li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>微软激活脚本</title>
    <url>/Tools/%E5%BE%AE%E8%BD%AF%E6%BF%80%E6%B4%BB%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>Microsoft 激活脚本（MAS），官方文档：<a href="https://github.com/massgravel/Microsoft-Activation-Scripts" rel="external nofollow noreferrer">https://github.com/massgravel/Microsoft-Activation-Scripts</a></li>
</ul>
<span id="more"></span>
<hr>
<h3 id="Microsoft-激活脚本（MAS）"><a class="header-anchor" href="#Microsoft-激活脚本（MAS）">#</a>Microsoft 激活脚本（MAS）</h3>
<ul>
<li>
<p>Microsoft 激活脚本（MAS）</p>
<ul>
<li>使用 HWID / Ohook / KMS38 / 在线 KMS 激活方法的 Windows 和 Office 激活器，侧重于开源代码和较少的防病毒检测。</li>
<li>HWID激活方法的介绍: <a href="https://massgrave.dev/hwid" rel="external nofollow noreferrer">https://massgrave.dev/hwid</a><br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用方法</strong>：官方推荐使用PowerShell（输入下面代码就行）</p>
<ul>
<li><code>irm https://get.activated.win | iex</code><br>
<br></li>
</ul>
</li>
<li>
<p>Office 和 Windows 镜像下载地址：</p>
<ul>
<li><a href="https://gravesoft.dev/office_c2r_links#chinese-simplified-zh-cn" rel="external nofollow noreferrer">https://gravesoft.dev/office_c2r_links#chinese-simplified-zh-cn</a><br>
<br></li>
</ul>
</li>
<li>
<p>激活成功截图<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/success.png" alt="success"></p>
</li>
</ul>
<hr>
<h4 id="Thanks"><a class="header-anchor" href="#Thanks">#</a>Thanks</h4>
<ul>
<li>
<p><a href="https://github.com/massgravel/Microsoft-Activation-Scripts" rel="external nofollow noreferrer">Microsoft 激活脚本 Github 地址</a><br>
<br></p>
</li>
<li>
<p><a href="https://massgrave.dev/" rel="external nofollow noreferrer">Microsoft 激活脚本 主页</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理和反向代理</title>
    <url>/Tools/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>正向代理和反向代理的应用和作用。<br>
<br></li>
</ul>
<span id="more"></span>
<hr>
<h3 id="正向代理和反向代理"><a class="header-anchor" href="#正向代理和反向代理">#</a>正向代理和反向代理</h3>
<ol>
<li>
<p><strong>正向代理</strong></p>
<ul>
<li>类似一个跳板机，代理用户发送请求来访问外部资源。<br>
<br></li>
<li>要使用正向代理，客户端必须设置正向代理服务器。
<ul>
<li>设置正向的前提是：知道正向代理<strong>服务器的IP地址</strong>，还有<strong>代理程序的端口</strong>。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>反向代理</strong></p>
<ul>
<li>
<p>不同地区的客户端并不知道自己访问的是不同的代理服务器，客户端是无感知代理的存在的。<br>
<br></p>
</li>
<li>
<p>客户端不需要任何配置就可以获取资源。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="正向代理和反向代理的作用"><a class="header-anchor" href="#正向代理和反向代理的作用">#</a>正向代理和反向代理的作用</h4>
<ul>
<li>
<p>正向代理</p>
<ul>
<li>一般是通过客户端软件连接到代理服务器获取和返回资源。<br>
<br><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="正向代理流程"><br>
<br></li>
</ul>
</li>
<li>
<p>反向代理</p>
<ul>
<li>保证内网的安全，可以使用反向代理提供防火墙功能，阻止web攻击穿透内网。</li>
<li>通过代理服务器优化网站的负载，减少单一服务器压力。<br>
<br><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="反向代理流程"></li>
</ul>
</li>
</ul>
<hr>
<h5 id="正向代理和反向代理的区别"><a class="header-anchor" href="#正向代理和反向代理的区别">#</a>正向代理和反向代理的区别</h5>
<ul>
<li>
<p>正向代理</p>
<ul>
<li>可以看作是用户（client）和代理（proxy）处在一个局域网（LAN），代理（proxy）服务器对于Web服务器（server）是透明的。<br>
<br></li>
</ul>
</li>
<li>
<p>反向代理</p>
<ul>
<li>可以看作是服务器（server）和代理（proxy）处在一个局域网（LAN），Web服务器（server）对于代理（proxy）服务器是透明。</li>
</ul>
</li>
<li>
<p>总结</p>
<ul>
<li>实际使用的正向和反向代理中，代理服务器做的都是代收发请求，类似于现实中的中介。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>CSGO 批量出售饰品</title>
    <url>/Games/CSGO%20%E6%89%B9%E9%87%8F%E5%87%BA%E5%94%AE%E9%A5%B0%E5%93%81/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>简要介绍 Steam 如何一次出售多个饰品。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="CSGO-批量出售"><a class="header-anchor" href="#CSGO-批量出售">#</a>CSGO 批量出售</h3>
<ul>
<li>CSGO 批量出售链接
<ul>
<li><code>https://steamcommunity.com/market/multisell?appid=730&amp;contextid=2&amp;items[]=Snakebite%20Case</code></li>
<li><code>multisell</code>: 代表批量出售。</li>
<li><code>appid</code>: 代表游戏ID，例如：<code>730</code>是<code>CSGO 2</code>而<code>570</code>是<code>Dota 2</code>。</li>
<li><code>contextid</code>: 用来区别服务的，当一个微服务需要调用另一个微服务提供的多个不同接口时，就需要contextId在运行时能够正确地识别和区分彼此，避免出现冲突和混淆。</li>
<li><code>items[]=</code>: 数组，用于批量传输商品代码。</li>
<li><code>Snakebite%20Case</code>代表数字ID，同样也是商品代码。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CSGO</tag>
      </tags>
  </entry>
  <entry>
    <title>自发学习</title>
    <url>/Study/%E8%87%AA%E5%8F%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>自发学习的核心是逐步加强的对自身的理解和控制能力。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h3>
<ul>
<li>
<p>想到自发学习，总不自然联想到社会主义，人总是希望思想能够直接控制行为，然而人和人群一样都是基于抽象主义。<br>
<br></p>
</li>
<li>
<p>从抽象直接控制具体是不现实，反之亦然。</p>
</li>
</ul>
<hr>
<h4 id="自发学习"><a class="header-anchor" href="#自发学习">#</a>自发学习</h4>
<ol>
<li>
<p><strong>可行性方案</strong><br>
<br></p>
</li>
<li>
<p><strong>安全可明白性的输入</strong><br>
<br></p>
</li>
<li>
<p><strong>忍受歧义接受不完美</strong><br>
<br></p>
</li>
<li>
<p><strong>分解解构</strong><br>
<br></p>
</li>
<li>
<p><strong>形成工具箱</strong></p>
</li>
</ol>
<hr>
<h4 id="可行性方案"><a class="header-anchor" href="#可行性方案">#</a>可行性方案</h4>
<ul>
<li>明确的可执行的方案
<ul>
<li>模仿已知方案</li>
<li>寻求有效性</li>
<li>识别并运用</li>
</ul>
</li>
</ul>
<hr>
<h4 id="安全可明白性的输入"><a class="header-anchor" href="#安全可明白性的输入">#</a>安全可明白性的输入</h4>
<ul>
<li>开心、放松、好奇大脑状态</li>
<li>忍受歧义接受不完美</li>
<li>安全理解和反馈（AI工具）</li>
</ul>
<hr>
<h4 id="分解解构"><a class="header-anchor" href="#分解解构">#</a>分解解构</h4>
<ul>
<li>理解基础意思</li>
<li>创造和基础运用</li>
</ul>
<hr>
<h4 id="形成工具箱"><a class="header-anchor" href="#形成工具箱">#</a>形成工具箱</h4>
<ul>
<li>基础工具箱</li>
<li>自己的工具箱</li>
</ul>
]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>工作、消费主义和新穷人</title>
    <url>/Books/%E5%B7%A5%E4%BD%9C%E3%80%81%E6%B6%88%E8%B4%B9%E4%B8%BB%E4%B9%89%E5%92%8C%E6%96%B0%E7%A9%B7%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>人类创造的环境是一种快速、脆弱并伴随<strong>周期性</strong>的<strong>以多求少</strong>的系统。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="Topic-Introduction"><a class="header-anchor" href="#Topic-Introduction">#</a>Topic Introduction</h3>
<ol>
<li>
<p>创造工作伦理</p>
<ul>
<li>pass</li>
<li>pass<br>
<br></li>
</ul>
</li>
<li>
<p>Two</p>
<ul>
<li>pass</li>
<li>pass<br>
<br></li>
</ul>
</li>
<li>
<p>Three</p>
<ul>
<li>pass</li>
<li>pass</li>
</ul>
</li>
</ol>
<hr>
<h4 id="Topic"><a class="header-anchor" href="#Topic">#</a>Topic</h4>
<ul>
<li>pass</li>
</ul>
<hr>
<h4 id="Thanks"><a class="header-anchor" href="#Thanks">#</a>Thanks</h4>
<ul>
<li>pass</li>
</ul>
]]></content>
      <categories>
        <category>Books</category>
      </categories>
  </entry>
  <entry>
    <title>网络协议 - 相关补充</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文网络协议其他知识，包括常用的VPN、网络爬虫、HTTP缓存、IPv6、即时通信和流媒体。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="VPN"><a class="header-anchor" href="#VPN">#</a>VPN</h4>
<ul>
<li>
<p><strong>简介</strong></p>
<ul>
<li>VPN（Virtual Private Network）虚拟私人网络</li>
<li>能在公用网络上建立专用网络，并进行加密通讯</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%85%AC%E7%94%A8%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84VPN.png" alt="公用网络上的VPN"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>VPN - 作用</strong></p>
<ul>
<li>提高上网安全性  保护公司内部网络(外部网络访问公司内部服务器)</li>
<li>隐藏上网者身份（隐藏IP）</li>
<li>突破网站地域限制</li>
<li>突破网络封锁（GFW的限制）<br>
<br></li>
</ul>
</li>
<li>
<p><strong>VPN - 与代理区别</strong></p>
<ul>
<li>软件
<ul>
<li>VPN一般需要安装VPN客户端软件</li>
<li>代理不需要安装额外的软件</li>
</ul>
</li>
<li>安全性
<ul>
<li>VPN默认会对数据进行加密</li>
<li>代理默认不会对数据进行加密（数据最终是否加密取决于使用的协议本身</li>
</ul>
</li>
<li>费用
<ul>
<li>一般情况下，VPN比代理贵<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>VPN - 实现原理</strong></p>
<ul>
<li>VPN的实现原理是：使用了隧道协议（Tunneling Protocol）</li>
<li>常见的VPN隧道协议有 PPTP（Point to Point Tunneling Protocol）：点对点隧道协议</li>
<li>L2TP（Layer Two Tunneling Protocol）：第二层隧道协议</li>
<li>SSL VPN（如OpenVPN）</li>
<li>…<br>
<br></li>
</ul>
</li>
<li>
<p><strong>tcpdump</strong></p>
<ul>
<li>tcpdump是Linux平台的抓包分析工具，Windows版本是<a href="https://www.winpcap.org/windump/install/default.htm" rel="external nofollow noreferrer">WinDump</a></li>
<li><a href="https://www.tcpdump.org/manpages/tcpdump.1.html" rel="external nofollow noreferrer">使用手册</a></li>
<li><a href="https://danielmiessler.com/study/tcpdump/" rel="external nofollow noreferrer">教程</a></li>
</ul>
</li>
</ul>
<hr>
<h4 id="网络爬虫"><a class="header-anchor" href="#网络爬虫">#</a>网络爬虫</h4>
<ul>
<li>
<p><strong>概述</strong></p>
<ul>
<li>网络爬虫（Web Crawler），也叫做网蜘蛛（Web Spider）</li>
<li>网络爬虫是模拟人类使用浏览器操作页面的行为，对页面进行相关操作</li>
<li>常用的爬虫工具：Python的<a href="https://scrapy.org/" rel="external nofollow noreferrer">Scrapy</a>框架</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>网络爬虫 - 简易实例</strong></p>
<ul>
<li>使用Java小框架<a href="https://jsoup.org/" rel="external nofollow noreferrer">Jsoup</a>爬取一些简单数据</li>
<li>需要的jar包
<ul>
<li><a href="https://jsoup.org/packages/jsoup-1.13.1.jar" rel="external nofollow noreferrer">https://jsoup.org/packages/jsoup-1.13.1.jar</a></li>
<li><a href="https://mirror.bit.edu.cn/apache/commons/io/binaries/commons-io-2.8.0-bin.zip" rel="external nofollow noreferrer">https://mirror.bit.edu.cn/apache/commons/io/binaries/commons-io-2.8.0-bin.zip</a></li>
<li>爬取的目标：<a href="https://ext.se.360.cn/webstore/category" rel="external nofollow noreferrer">https://ext.se.360.cn/webstore/category</a><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>网络爬虫 - robots.txt</p>
<ul>
<li>存在于网络根目录的文件，例如：<a href="https://www.bilibili.com/robots.txt" rel="external nofollow noreferrer">https://www.bilibili.com/robots.txt</a></li>
<li>因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写</li>
</ul>
</li>
</ul>
<hr>
<h4 id="HTTP缓存"><a class="header-anchor" href="#HTTP缓存">#</a>HTTP缓存</h4>
<ul>
<li>
<p><strong>缓存(Cache)</strong></p>
<ul>
<li>
<p><strong>简单流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP%E7%BC%93%E5%AD%98%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B.png" alt="HTTP缓存简单流程"></p>
<ul>
<li>
<p>Resource cache (Memory cache and Disk cache)</p>
</li>
<li>
<p>通常会缓存的情况： GET请求 + 静态资源 （js,css,html,图片等）</p>
</li>
<li>
<p>Ctrl + F5 ：强制刷新缓存<br>
<br></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>缓存 - 响应头</strong></p>
<ul>
<li>
<p>Pragma：作用类似于Cache-Control， HTTP、1.0产物</p>
</li>
<li>
<p>Expires：缓存的过期时间（CMT格式），HTTP/1.0产物</p>
</li>
<li>
<p>Cache-Control：缓存策略</p>
<ul>
<li>no-storage：不缓存数据到本地</li>
<li>public：允许用户、代理服务器缓存数据到本地</li>
<li>private：只允许用户缓存数据到本地（默认）</li>
<li>max-age：缓存的有效时间，单位秒</li>
<li>no-cache：每次发请求给服务器询问缓存是否变化，再决定是否使用缓存</li>
</ul>
</li>
<li>
<p>优先级： Pragma &gt; cache-control &gt; Expires<br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>缓存 - 响应头</strong></p>
<ol>
<li>Last-Modified: 资源的最后一次修改时间</li>
<li>ETag: 资源的唯一标识（根据文件内同计算出的摘要值）</li>
<li>优先级 ETag &gt; Last - Modified<br>
<br></li>
</ol>
</li>
<li>
<p><strong>缓存 - 请求头</strong></p>
<ul>
<li>
<p><strong>If-None-Match</strong></p>
<ol>
<li>如果上一次响应头中有ETag，则将ETag值作为该请求头的值</li>
<li>如果服务器发现请求资源的最新摘要值与If-None-Match不匹配，就返回新资源（200 ok）</li>
<li>否则不返回资源具体数据（304 Not Modified）</li>
</ol>
</li>
<li>
<p><strong>If-Modified-Since</strong></p>
<ol>
<li>如果上一次响应头中没有ETag，有Last-Modified，则将Last-Modified值作为该请求头的值。</li>
<li>如果服务器发现请求资源的最后一次修改时间小于If-Modified-Since，就返回新资源（200 ok）</li>
<li>否则不返回资源具体数据（304 Not Modified）</li>
</ol>
</li>
<li>
<p><strong>Last-Modified</strong> 与<strong>ETag</strong> 区别</p>
<ul>
<li><strong>Last-Modified</strong>
<ol>
<li>只能精确到秒级别，如果资源部在1秒内被修改，客户端将无法获取最新数据</li>
<li>如果某些资源被修改了（最后一次修改时间发生变化），但是内容没有变化，就会导致数据重复传输，没有使用缓存</li>
</ol>
</li>
<li><strong>ETag</strong>
<ul>
<li>只要资源内容发生变化，就会返回最新的资源数据给客户端<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>缓存使用流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="HTTP缓存使用流程"></p>
</li>
</ul>
<hr>
<h4 id="IPv6"><a class="header-anchor" href="#IPv6">#</a>IPv6</h4>
<ul>
<li>
<p><strong>背景</strong></p>
<ul>
<li>IPv6（Internet Protocol version 6）</li>
<li>用它来取代IPv4主要是为了解决IPv4地址枯竭问题，同时它也在其他方面对于IPv4有许多改进</li>
<li>IPv6采用128位的地址，而IPv4使用的是32位</li>
<li>支持2^128（约3.4 ∗ 1038 ）个地址</li>
<li>就以地球人口70亿人计算，每人平均可分得约4.86 ∗ 10^28个IPv6地址<br>
<br></li>
</ul>
</li>
<li>
<p><strong>IPv6 - 地址格式</strong></p>
<ul>
<li>IPv6地址为128位，没16bit为一组，一共8组</li>
<li>每组用&quot;:&quot;隔开，每组4位十六进制方式表示
<ul>
<li>2001:0db8:86a3:08d3:1319:8a2e:0307:7344</li>
</ul>
</li>
<li>类似于IPv4的点分十进制的写法
<ul>
<li>2.0.0.1.0.d.b.8.8.6.a.3.0.8.d.3.1.3.1.9.8.a.2.e.0.3.0.7.7.3.4.4</li>
</ul>
</li>
<li>每组前面连续0可以省略
<ul>
<li>2001:0db8:86a3:0000:0000:0000:0307:7344</li>
<li>2001:0db8:86a3:0:0:0:0307:7344</li>
</ul>
</li>
<li>可以使用双冒号“::”表示一组或多组连续的0，但只能出现一次
<ul>
<li>2001:0db8:86a3:0000:0000:0000:0307:7344</li>
<li>2001:0db8:86a3::0307:7344</li>
</ul>
</li>
<li>::1是本地环回地址（0:0:0:0:0:0:0:1）
<ul>
<li><code>ping ::1</code></li>
<li><code>ping 127.0.0.1</code><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>IPv6 - 首部格式</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/IPv6-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="IPv6-首部格式"></p>
<ul>
<li>前面64位</li>
<li>有40个字节的固定首部</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/IPv4%E5%92%8CIPv6%E5%A4%B4%E9%83%A8%E5%AF%B9%E6%AF%94.png" alt="IPv4和IPv6头部对比"></p>
<ul>
<li>
<p>Version（占4bit，0110）：版本号</p>
</li>
<li>
<p>Traddic Class（占8bit）：交通类别</p>
<ul>
<li>指示数据包的类别或优先级，可以帮助路由器根据数据包的优先级处理流量</li>
<li>如果路由器发生拥塞，则优先级别最低的数据包将被丢弃</li>
</ul>
</li>
<li>
<p>Payload Length（占16bit）：有效负载长度</p>
<ul>
<li>最大致65535分字节</li>
<li>包括了扩展头部、上层（传输层）数据长度</li>
</ul>
</li>
<li>
<p>Hop Limit（占8bit）：跳数限制</p>
<ul>
<li>与IPv4数据包中的TTL相同</li>
</ul>
</li>
<li>
<p>Source Address（占128bit）：源IPv6地址</p>
</li>
<li>
<p>Destination Adress（占128bit）：目的IPv6地址</p>
</li>
<li>
<p>Flow Label(占20bit)：标签流</p>
<ul>
<li>指示数据包属于那以特定序列（流）</li>
<li>用数据包的源地址、目的地址、流标签标识一个流</li>
</ul>
</li>
<li>
<p>不包括固定40个字节<br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>IPv6 - 扩展头部</strong></p>
<ul>
<li>Next Header（占8bit）:下一个头部<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/IPv6%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%A4%B4%E9%83%A8.png" alt="IPv6下一个头部"></li>
<li>指示扩展头部（如果存在）的类型，上层数据包的协议类型（例如TCP，UDP）<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%8C%87%E7%A4%BA%E6%89%A9%E5%B1%95%E5%A4%B4%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%BC%96%E5%8F%B7.png" alt="指示扩展头协议类型对应编号"></li>
</ul>
</li>
</ul>
<hr>
<h4 id="即时通信"><a class="header-anchor" href="#即时通信">#</a>即时通信</h4>
<ul>
<li>
<p>即时通信（Instant Messaging，简称IM），平时用的QQ、微信，都属于典型的IM应用</p>
</li>
<li>
<p>国内的IM开发者社区</p>
<ul>
<li><a href="http://www.52im.net/" rel="external nofollow noreferrer">http://www.52im.net/</a></li>
</ul>
</li>
<li>
<p>IM云服务</p>
<ul>
<li><a href="https://netease.im/" rel="external nofollow noreferrer">网易云信</a>、<a href="https://cloud.tencent.com/product/im" rel="external nofollow noreferrer">腾讯云</a>、<a href="https://www.easemob.com/" rel="external nofollow noreferrer">环信</a>等。</li>
</ul>
</li>
<li>
<p>常用协议</p>
<ul>
<li>XMPP、MQTT、自定义协议</li>
</ul>
</li>
<li>
<p><strong>即时通信 - XMPP</strong></p>
<ul>
<li><a href="https://xmpp.org/" rel="external nofollow noreferrer">XMPP</a>（Extensible Messaging and Presence Protocol）</li>
<li>译为：可扩展消息与存在协议，前身是Jabber</li>
<li>基于TCP，默认端口5222、5269</li>
<li><strong>特点</strong>
<ul>
<li>使用XML格式进行传输，体积较大</li>
<li>比较成熟的IM协议，开发者接入方便</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>即时通信 - MQTT</strong></p>
<ul>
<li>
<p><a href="https://mqtt.org/" rel="external nofollow noreferrer">MQTT</a>（Message Queuing Telemetry Transport），译为：消息队列遥测传输</p>
</li>
<li>
<p>基于TCP，默认端口1883、8883（带SSL/TLS）</p>
</li>
<li>
<p><strong>特点</strong></p>
<ul>
<li>开销很小，以降低网络流量，信息冗余远小于XMPP</li>
<li>不是专门为IM设计的协议，很多功能需要自己实现</li>
<li>很多人认为MQTT是最适合物联网（IoT，Internet of Things）的网络协议</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1-MQTT.png" alt="即时通信-MQTT"></p>
</li>
</ul>
<hr>
<h4 id="流媒体"><a class="header-anchor" href="#流媒体">#</a>流媒体</h4>
<ul>
<li>
<p><strong>流媒体（Streaming Media），又叫流式媒体</strong></p>
<ul>
<li>是指将一连串的多媒体数据压缩后，经过互联网分段发送数据，在互联网上即时传输影音以供观赏的一种技术</li>
<li>此技术使得资料数据包得以像流水一样发送，不使用此技术，就必须在使用前下载整个媒体文件</li>
</ul>
</li>
<li>
<p><strong>流媒体 - 常见协议</strong></p>
<ul>
<li>RTP（Real-Time Transport Protocol），译为：实时传输协议
<ul>
<li>参考：<a href="https://datatracker.ietf.org/doc/html/rfc3550" rel="external nofollow noreferrer">RFC 3550</a>、<a href="https://datatracker.ietf.org/doc/html/rfc3551" rel="external nofollow noreferrer">RFC 3551</a>，基于UDP</li>
</ul>
</li>
<li>RTCP（Real-Time Transport Control Protocol），译为：实时传输控制协议
<ul>
<li>参考：<a href="https://datatracker.ietf.org/doc/html/rfc3550" rel="external nofollow noreferrer">RFC 3550</a>，基于UDP，使用RTP的下一个端口</li>
</ul>
</li>
<li>RTSP（Real-Time Streaming Protocol），译为：实时流协议，参考：<a href="https://datatracker.ietf.org/doc/html/rfc7820" rel="external nofollow noreferrer">RFC 7820</a>
<ul>
<li>基于TCP、UDP的554端口</li>
</ul>
</li>
<li>RTMP（Real-Time Messaging Protocol），译为：实时消息传输协议，由Adobe公司出品
<ul>
<li>默认基于TCP的1935端口</li>
</ul>
</li>
<li>HLS（HTTP Live Streaming），基于HTTP的流媒体网络传输协议，苹果公司出品，参考：<a href="https://datatracker.ietf.org/doc/html/rfc8216" rel="external nofollow noreferrer">RFC 8216</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>VPN</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - 其他协议</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍应用层除HTTPS之外的其他协议，包括支持全双工的WebSocket协议、HTTPDNS、文件传输协议FTP、邮件协议收发协议POP、IMAP(收)和SMTP(发)。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="区别WebSocket和Socket"><a class="header-anchor" href="#区别WebSocket和Socket">#</a>区别WebSocket和Socket</h4>
<ul>
<li>
<p>Socket：一套网络编程API,利用他可以建立网络连接，一般都是基于操作系统底层实现的(Socket编程)</p>
</li>
<li>
<p>WebSocket：网络协议。</p>
</li>
</ul>
<hr>
<h4 id="WebSocket协议"><a class="header-anchor" href="#WebSocket协议">#</a>WebSocket协议</h4>
<ul>
<li>
<p>背景</p>
<ul>
<li>HTTP请求的特点，通信只能由客户端发起（请求-应答 模式），所以早期的网站为了实现<strong>推送技术</strong>，!所用的技术都是轮询（直播，聊天，股票）</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/AJAX%E8%BD%AE%E8%AF%A2%E5%92%8CWebSocket.png" alt="AJAX轮询和WebSocket"></p>
<ul>
<li>**轮询：**由浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，然后服务器返回最新的数据给客户端</li>
<li>为了能更好的节省服务器资源和带宽，并且能够更实时地进行通讯，<strong>HTML5规范</strong>中出现了<strong>WebSocket协议</strong><br>
<br></li>
</ul>
</li>
<li>
<p><strong>WebSocket</strong></p>
<ul>
<li>
<p>WebSocket是<strong>基于TCP</strong>的支持<strong>全双工通信</strong>的<strong>应用层协议</strong></p>
<ul>
<li>在2011年由IETF标准化为 <a href="https://tools.ietf.org/html/rfc6455" rel="external nofollow noreferrer">RFC 6455</a>，后由 <a href="https://tools.ietf.org/html/rfc7936" rel="external nofollow noreferrer">RFC 7936</a> 补充规范</li>
<li>客户端、服务器，任何一方都可以主动发消息给对方<br>
<br></li>
</ul>
</li>
<li>
<p>WebSocket的应用场景</p>
<ul>
<li>社交订阅、股票基金报价、体育实况更新、多媒体聊天、多玩家游戏等<br>
<br></li>
</ul>
</li>
<li>
<p>WebSocket和 HTTP 属于<strong>平级关系</strong>，都是<strong>应用层的协议</strong></p>
<ul>
<li>其实TCP本身就是支持全双工通信的（客户端、服务器均可主动发消息给对方）</li>
<li>只是HTTP的 <strong>“请求-应答模式”</strong> 限制了TCP的能力<br>
<br></li>
</ul>
</li>
<li>
<p>WebSocket使用 80(ws://)、443(wss://) 端口，可以绕过大多数防火墙的限制（不能写#）</p>
<ul>
<li><code>ws://example.com/wsapi</code></li>
<li><code>wss://secure.example.com/wsapi</code><br>
<br></li>
</ul>
</li>
<li>
<p>与 HTTP 不同的是，WebSocket需要先建立连接（在应用层建立）</p>
<ul>
<li>这就使得WebSocket成为一种<strong>有状态的协议</strong>，之后通信时可以省略部分状态信息</li>
<li>而HTTP请求可能需要在每个请求都额外携带状态信息（如身份认证等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="WebSocket-建立连接"><a class="header-anchor" href="#WebSocket-建立连接">#</a>WebSocket - 建立连接</h4>
<ul>
<li>
<p>WebSocket需要借助 HTTP协议来建立连接（也叫作握手，<a href="https://tools.ietf.org/html/rfc6455#section-1.3" rel="external nofollow noreferrer">Handshake</a>）</p>
<ul>
<li>由客户端（浏览器）主动发出握手请求</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20221125214735.png" alt="浏览器发出握手请求"></p>
<ul>
<li>Connection必须设置Upgrade
<ul>
<li>表示客户端希望连接升级</li>
</ul>
</li>
<li>Upgrade必须设置webSocket
<ul>
<li>表示希望升级到WebSocket协议</li>
</ul>
</li>
<li>Sec-WebSocket-Version
<ul>
<li>表示支持的WebSocket版本</li>
<li><a href="https://tools.ietf.org/html/rfc6455" rel="external nofollow noreferrer">RFC 6455</a>要求使用的的是13</li>
</ul>
</li>
<li>Sec-WebSocket-Key是客户端随机生成的字符串</li>
<li>服务端收到客户端的Sec-WebSocket-Key后会执行以下操作
<ol>
<li>Sec-WebSocket-Key加上一个固定的<a href="https://tools.ietf.org/html/rfc4122" rel="external nofollow noreferrer">GUID</a>值</li>
<li>将1中的结果进行<a href="http://encode.chahuo.com/" rel="external nofollow noreferrer">SHA-1摘要计算</a></li>
<li>将2中的结果进行<a href="https://base64.guru/converter/encode/hex" rel="external nofollow noreferrer">Hex To Base64编码</a></li>
<li>将3中的结果作为Sec-WebSocket-Accept响应头的值，返回给客户端</li>
</ol>
</li>
<li>这样操作以后就能尽量避免普通的HTTP请求被误认为是WebSocket协议</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p>WebSocket - 使用</p>
<ul>
<li>
<p>WebSocket的体验和演示</p>
<ul>
<li><a href="https://www.websocket.org/echo.html" rel="external nofollow noreferrer">https://www.websocket.org/echo.html</a></li>
</ul>
</li>
<li>
<p>W3C标准化看一套<code>WebSocket</code> API 可以通过JS直接调用:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;wss://example.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="WebService"><a class="header-anchor" href="#WebService">#</a>WebService</h4>
<ul>
<li>
<p>WebService：Web服务，是一种跨编程语言和跨操作系统平台的远程调用技术标准<br>
<br></p>
</li>
<li>
<p>应用场景</p>
<ul>
<li>
<p>天气预报、手机归属地查询、航班信息查询、物流信息查询等，比如天气预报，是气象局把自己的服务以WebService形式暴露出来，让第三方程序可以调用这些服务功能</p>
</li>
<li>
<p><a href="http://www.webxml.com.cn/zh_cn/index.aspx" rel="external nofollow noreferrer">http://www.webxml.com.cn/zh_cn/index.aspx</a></p>
</li>
<li>
<p>后被<strong>Web API</strong>取代（例如：HTTP + JSON）（大多数使用）<br>
<br></p>
</li>
</ul>
</li>
<li>
<p>WebService传递数据</p>
<ul>
<li>WebService使用SOAP协议来封装传递数据
<ul>
<li>SOAP（Simple Object Access Protocol），译为：简单对象访问协议</li>
<li>很多时候，SOAP = HTTP + XML</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/WebService%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.png" alt="WebService传递数据"></p>
</li>
</ul>
<br>
<ul>
<li><strong>补充：</strong>
<ul>
<li>WSDL（Web Services Description Language），译为：Web服务描述语言</li>
<li>一个XML文档，用以描述WebService接口的细节（比如参数、返回值等）</li>
<li>一般在WebService的URL后面跟上?wsdl获取WSDL信息</li>
<li>比如：<a href="http://ws.webxml.com.cn/WebServices/WeatherWS.asmx?wsdl" rel="external nofollow noreferrer">http://ws.webxml.com.cn/WebServices/WeatherWS.asmx?wsdl</a></li>
</ul>
</li>
</ul>
<hr>
<h4 id="RESTful风格"><a class="header-anchor" href="#RESTful风格">#</a>RESTful风格</h4>
<ul>
<li>
<p><strong>简介：</strong></p>
<ul>
<li>
<p>RESTful的全称是：(REpresentational State Transfer)</p>
</li>
<li>
<p>REST是一种互联网架构设计风格</p>
<ul>
<li>定义一组用于创建Web服务的约束</li>
<li>符合REST架构的Web服务，称为为RESTful Web服务<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>RESTful的使用：</strong></p>
<ul>
<li>
<p>URL使用名词（建议使用复数形式），不使用动词</p>
<ul>
<li><strong>推荐</strong>：<code>users</code>、 <code>/users/6</code></li>
<li>不推荐：<code>/listUsers</code>、<code>/getUser？id=6</code>、<code>/user/list</code>、<code>/user/get?id=6</code></li>
</ul>
</li>
<li>
<p>使用HTTP 的请求方法表示动作</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/RESTful%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%8A%A8%E4%BD%9C.png" alt="RESTful风格的请求动作"></p>
<ul>
<li>
<p>一个资源连接到另一个资源，使用子资源的形式</p>
<ul>
<li>GET <code>/users/6/cars/88</code></li>
<li>POST <code>/users/8/cars</code></li>
</ul>
</li>
<li>
<p>API 的版本化</p>
<ul>
<li><code>baidu.com/v1/users</code></li>
<li><code>baidu.com/v2/users/66</code></li>
</ul>
</li>
<li>
<p>返回JSON格式数据</p>
</li>
<li>
<p>发生错误是，不要返回200的状态码</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="HTTPDNS"><a class="header-anchor" href="#HTTPDNS">#</a>HTTPDNS</h4>
<ul>
<li>
<p>简介</p>
<ul>
<li>HTTPDNS是基于HTTP协议向DNS服务器发送域名解析请求</li>
<li>替代了传统基于DNS协议向运营商Local DNS发起解析请求的传统方式</li>
<li>可以避免Local DNS造成的域名劫持和跨网访问问题</li>
<li>常用在移动互联网中（比如Android、iOS开发中）</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTPDNS%E5%92%8CLocalDNS%E6%AF%94%E8%BE%83.png" alt="HTTPDNS和LocalDNS比较"></p>
</li>
<li>
<p>使用：</p>
<ul>
<li>腾讯云：<a href="https://cloud.tencent.com/product/httpdns" rel="external nofollow noreferrer">https://cloud.tencent.com/product/httpdns</a></li>
<li>阿里云：<a href="https://help.aliyun.com/product/30100.html" rel="external nofollow noreferrer">https://help.aliyun.com/product/30100.html</a></li>
<li>使用移动端集成的相关SDK就可以使用HTTPDNS服务</li>
</ul>
</li>
</ul>
<hr>
<h4 id="FTP文件传输协议"><a class="header-anchor" href="#FTP文件传输协议">#</a>FTP文件传输协议</h4>
<ul>
<li>
<p>FTP的两种连接模式：<strong>主动（Active）和被动（Passive）</strong></p>
</li>
<li>
<p>不管是哪种模式，都需要客户端和服务器建立2个连接</p>
<ul>
<li>控制连接：用于传输状态信息（命令，CMD）</li>
<li>数据连接：用于传输文件和目录信息（data）</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/FTP%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="FTP的两种连接模式"></p>
<br>
<ul>
<li>
<p><strong>FTP - 主动模式</strong></p>
<ul>
<li>
<p><strong>客户端</strong></p>
<ul>
<li>客户端打开一个随机的命令端口（端口号大于1024，假设为N）,同时连接至服务器的命令端口21（固定不变）</li>
<li>客户端开始监听N+1数据端口，同时发送一个Port命令给服务器的命令端口21（告诉客户端正在监听N+1数据端口，并且已经准本好从此端口接受数据）</li>
</ul>
</li>
<li>
<p><strong>服务器</strong></p>
<ul>
<li>服务器打开20号数据端口，并创建和客户端端口（N+1）的连接</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/FTP%E4%B8%BB%E5%8A%A8%E6%A8%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="FTP主动模模式的流程"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>FTP - 被动模式</strong></p>
<ul>
<li>
<p><strong>客户端</strong></p>
<ul>
<li>
<p>客户端打开一个随机的命令端口（端口号大于1024，假设为N）,同时连接至服务器的命令端口21（固定不变）</p>
</li>
<li>
<p>客户端通过命令端口N发送PASV命令（开启被动模式）给服务器端口21</p>
</li>
<li>
<p>服务器打开一个随机的命令端口（端口号大于1024，假设为M），并告知该端口号给客户端</p>
</li>
<li>
<p>客户端数据端口N+1发起与服务器数据端口M的连接</p>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/FTP%E8%A2%AB%E5%8A%A8%E6%A8%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="FTP被动模模式的流程"></p>
</li>
</ul>
<hr>
<h4 id="邮件相关的协议"><a class="header-anchor" href="#邮件相关的协议">#</a>邮件相关的协议</h4>
<ul>
<li>
<p><strong>发邮件使用的协议</strong></p>
<ul>
<li>SMTP（Simple Mail Transfer Protocol），译为：简单邮件传输协议
<ol>
<li>基于TCP，标准参考<a href="https://tools.ietf.org/html/rfc5321" rel="external nofollow noreferrer">RFC 5321</a></li>
<li>服务器默认使用25端口，SSL/TLS使用465端口<br>
<br></li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>收邮件使用的协议</strong></p>
<ul>
<li>
<p>POP（Post Office Protocol），译为：邮局协议</p>
<ol>
<li>基于TCP，最新版是POP3，标准参考<a href="https://tools.ietf.org/html/rfc1939" rel="external nofollow noreferrer">RFC 1939</a></li>
<li>服务器默认使用110端口，SSL/TLS使用995端口<br>
<br></li>
</ol>
</li>
<li>
<p>IMAP（Internet Message Access Protocol），译为：因特网信息访问协议</p>
<ol>
<li>基于TCP，最新版是IMAP4，标准参考RFC 3501</li>
<li>服务器默认使用143端口，SSL/TLS使用993端口<br>
<br></li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>收发邮件流程</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%94%B6%E5%8F%91%E9%82%AE%E4%BB%B6%E6%B5%81%E7%A8%8B.png" alt="收发邮件流程"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>POP 和 IMAP对比</strong></p>
<ul>
<li>
<p><strong>POP的特点</strong></p>
<ul>
<li>
<p>客户端连接服务器时，将会从服务器<strong>下载所有邮件</strong></p>
</li>
<li>
<p>可以设置下载完后，立即或一段时间后删除服务器邮件</p>
</li>
<li>
<p>客户端的操作（比如删除邮件、移动到文件夹）<strong>不会跟服务器同步</strong></p>
</li>
<li>
<p>每个客户端都是<strong>独立的</strong>，都可以获得其自己的电子邮件副本</p>
</li>
</ul>
</li>
<li>
<p><strong>IMAP的特点</strong></p>
<ul>
<li>
<p>客户端连接服务器时，获取的是服务器上邮件的基本信息，并<strong>不会下载邮件</strong></p>
</li>
<li>
<p>等打开邮件时，<strong>才开始下载邮件</strong></p>
</li>
<li>
<p>客户端的操作（比如删除邮件、移动到文件夹）<strong>会跟服务器同步</strong></p>
</li>
<li>
<p>所有客户端<strong>始终会看到相同的邮件和相同的文件夹</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>RESTful</tag>
        <tag>HTTPDNS</tag>
        <tag>FTP</tag>
        <tag>SMTP</tag>
        <tag>POP</tag>
        <tag>IMAP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - HTTP1.1的升级改进</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20HTTP1.1%E7%9A%84%E5%8D%87%E7%BA%A7%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文先是介绍了HTTP1.1的相关问题，并由此介绍了HTTP1.1的升级版本HTTP2和HTTP3的新特性。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="HTTP协议的不足（HTTP1-1）"><a class="header-anchor" href="#HTTP协议的不足（HTTP1-1）">#</a>HTTP协议的不足（HTTP1.1）</h4>
<ul>
<li>
<p>同一时间，一次连接只能对应一次请求（也就是一次连接中只会有一个请求在处理，连接复用，多次请求需要排队迭代处理）</p>
</li>
<li>
<p>只允许客户端主动发起请求</p>
<ul>
<li>一个请求只能对应一个响应(<strong>请求 - 应答</strong> 模式)</li>
</ul>
</li>
<li>
<p>并发请求</p>
<ul>
<li>针对同一个域名，大多数浏览器允许同时最多<strong>6个并发连接</strong></li>
</ul>
</li>
<li>
<p>同一个会话的多次请求中，头信息会被重复传输</p>
<ul>
<li>通常会给每个传输增加 500~800 字节的开销</li>
<li>(如果使用 Cookie，增加的开销有时会达到上千字节)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="SPDY-协议"><a class="header-anchor" href="#SPDY-协议">#</a>SPDY 协议</h4>
<ul>
<li>
<p>SPDY (speedy的缩写)，是基于TCP的应用层协议，它<strong>强制要求使用 SSL/TLS</strong></p>
<ul>
<li>2009年11月，Google 宣布将 SPDY 作为提高网络速度的内部项目</li>
</ul>
</li>
<li>
<p>SPDY与HTTP的关系</p>
<ul>
<li>SPDY并不用于取代HTTP，它只是修改了HTTP请求与响应的传输方式</li>
<li>只需增加一个SPDY层，现有的所有服务端应用均不用做任何修改</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/SPDY%E4%B8%8EHTTP%E7%9A%84%E5%AF%B9%E6%AF%94.jpg" alt="SPDY与HTTP的对比"></p>
</li>
<li>
<p>SPDY是HTTP2的前身</p>
<ul>
<li>2015年9月，Google宣布移除对SPDY的支持，拥抱HTTP2</li>
<li>2015年9月，Google宣布移除对SPDY的支持，拥抱HTTP2</li>
</ul>
</li>
</ul>
<hr>
<h4 id="HTTP2"><a class="header-anchor" href="#HTTP2">#</a>HTTP2</h4>
<ul>
<li>
<p><strong>背景</strong></p>
<ul>
<li>
<p>HTTP2，于2015年5月以 <a href="https://tools.ietf.org/html/rfc7540" rel="external nofollow noreferrer">RFC 7540</a> 正式发表</p>
</li>
<li>
<p>根据 W3Techs 的数据，截至2019年6月，全球有36.5%的网站支持了HTTP2</p>
<ul>
<li>下列两个网站可以进行 HTTP1.1 和 HTTP2 速度对比
<ul>
<li><a href="http://www.http2demo.io/" rel="external nofollow noreferrer">http://www.http2demo.io/</a></li>
<li><a href="https://http2.akamai.com/demo" rel="external nofollow noreferrer">https://http2.akamai.com/demo</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>HTTP2不强制要求使用 SSL/TLS</p>
</li>
<li>
<p>HTTP2在底层传输做了很多的改进和优化，但在<strong>语意上完全与 HTTP1.1 兼容</strong></p>
<ul>
<li>比如请求方法（如GET、POST）、Status Code、各种Headers等都没有改变</li>
<li>因此，要想升级到 HTTP2开发者不需要修改任何代码只需要升级服务器配置、升级浏览器<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>HTTP2的特性 - 二进制格式</strong></p>
<ul>
<li>
<p>HTTP2 采用<strong>二进制格式</strong>传输数据，而非HTTP1.1的<strong>文本格式</strong>；</p>
</li>
<li>
<p>二进制格式在协议的解析和优化扩展上带来更多的优势和可能。</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E5%8D%87%E7%BA%A7%E6%94%B9%E8%BF%9B.png" alt="HTTP2的升级改进"></p>
</li>
</ul>
<br>  
<ul>
<li>
<p><strong>HTTP2基本概念 - 数据流、消息、帧</strong></p>
<ul>
<li>
<p><strong>数据流</strong>：</p>
<ul>
<li>已建立的连接内的<strong>双向字节流</strong>，可以承载一条或多条消息</li>
<li>所有通信都在<strong>一个TCP</strong>连接上完成，此连接可以（同一时间）承载任意数量的双向数据流</li>
</ul>
</li>
<li>
<p><strong>消息</strong>：</p>
<ul>
<li>与逻辑HTTP请求或响应消息对应，由一系列帧组成</li>
</ul>
</li>
<li>
<p><strong>帧</strong>：</p>
<ul>
<li>HTTP2通信的最小单位，每个帧都包含帧头（会标识出当前帧所属的数据流）</li>
<li>来自不同数据流的帧可以<strong>交错发送</strong>，然后再根据每个帧头的数据流标识符重新组装</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E5%B8%A7%E4%BC%A0%E8%BE%93.png" alt="HTTP2的帧传输"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E5%B8%A7%E5%86%85%E5%AE%B9.png" alt="HTTP2的帧内容"><br>
<br></p>
</li>
<li>
<p><strong>HTTP2的特性 - 多路复用（Multiplexing）</strong></p>
<ul>
<li>客户端和服务器可以将 HTTP消息分解为<strong>互不依赖的帧</strong>，然后<strong>交错发送</strong>，最后再在另一端把它们重新组装起来</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E7%89%B9%E6%80%A7-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="HTTP2的特性-多路复用"></p>
<ul>
<li>
<p>并行交错地发送多个<strong>请求</strong>，请求之间互不影响</p>
</li>
<li>
<p>并行交错地发送多个<strong>响应</strong>，响应之间互不干扰</p>
</li>
<li>
<p>使用一个连接并行发送多个请求和响应</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E5%90%8C%E6%97%B6%E5%8F%91%E9%80%81%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94.png" alt="HTTP2同时发送多个请求和响应"></p>
<ul>
<li>
<p>不必再为绕过HTTP1.1限制而做很多工作</p>
<ul>
<li>比如<strong>精灵图 (image sprites)</strong>、<strong>合并CSS\JS</strong>、<strong>内嵌CSS\JS\Base64图片</strong>、<strong>域名分片</strong>等</li>
<li><strong>精灵图 (image sprites)</strong></li>
<li>image sprites（也叫做CSS Sprites），将多张小图合并成一张大图</li>
<li>最后通过CSS结合小图的位置、尺寸进行精准定位</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E7%B2%BE%E7%81%B5%E5%9B%BE.png" alt="精灵图"></p>
<ul>
<li>base64：<a href="https://tool.jisuapi.com/pic2base64.html" rel="external nofollow noreferrer">https://tool.jisuapi.com/pic2base64.html</a><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>HTTP2的特性 - 优先级</strong></p>
<ul>
<li>
<p>HTTP2 标准允许每个数据流都有一个关联的权重和依赖关系</p>
<ul>
<li>可以向每个数据流分配一个介于1至256之间的整数</li>
<li>每个数据流与其他数据流之间可以存在显式依赖关系</li>
</ul>
</li>
<li>
<p>客户端可以构建和传递 “优先级树”，表明它倾向于如何接收响应</p>
</li>
<li>
<p>服务器可以使用此信息通过控制CPU、内存和其他资源的分配设定数据流处理的优先级</p>
<ul>
<li>在资源数据可用之后，确保将高优先级响应以最优方式传输至客户端</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E7%89%B9%E6%80%A7-%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="HTTP2的特性-优先级"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>HTTP2的特性 - 头部压缩</strong></p>
<ul>
<li>
<p><strong>背景：</strong></p>
</li>
<li>
<p><strong>早期版本</strong>的 HTTP2 和 SPDY 使用 <strong><code>zlib</code></strong> 压缩请求头和响应头</p>
<ul>
<li>可以将所传输头数据的大小减小85%~88%</li>
<li>但在2012年夏天，被攻击导致会话劫持</li>
<li>后被更<strong>安全</strong>的 <strong>HPACK</strong> 取代</li>
</ul>
</li>
<li>
<p>目前，HTTP2使用 <strong>HPACK</strong> 压缩请求头和响应头</p>
<ul>
<li>可以极大减少头部开销，进而提高性能（追踪上一次请求）</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E7%89%B9%E6%80%A7-%E5%8E%8B%E7%BC%A9%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4.png" alt="HTTP2的特性-压缩请求头和响应头"></p>
<ul>
<li>双方同时存储索引表，相同的头发送索引号</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E7%89%B9%E6%80%A7-%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E8%A1%A8-%E7%9B%B8%E5%90%8C%E7%9A%84%E5%A4%B4%E5%8F%91%E9%80%81%E7%B4%A2%E5%BC%95%E5%8F%B7.png" alt="HTTP2的特性-存储索引表-相同的头发送索引号"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>HTTP2的特性 - 服务器推送（Server Push）</strong></p>
<ul>
<li>
<p><strong>服务器可以对一个客户端请求发送多个响应</strong></p>
<ul>
<li>除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端额外明确地请求</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E7%89%B9%E6%80%A7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81.png" alt="HTTP2的特性-服务器推送"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>HTTP2的问题 - 队头阻塞（head of line blocking）</strong></p>
<ul>
<li>这是TCP底层的问题，QUIC协议(底层UDP)可以处理（超时重传）</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP2%E7%9A%84%E9%97%AE%E9%A2%98-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.png" alt="HTTP2的问题-队头阻塞"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/QUIC%E5%8D%8F%E8%AE%AE.png" alt="QUIC协议"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>HTTP2的问题 - 握手延迟</strong></p>
<ul>
<li><strong>RTT (Round Trip Time)</strong>：往返时延，可以简单理解为通信一来一回的时间</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/TCP+TLS%E6%8F%A1%E6%89%8B%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98.png" alt="TCP+TLS握手延迟问题"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTPS-OVER-TCP+TLS%E6%8F%A1%E6%89%8B%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98.png" alt="HTTPS-OVER-TCP+TLS握手延迟问题"></p>
</li>
</ul>
<hr>
<h4 id="HTTP3"><a class="header-anchor" href="#HTTP3">#</a>HTTP3</h4>
<ul>
<li>
<p><strong>背景</strong></p>
<ul>
<li>
<p>Google 觉得 HTTP2 仍然不够快，于是就有了 HTTP3</p>
<ul>
<li>HTTP3由Google开发，弃用TCP协议，改为使用基于UDP协议的QUIC协议实现</li>
<li>QUIC (Quick UDP Internet Connections)，快速UDP网络连接，由Google在2013年实现</li>
<li>于2018年从 HTTP-over-QUIC 改为 HTTP3</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP3.png" alt="HTTP3"></p>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>HTTP3 相关补充</strong></p>
<ul>
<li>由 QUIC协议来保证可靠传输</li>
<li>目前世界上的网络设备基本只认TCP、UDP
<ul>
<li>如果要修改传输层，意味着操作系统的内核也要修改</li>
<li>另外，由IETF标准化的许多TCP新特性都因缺乏广泛支持而没有得到广泛的部署或使用</li>
<li>因此，要想开发并应用一个新的传输层协议，是极其困难的一件事情<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>HTTP3的特性 - 连接迁移</strong></p>
<ul>
<li>
<p>TCP基于4要素：源IP、源端口、目标IP、目标端口</p>
<ul>
<li>切换网络时至少会有一个要素发生变化，导致连接发生变化</li>
<li>当连接发生变化时，如果还使用原来的TCP连接，则会导致连接失败，就得等原来的连接超时后重新建立连接</li>
<li>所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久</li>
<li>如果实现得好，当检测到网络变化时立刻建立新的TCP连接，即使这样，建立新的连接还是需要几百毫秒的时间<br>
<br></li>
</ul>
</li>
<li>
<p>QUIC的连接不受4要素的影响，当4要素发生变化时，原连接依然维持</p>
</li>
<li>
<p>QUIC连接不以4要素作为标识，而是使用一组 Connection ID (连接ID) 来标识一个连接</p>
</li>
<li>
<p>即使IP或者端口发生变化，只要Connection ID没有变化，那么连接依然可以维持<br>
<br></p>
</li>
<li>
<p>例如：</p>
<ul>
<li>当设备连接到Wi-Fi时，将进行中的下载从蜂窝网络连接转移到更快速的Wi-Fi连接</li>
<li>当Wi-Fi连接不再可用时，将连接转移到蜂窝网络连接<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>HTTP3的问题 - 操作系统内核、CPU负载</strong></p>
<ul>
<li>据Google和Facebook称，与基于TLS的HTTP2相比，它们大规模部署的QUIC需要近2倍的CPU使用量
<ul>
<li>Linux内核的UDP部分没有像TCP那样的优化，因为传统上没有使用UDP进行如此高速的信息传输</li>
<li>TCP和TLS有硬件加速，而这对于UDP很罕见，对于QUIC则基本不存在</li>
<li>随着时间的推移，相信这个问题会逐步得到改善<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>HTTP3的特性 - 向前纠错（还未成为标准）</strong></p>
<ul>
<li>基于TPC协议的话，丢包以后会重传。</li>
<li>HTTP3的向前纠错，丢包以后可以根据其他包推测出这个包的数据（只适合丢失少量数据）。但是目前还没有成为标准，以后是否会成为标准也不确定。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>SPDY</tag>
        <tag>HTTP2</tag>
        <tag>HTTP3</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - HTTPS</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20HTTPS/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍HTTPS相关概念，介绍了HTTPS就是HTTP在应用层和传输层间建立一个了TSL | SSL 连接，并使用Wireshark抓包TLS 1.2的连接（以ECDHE密钥交换算法为例）过程。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="HTTPS简介"><a class="header-anchor" href="#HTTPS简介">#</a>HTTPS简介</h4>
<ul>
<li><strong>HTTPS (HyperText Transfer Protocol Secure)</strong>，译为：<strong>超文本传输安全协议</strong>
<ul>
<li>
<p>常称为 <strong>HTTP over TLS</strong>、<strong>HTTP over SSL</strong>、<strong>HTTP Secure</strong></p>
</li>
<li>
<p>由网景公司于1994年首次提出</p>
</li>
<li>
<p>HTTPS的默认端口号是 <strong>443</strong> (HTTP是80)</p>
</li>
<li>
<p>现在在浏览器上输入 <a href="http://www.baidu.com" rel="external nofollow noreferrer">http://www.baidu.com</a>，会重定向到 <a href="https://www.baidu.com" rel="external nofollow noreferrer">https://www.baidu.com</a></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="SSL-TLS"><a class="header-anchor" href="#SSL-TLS">#</a>SSL / TLS</h4>
<ul>
<li>
<p>背景：</p>
<ul>
<li>
<p>HTTPS 是在 HTTP 的基础上使用 SSL/TLS来 加密报文，对<strong>窃听</strong>和<strong>中间人攻击</strong>提供合理的防护</p>
</li>
<li>
<p><strong>TLS (Transport Layer Security)</strong>，译为：<strong>传输层安全性协议</strong></p>
<ul>
<li>前身是 <strong>SSL (Secure Sockets Layer)</strong>，译为：<strong>安全套接层</strong></li>
</ul>
</li>
<li>
<p>历史版本信息</p>
<ol>
<li>SSL 1.0：因存在严重的安全漏洞，从未公开过</li>
<li>SSL 2.0：1995年，已于2011年弃用 (<a href="https://tools.ietf.org/html/rfc6176" rel="external nofollow noreferrer">RFC 6176</a>)</li>
<li>SSL 3.0：1996年，已于2015年弃用 (<a href="https://tools.ietf.org/html/rfc7568" rel="external nofollow noreferrer">RFC 7568</a>)</li>
<li>TLS 1.0：1999年 (<a href="https://tools.ietf.org/html/rfc2246" rel="external nofollow noreferrer">RFC 2246</a>)</li>
<li>TLS 1.1：2006年 (<a href="https://tools.ietf.org/html/rfc4346" rel="external nofollow noreferrer">RFC 4346</a>)</li>
<li>TLS 1.2：2008年 (<a href="https://tools.ietf.org/html/rfc5246" rel="external nofollow noreferrer">RFC 5246</a>)</li>
<li>TLS 1.3：2018年 (<a href="https://tools.ietf.org/html/rfc8446" rel="external nofollow noreferrer">RFC 8446</a>)</li>
</ol>
</li>
<li>
<p>SSL/TLS工作位置：</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/2021012600195775.png" alt="SSL/TLS工作位置"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>OpenSSL</strong></p>
<ul>
<li>
<p><a href="https://www.openssl.org/" rel="external nofollow noreferrer">OpenSSL</a> 是SSL/TLS协议的开源实现，始于1998年，支持Windows、Mac、Linux等平台</p>
</li>
<li>
<p>Linux、Mac 一般自带 OpenSSL</p>
</li>
<li>
<p>Windows下载安装OpenSSL：<a href="https://slproweb.com/products/Win32OpenSSL.html" rel="external nofollow noreferrer">https://slproweb.com/products/Win32OpenSSL.html</a><br>
<br></p>
</li>
<li>
<p>常用命令:</p>
<ul>
<li>
<p><strong>生成私钥</strong>：<code>openssl genrsa -out mj.key</code></p>
</li>
<li>
<p><strong>生成公钥</strong>：<code>openssl rsa -in mj.key -pubout -out mj.pem</code></p>
</li>
<li>
<p>可以使用 OpenSSL 构建一套属于自己的CA，自己给自己颁发证书，称为“<strong>自签名证书</strong>”</p>
</li>
</ul>
</li>
<li>
<p><code>Openssl help</code>查看支持的相关指令（算法）：</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Openssl%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4.png" alt="Openssl相关指令"></p>
<ul>
<li>查看某一指令的具体用法（举例：RSA）</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%9F%A5%E7%9C%8BRSA%E7%94%A8%E6%B3%95.png" alt="查看RSA用法"><br>
<br></p>
</li>
<li>
<p><strong>HTTPS的成本</strong></p>
<ul>
<li>
<p>证书的费用</p>
</li>
<li>
<p>加解密计算</p>
</li>
<li>
<p>降低了访问速度</p>
<ul>
<li>有些企业的做法是：包含敏感数据的请求才使用HTTPS，其他保持使用HTTP(工商银行)
<ul>
<li><a href="http://www.icbc.com.cn/" rel="external nofollow noreferrer">http://www.icbc.com.cn/</a></li>
<li><a href="https://mybank.icbc.com.cn/" rel="external nofollow noreferrer">https://mybank.icbc.com.cn/</a><br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>HTTPS的通信过程</strong></p>
<ul>
<li>总的可以分为3大阶段
<ul>
<li>TCP的3次握手</li>
<li>TLS的连接（下图中绿色部分）</li>
<li>HTTP请求和响应</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png" alt="HTTPS的通信流程"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>TLS 1.2 的连接（ECDHE密钥交换算法）</strong></p>
<ul>
<li><strong>TLS 1.2</strong> 的连接大概有10大步骤:（图中省略了中间产生的一些ACK确认）</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/TLS%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%88ECDHE%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%89.png" alt="TLS的连接（ECDHE密钥交换算法）"></p>
</li>
</ul>
<br>
<ul>
<li>
<p>Client Hello</p>
<ul>
<li>TLS的版本号</li>
<li>支持的加密组件 (Cipher Suite) 列表</li>
<li>加密组件是指所使用的加密算法及密钥长度等</li>
<li>一个随机数 (Client Random)<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Client-Hello.png" alt="Client-Hello"></li>
</ul>
</li>
</ul>
<br>
- Server Hello
  - TLS的版本号
  - 选择的加密组件
  - 是从接收到的客户端加密组件列表中挑选出来的
  - 一个随机数 (Server Random)
  - 补充：
    - GEM（分组模式<一段一段加密>）
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Server-Hello.png" alt="Server-Hello"></p>
<br>
<ul>
<li>
<p>Certificate</p>
<ul>
<li>服务器的公钥证书（被CA签名过的）</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Certificate.png" alt="Certificate"></p>
</li>
</ul>
<br>
<ul>
<li>
<p>Server Key Exchange</p>
<ul>
<li>用以实现ECDHE算法的其中一个参数 (Server Params)</li>
<li>ECDHE是一种密钥交换算法</li>
<li>为了防止伪造，Server Params 经过了服务器私钥签名</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Server-Key-Exchange.png" alt="Server-Key-Exchange"></p>
</li>
</ul>
<br>
<ul>
<li>
<p>Server Hello Done</p>
<ul>
<li>告知客户端：协商部分结束</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Server-Hello-Done.png" alt="Server-Hello-Done"></p>
<ul>
<li>目前为止，客户端和服务器之间通过明文共享了Client Random、Server Random、Server Params<br>
而且，客户端也已经拿到了服务器的公钥证书，接下来，客户端会验证证书的真实有效性<br>
<br></li>
</ul>
</li>
<li>
<p>Client Key Exchange</p>
<ul>
<li>用以实现ECDHE算法的另一个参数 (Client Params)</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Client-Key-Exchange.png" alt="Client-Key-Exchange"></p>
<ul>
<li>目前为止，客户端和服务器都拥有了ECDHE算法需要的2个参数：Server Params、Client Params<br>
客户端、服务器都可以使用ECDHE算法根据Server Params、Client Params计算出一个新的随机密钥串：Pre-master secret</li>
<li>然后结合 Client Random、Server Random、Pre-master secret 生成一个主密钥</li>
<li>最后利用自己的（客户端或服务器）主密钥衍生出其他密钥：客户端发送用的会话密钥、服务器发送用的会话密钥等</li>
<li>然后自己再利用自己对应的密钥（客户端发送用的会话密钥）加密后对方会用与之对应的（客户端的会话密钥）密钥解密（使用的是对称加密）</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p>Change Cipher Spec</p>
<ul>
<li>告知服务器：之后的通信会采用计算出来的会话密钥进行加密</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Change-Cipher-Spec.png" alt="Change-Cipher-Spec"></p>
</li>
</ul>
<br>
<ul>
<li>
<p>Finished</p>
<ul>
<li>包含连接至今全部报文的整体校验值（摘要），加密之后发送给服务器</li>
<li>这次握手协商是否成功，要以服务器是否能够正确解密该报文作为判定标准</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Finished.png" alt="Finished"></p>
</li>
</ul>
<br>
<ul>
<li>
<p>Change Cipher Spec &amp; Finished</p>
<ul>
<li>到此为止，客户端服务器都验证加密解密没问题，握手正式结束</li>
<li>后面开始传输加密的HTTP请求和响应</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Change-Cipher-Spec-Finished.png" alt="Change-Cipher-Spec-Finished"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Encrypted-Handshake-Handshake-Message.png" alt="Encrypted-Handshake-Handshake-Message"></p>
</li>
<li>
<p>抓包总体流程</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%8A%93%E5%8C%85%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="抓包总体流程"></p>
</li>
</ul>
<hr>
<h4 id="使用Wireshark解密HTTPS"><a class="header-anchor" href="#使用Wireshark解密HTTPS">#</a>使用Wireshark解密HTTPS</h4>
<ul>
<li>
<p>设置环境变量SSLKEYLOGFILE（浏览器会将key信息导出到这个文件）</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/SSLKEYLOGFILE.png" alt="SSLKEYLOGFILE"></p>
<ul>
<li>如果环境变量不管用，可以直接设置浏览器的启动参数</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E8%AE%BE%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0.png" alt="设置浏览器的启动参数"></p>
<ul>
<li>在wireshark中加载<code>TLS.log</code>文件位置</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%8A%A0%E8%BD%BDTLS.log%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE.png" alt="加载TLS.log文件位置"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%9C%A8Wireshark%E4%B8%AD%E7%9A%84HTTPS.png" alt="在Wireshark中的HTTPS"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>配置Tomcat服务器HTTPS</strong></p>
<ul>
<li>生成证书
<ul>
<li>一个生成免费证书的网站：<a href="https://freessl.org/" rel="external nofollow noreferrer">https://freessl.org/</a><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>自签生成证书</strong>：</p>
<ul>
<li>环境：Tomcat9.0.34、JDK1.8.0_251
<ul>
<li>首先，使用JDK自带的 <strong>keytool</strong> 生成证书</li>
<li>文件名为：.jks(java key store)</li>
<li><code>keytool -genkeypair -alias sg -keyalg rsa -keystore F:/sg.jks</code></li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%9C%A8F%E7%9B%98%E4%B8%8B%E7%94%9F%E6%88%90sg.jks.png" alt="在F盘下生成sg.jks"></p>
<ul>
<li>
<p>将证书 *<strong>.jks</strong> 文件放到 TOMCAT_HOME/conf 目录下</p>
</li>
<li>
<p>修改 TOMCAT_HOME/conf/server.xml 中的 Connector</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Tomcat%E9%85%8D%E7%BD%AEHTTPS.png" alt="Tomcat配置HTTPS"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>TLS</tag>
        <tag>SSL</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - 网络安全</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍Web网络传输过程中的安全问题和相关技术。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="网络安全简介"><a class="header-anchor" href="#网络安全简介">#</a>网络安全简介</h4>
<ul>
<li>网络通信中面临的4种安全威胁
<ul>
<li><strong>截获</strong>：窃听通信内容</li>
<li><strong>中断</strong>：中断网络通信</li>
<li><strong>篡改</strong>：篡改通信内容</li>
<li><strong>伪造</strong>：伪造通信内容</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E4%B8%BB%E5%8A%A8%E6%94%BB%E5%87%BB%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%94%BB%E5%87%BB.png" alt="主动攻击和被动攻击"></p>
<hr>
<h4 id="网络层-ARP欺骗"><a class="header-anchor" href="#网络层-ARP欺骗">#</a>网络层 - ARP欺骗</h4>
<ul>
<li>
<p><strong>ARP欺骗 (ARP spoofing)</strong>，又称<strong>ARP毒化 (ARP poisoning)</strong>、<strong>ARP病毒</strong>、<strong>ARP攻击</strong></p>
</li>
<li>
<p>ARP欺骗的效果</p>
<ul>
<li>可让攻击者<strong>获取局域网上的数据包</strong>甚至可<strong>篡改数据包</strong></li>
<li>可让网络上特定<strong>电脑之间无法正常通信</strong>（例如<strong>网络执法官</strong>这样的软件）</li>
<li>让送至特定IP地址的流量被错误送到攻击者所取代的地方</li>
<li>…</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/ARP%E6%AC%BA%E9%AA%97%E6%B5%81%E7%A8%8B.png" alt="ARP欺骗流程"><br>
<br></p>
<ul>
<li>
<p><strong>ARP欺骗防护</strong></p>
<ul>
<li>静态ARP</li>
<li>DHCP Snooping
<ul>
<li>网络设备可借由DHCP保留网络上各电脑的MAC地址，在伪造的ARP数据包发出时即可侦测到</li>
<li>利用一些软件监听ARP的不正常变动</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="DoS、DDoS-介绍与防御"><a class="header-anchor" href="#DoS、DDoS-介绍与防御">#</a>DoS、DDoS 介绍与防御</h4>
<ul>
<li>
<p><strong>DoS攻击介绍和分类</strong></p>
<ul>
<li>DoS攻击（拒绝服务攻击，Denial-of-Service attack）
<ul>
<li>使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问</li>
<li>带宽消耗型：UDP洪水攻击、ICMP洪水攻击</li>
<li>资源消耗型：SYN洪水攻击、LAND攻击<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>DDoS攻击</strong>（分布式拒绝服务攻击，Distributed Denial-of-Service attack）</p>
<p>黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动DoS攻击<br>
2018年3月，GitHub遭到迄今为止规模最大的DDoS攻击<br>
<br></p>
</li>
<li>
<p><strong>DoS、DDoS防御</strong></p>
<ul>
<li>防御方式通常为：入侵检测、流量过滤、多重验证</li>
<li>堵塞网络带宽的流量将被过滤，而正常的流量可正常通过<br>
<br></li>
</ul>
</li>
<li>
<p><strong>防火墙</strong></p>
<ul>
<li>防火墙可以设置规则，例如允许或拒绝特定通讯协议，端口或IP地址</li>
<li>当攻击从少数不正常的IP地址发出时，可以简单的使用拒绝规则阻止一切从攻击源IP发出的通信</li>
<li>复杂攻击难以用简单规则来阻止，例如80端口遭受攻击时不可能拒绝端口所有的通信，因为同时会阻止合法流量</li>
<li>防火墙可能处于网络架构中过后的位置，路由器可能在恶意流量达到防火墙前即被攻击影响<br>
<br></li>
</ul>
</li>
<li>
<p><strong>交换机</strong></p>
<ul>
<li>大多数交换机有一定的速度限制和访问控制能力<br>
<br></li>
</ul>
</li>
<li>
<p><strong>路由器</strong></p>
<ul>
<li>和交换机类似，路由器也有一定的速度限制和访问控制能力<br>
<br></li>
</ul>
</li>
<li>
<p><strong>黑洞引导</strong></p>
<ul>
<li>将所有受攻击计算机的通信全部发送至一个“黑洞”（空接口或不存在的计算机地址）或者有足够能力处理洪流的网络设备商，以避免网络受到较大影响<br>
<br></li>
</ul>
</li>
<li>
<p><strong>流量清洗</strong></p>
<ul>
<li>当流量被送到DDoS防护清洗中心时，通过采用抗DDoS软件处理，将正常流量和恶意流量区分</li>
<li>正常的流量则回注回客户网站</li>
</ul>
</li>
</ul>
<hr>
<h4 id="传输层-SYN洪水攻击（SYN-flooding-attack）"><a class="header-anchor" href="#传输层-SYN洪水攻击（SYN-flooding-attack）">#</a>传输层 - SYN洪水攻击（SYN flooding attack）</h4>
<ul>
<li>
<p>攻击者发送一系列的SYN请求到目标，然后让目标因收不到ACK（第3次握手）而进行等待、消耗资源</p>
</li>
<li>
<p>攻击方法</p>
<ul>
<li>跳过发送最后的ACK信息</li>
<li>修改源IP地址，让目标送SYN-ACK到伪造的IP地址，因此目标永不可能收到ACK（第3次握手）</li>
</ul>
</li>
<li>
<p>防护参考：<a href="https://tools.ietf.org/html/rfc4987" rel="external nofollow noreferrer">RFC 4987</a></p>
</li>
</ul>
<hr>
<h4 id="传输层-LAND攻击"><a class="header-anchor" href="#传输层-LAND攻击">#</a>传输层 - LAND攻击</h4>
<ul>
<li>
<p><strong>LAND攻击</strong>（局域网拒绝服务攻击，Local Area Network Denial attack）</p>
<ul>
<li>通过持续发送相同源地址和目标地址的欺骗数据包，使目标试图与自己建立连接，消耗系统资源直至崩溃</li>
<li>有些系统存在设计上的缺陷，允许设备接受并响应来自网络、却宣称来自于设备自身的数据包，导致循环应答</li>
</ul>
</li>
<li>
<p>防护</p>
<ul>
<li>大多数防火墙都能拦截类似的攻击包，以保护系统</li>
<li>部分操作系统通过发布安全补丁修复了这一漏洞</li>
<li>路由器应同时配置上行与下行筛选器，屏蔽所有源地址与目标地址相同的数据包</li>
</ul>
</li>
</ul>
<hr>
<h4 id="应用层-DNS劫持、HTTP劫持"><a class="header-anchor" href="#应用层-DNS劫持、HTTP劫持">#</a>应用层 - DNS劫持、HTTP劫持</h4>
<ul>
<li>
<p><strong>DNS劫持</strong>，又称为<strong>域名劫持</strong>(篡改域名解析结果)</p>
<ul>
<li>攻击者篡改了某个域名的解析结果，使得指向该域名的IP变成了另一个IP</li>
<li>导致对相应网址的访问被劫持到另一个不可达的或者假冒的网址</li>
<li>从而实现非法窃取用户信息或者破坏正常网络服务的目的（窃取密码）</li>
</ul>
</li>
<li>
<p>为防止DNS劫持，可以考虑使用更靠谱的DNS服务器，比如：114.114.114.114</p>
<ul>
<li>国内114DNS：<a href="https://www.114dns.com/" rel="external nofollow noreferrer">https://www.114dns.com/</a></li>
<li>谷歌：8.8.8.8、8.8.4.4</li>
<li>微软：4.2.2.1、4.2.2.2</li>
<li>百度：180.76.76.76</li>
<li>阿里：223.5.5.5、223.6.6.6</li>
</ul>
</li>
<li>
<p><strong>HTTP劫持</strong>：对HTTP数据包进行 拦截处理，比如插入JS代码</p>
<ul>
<li>访问某些网站时，在右下角多了个莫名其妙的弹窗广告。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="HTTP协议的安全问题"><a class="header-anchor" href="#HTTP协议的安全问题">#</a>HTTP协议的安全问题</h4>
<ul>
<li>
<p>HTTP协议默认是采取<strong>明文传输</strong>的，因此会有很大的安全隐患</p>
<ul>
<li>常见的提高安全性的方法是：对通信内容进行加密后，再进行传输<br>
<br></li>
</ul>
</li>
<li>
<p><strong>常见的加密方式</strong></p>
<ul>
<li>
<p><strong>不可逆</strong></p>
<ul>
<li>单向散列函数：MD5、SHA等</li>
</ul>
</li>
<li>
<p><strong>可逆</strong></p>
<ul>
<li>对称加密：DES、3DES、AES等</li>
<li>非对称加密：RSA等</li>
</ul>
</li>
<li>
<p><strong>其它</strong></p>
</li>
<li>
<p><strong>混合密码系统</strong></p>
</li>
<li>
<p><strong>数字签名</strong></p>
</li>
<li>
<p><strong>证书</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">encrypt：加密</span><br><span class="line">encrypt：加密</span><br><span class="line">decrypt：解密</span><br><span class="line">plaintext：明文</span><br><span class="line">ciphertext：密文</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>单向散列函数（One-way hash function）</strong></p>
<ul>
<li>
<p>单向散列函数，可以根据根据消息内容计算出散列值(<strong>固定长度</strong>)。</p>
<ul>
<li><strong>单向散列函数</strong>，也被称为<strong>消息摘要函数（message digest function）哈希函数（hash function）</strong></li>
<li><strong>输出的散列值</strong>，也被称<strong>消息摘要（message digest）指纹（fingerprint）</strong></li>
</ul>
</li>
<li>
<p><strong>单向散列函数网站</strong></p>
<ul>
<li>MD5加密：<a href="https://www.cmd5.com/hash.aspx" rel="external nofollow noreferrer">https://www.cmd5.com/hash.aspx</a></li>
<li>MD5解密：<a href="https://www.cmd5.com/" rel="external nofollow noreferrer">https://www.cmd5.com/</a></li>
<li><a href="https://www.sojson.com/encrypt_des.html" rel="external nofollow noreferrer">https://www.sojson.com/encrypt_des.html</a></li>
<li><a href="https://tool.chinaz.com/tools/md5.aspx" rel="external nofollow noreferrer">https://tool.chinaz.com/tools/md5.aspx</a></li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0.png" alt="单向散列函数"><br>
<br></p>
</li>
<li>
<p><strong>单向散列函数特点</strong></p>
<ul>
<li>
<p>​根据任意长度的消息，计算出<strong>固定长度的散列值</strong></p>
</li>
<li>
<p>​<strong>计算速度快</strong>，能快速计算出散列值</p>
</li>
<li>
<p>​具备<strong>单向性</strong>(不可逆)</p>
<ul>
<li>根据消息能计算出散列值，但是根据散列值不可计算出消息。</li>
</ul>
</li>
<li>
<p>消息不同，散列值不同，具有<strong>雪崩效应</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%95%A3%E5%88%97%E5%80%BC%E4%B8%8D%E9%9A%8F%E5%86%85%E5%AE%B9%E8%A7%84%E5%BE%8B%E5%8F%98%E5%8C%96.png" alt="散列值不随内容规律变化"><br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>常见的几种单向散列函数</strong></p>
<ul>
<li><strong>MD4</strong>，<strong>MD5</strong>（MD Message Digest 的缩写，目前不安全）产生128bit的散列值，MD就是Message Digest的缩写</li>
<li><strong>SHA-1</strong>（目前已经不安全）产生160bit的散列值</li>
<li><strong>SHA-2</strong><br>
SHA-256，SHA-384，SHA-512，散列值长度分别是256bit，384bit，512bit</li>
<li><strong>SHA-31</strong><br>
全新标准<br>
<br></li>
</ul>
</li>
<li>
<p><strong>单向散列函数 - 防止数据被篡改</strong></p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8.png" alt="单向散列函数应用"></p>
<ul>
<li>
<p>单向散列函数 - 防止数据被篡改的应用：</p>
<ul>
<li>例如 <a href="https://www.realvnc.com/en/connect/download/vnc/" rel="external nofollow noreferrer">RealVNC</a>下载界面，通过给出的一串 SHA-256，用于检验下载后的文件是否被篡改。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>单向散列函数 - 密码加密</strong></p>
<ul>
<li>现在数据库不会直接存储密码明文，存储的都是加密过后的值。（所以现在的<strong>找回密码</strong>也无法看到原密码，只能重置成新密码）<br>
<br></li>
</ul>
</li>
<li>
<p><strong>对称加密</strong>（Symmetric Cryptography）</p>
<ul>
<li>
<p>在<strong>对称加密</strong>的过程中、<strong>加密</strong>和<strong>解密</strong>使用的都是一个密钥</p>
</li>
<li>
<p>常用的对称加密的算法：</p>
<ul>
<li>DES（不安全）</li>
<li>3DES</li>
<li>AES<br>
<br></li>
</ul>
</li>
<li>
<p><strong>DES（Data Encryption Standard）</strong></p>
<ul>
<li>DES 是一种将 64bit 明文加密成 64bit 密文的对称加密算法，密钥长度是 56bit</li>
<li>规格上来说，密钥长度是 64bit，但每隔 7bit 会设置一个用于错误检查的 ，因此密钥长度实质上是 56bit</li>
<li>由于DES 每次只能加密 64bit 的数据，遇到比较大的数据，需要对 DES 加密进行迭代（反复）</li>
<li>目前已经可以在短时间内被破解，所以不建议使用<br>
<br></li>
</ul>
</li>
<li>
<p><strong>3DES（Triple Data Encryption Algorithm）</strong></p>
<ul>
<li>
<p>3DES ，将 DES 重复 3 次所得到的一种密码算法，也叫做 3重DES</p>
</li>
<li>
<p>三重DES 并不是进行三次 DES 加密（加密 → 加密 → 加密）而是：</p>
<ul>
<li>加密过程： 加密(Encryption) → 解密(Decryption) → 加密(Encryption) 的过程（会用到3次密钥）</li>
<li>解密过程： 解密(Encryption) → 加密(Decryption) → 解密(Encryption) 的过程（会用到3次密钥顺序不变）</li>
</ul>
</li>
<li>
<p>目前还被一些银行等机构使用，但处理速度不高，安全性逐渐暴露出问题</p>
</li>
<li>
<p>由于3个密钥都是不同的，也称为 <strong>DES-EDE3</strong></p>
</li>
<li>
<p>如果密钥1、密钥3相同，密钥2不同（中间），称为 <strong>DES-EDE2</strong></p>
</li>
<li>
<p>如果<strong>所有密钥都使用同一个</strong>，则结果与普通的 DES 是等价的<br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>AES（Advanced Encryption Standard）</strong></p>
<ul>
<li>
<p>AES 取代 DES 成为新标准的一种对称加密算法，又称 Rijndeal加密法(安全)</p>
</li>
<li>
<p>AES 的密钥长度有 128、192、256bit 三种</p>
</li>
<li>
<p>目前 AES 已经逐步取代 DES、3DES ，成为首选的对称加密算法</p>
</li>
<li>
<p>一般来说，我们也不应该去使用任何自制的密码算法，而是应该使用 AES</p>
<ul>
<li>它经过了全世界密码学家所进行的高品质验证工作<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>密钥配送问题</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%AF%86%E9%92%A5%E9%85%8D%E9%80%81.png" alt="密钥配送"><br>
<br></p>
</li>
<li>
<p><strong>有以下几种解决密钥配送的方法</strong></p>
<ul>
<li>事先共享密钥（比如私下共享）</li>
<li>密钥分配中心（Key Distribution Center，简称 KDC）</li>
<li>Diffie-Hellman 密钥交换</li>
<li>pki</li>
<li><strong>非对称加密</strong><br>
<br></li>
</ul>
</li>
<li>
<p><strong>非对称加密（Asymmetric Cryptography）</strong></p>
<ul>
<li>在<strong>非对称加密</strong>中，密钥分为加密密钥、解密密钥 2种，它们并不是同一个密钥</li>
<li><strong>加密密钥</strong>：一般是公开的，因此该密钥称为<strong>公钥</strong>(public key)</li>
<li>因此，<strong>非对称加密</strong>也被称为公钥密码(Public-key Cryptography)</li>
<li><strong>解密密钥</strong>：由消息接收者自己保管的，不能公开，因此也称为<strong>私钥</strong>(private key)<br>
<br></li>
</ul>
</li>
<li>
<p><strong>公钥、私钥</strong></p>
<ul>
<li>
<p>公钥和私钥是一一对应的，不能单独生成</p>
</li>
<li>
<p>一对公钥和私钥统称为<strong>密钥对</strong>(key pair)</p>
<ul>
<li>
<p>由<strong>公钥</strong>加密的密文，必须使用与该<strong>公钥</strong>对应的<strong>私钥</strong>才能解密</p>
</li>
<li>
<p>由<strong>私钥</strong>加密的密文，必须使用与该<strong>私钥</strong>对应的<strong>公钥</strong>才能解密<br>
<br></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>密钥配送问题解决方案</strong></p>
<ul>
<li>由消息的接收者，生成<strong>一对公钥、私钥</strong></li>
<li>将公钥发给消息的发送者</li>
<li>消息的发送者使用公钥加密消息</li>
<li>为什么要用非对称加密解决密钥配送问题，而不是直接使用非对称加密传输消息呢？
<ul>
<li><strong>非对称加密的加密解密速度比对称加密要慢</strong>，直接用来传输消息效率低</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%85%AC%E9%92%A5%E4%BD%93%E5%88%B6%E8%A7%A3%E5%86%B3%E5%AF%86%E9%92%A5%E9%85%8D%E9%80%81%E9%97%AE%E9%A2%98.png" alt="公钥体制解决密钥配送问题"><br>
<br></p>
<ul>
<li>
<p><strong>RSA</strong></p>
<ul>
<li>
<p>目前使用最广泛的<strong>非对称加密</strong>算法是 RSA</p>
</li>
<li>
<p><strong>混合密码系统（Hybrid Cryptosystem) - 加密、解密</strong></p>
</li>
<li>
<p><strong>对称加密</strong>的缺点</p>
<ul>
<li>不能很好的解决<strong>密钥配送</strong>的问题（密钥在传输过程中可能被窃听）</li>
</ul>
</li>
<li>
<p><strong>非对称加密的缺点</strong></p>
<ul>
<li>加密速度比较满慢</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>混合密码加密</strong>：是将<strong>对称加密</strong>和<strong>非对称加密</strong>的优势相<strong>结合</strong>的方法</p>
<ul>
<li>解决<strong>非对称加密</strong>的加密速度慢问题</li>
<li>解决<strong>对称加密</strong>的<strong>密钥配送</strong>问题<br>
<br></li>
</ul>
</li>
<li>
<p><strong>补充</strong></p>
<ul>
<li>
<p>网络上的密码通信所用的SSL/TLS都运用了混合密码系统</p>
</li>
<li>
<p><strong>混合密码的加密</strong></p>
<ul>
<li>
<p><strong>会话密钥（session key）</strong></p>
<ul>
<li>为本次通信随机生成的临时密钥</li>
<li>作为<strong>对称加密</strong>的密钥，用于<strong>加密消息</strong>，提高速度</li>
</ul>
</li>
<li>
<p>加密步骤（发送消息）</p>
<ul>
<li>首先，消息发送者要拥有消息接收者的公钥</li>
<li>生成会话密钥，作为对称加密的密钥，加密消息</li>
<li>用消息接收者的公钥，加密会话密钥</li>
<li>将前 步生成的加密结果，一并发给消息接收者</li>
</ul>
</li>
<li>
<p>发送出去的内容包括：</p>
<ul>
<li>用会话密钥加密的消息（加密方法：对称加密）</li>
<li>用公钥加密的会话密钥（加密方法：非对称加密）</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png" alt="对称和非对称混合加密"><br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>数字签名</strong></p>
<ul>
<li>
<p>产生背景</p>
<ul>
<li>一个人给另一个人发送消息，接收者如何确认这段消息的真实性（如何识别<strong>篡改、伪装、否认</strong>），也就产生了解决方案： <strong>数字签名</strong></li>
</ul>
</li>
<li>
<p>在数字签名技术的两种行为：</p>
<ul>
<li>
<p><strong>生成签名</strong></p>
<ul>
<li>由消息发送者完成，通过“签名密钥”生成</li>
</ul>
</li>
<li>
<p><strong>验证签名</strong></p>
<ul>
<li>由消息接收者完成，通过“验证密钥”验证</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如何能保证这个签名是消息发送者自己签的？</p>
<ul>
<li>用<strong>消息发送者的私钥</strong>进行<strong>签名</strong>任何人都可以用<strong>消息发送者的公钥</strong>进行<strong>检验</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数字签名过程：</strong></p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20210124231215490.png" alt="数字签名"><br>
<br></p>
<p><strong>数字签名 - 过程优化：</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%BC%98%E5%8C%96.jpg" alt="数字签名优化"></p>
<ul>
<li>
<p>补充：</p>
<ul>
<li>数字签名作9用不是保证机密性，仅仅是为了能够识别内容有没有篡改（类似做独特标记）</li>
</ul>
</li>
<li>
<p>数字签名的作用</p>
<ul>
<li>确认消息的<strong>完整性</strong></li>
<li>识别消息是否被<strong>篡改</strong></li>
<li>防止消息发送人<strong>否认</strong><br>
<br></li>
</ul>
</li>
<li>
<p><strong>非对称加密 - 公钥、私钥总结</strong></p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%85%AC%E9%92%A5%E3%80%81%E7%A7%81%E9%92%A5%E6%80%BB%E7%BB%93.png" alt="公钥、私钥总结"></p>
<ul>
<li>
<p><strong>数字签名</strong>，就是将<strong>非对称加密</strong>反过来使用</p>
</li>
<li>
<p>一句话总结<strong>签名</strong>和<strong>加密</strong>（针对自己而言）：</p>
<ul>
<li>
<p><strong>加密</strong>：不希望第三者知道（别人发给我的）和我相关的消息，所以希望（加密过的）消息只有自己能解密。</p>
</li>
<li>
<p><strong>公钥</strong>（公开）负责<strong>加密</strong>，<strong>私钥</strong>负责<strong>解密</strong></p>
</li>
<li>
<p><strong>签名</strong>：自己不希望别人冒充我发送给其他人的消息，所以需要只有我自己才能签名</p>
</li>
<li>
<p><strong>私钥</strong>负责<strong>签名</strong>，<strong>公钥</strong>（公开）负责<strong>验签</strong><br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>证书（Certificate）</strong></p>
<ul>
<li>
<p>背景</p>
<ul>
<li>由于<strong>公钥</strong>在网络中传播（无法唯一标识对方<strong>公钥</strong>是不是真正在相互交流的人），所以无法确认是否存在中间人攻击的情况</li>
<li>也就是可能会存在公钥是中间人（双方）伪造的情况</li>
<li>也就出现了<strong>证书</strong>（第三方）来验证公钥的合法性。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="中间人攻击"></p>
</li>
<li>
<p>密码学中的证书，全称叫<strong>公钥证书 (Public-key Certificate，PKC)</strong>，跟驾驶证类似</p>
</li>
<li>
<p>里面有姓名、邮箱等个人信息，以及此人的<strong>公钥</strong></p>
</li>
<li>
<p>并由 <strong>认证机构 (Certificate Authority，CA)</strong> 施加数字签名</p>
<ul>
<li>CA 就是能够认定 “公钥确实属于此人” 并能够生成数字签名的个人或者组织</li>
<li>有国际性组织、政府设立的组织</li>
<li>有通过提供认证服务来盈利的企业</li>
<li>个人也可以成立认证机构</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="证书的使用流程"></p>
<ul>
<li>
<p>各大CA的公钥，默认已经内置在<strong>浏览器</strong>和<strong>操作系统</strong>中</p>
</li>
<li>
<p>证书 - 注册和下载<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E4%B8%8B%E8%BD%BD.png" alt="证书的注册和下载"><br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>补充：</strong></p>
</li>
<li>
<p>查看 Windows 已经信任的证书</p>
<ul>
<li>Windows键 + R &gt;&gt;&gt; 输入<code>mmc</code></li>
<li>文件 &gt;&gt;&gt; 添加/删除管理单元</li>
<li>证书 &gt;&gt;&gt; 添加 &gt;&gt;&gt; 我的用户账户 &gt;&gt;&gt; 完成 &gt;&gt;&gt; 确定</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/Windows%E6%9F%A5%E7%9C%8B%E5%B7%B2%E7%BB%8F%E4%BF%A1%E4%BB%BB%E7%9A%84%E8%AF%81%E4%B9%A6.png" alt="Windows查看已经信任的证书"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>DoS</tag>
        <tag>RSA</tag>
        <tag>AES</tag>
        <tag>CA</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda 使用教程</title>
    <url>/Software-Testing/Anaconda%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍Anaconda相关概念和作用，着重介绍了Anaconda常用命令。</li>
</ul>
<span id="more"></span>
<h4 id="Anaconda-简介"><a class="header-anchor" href="#Anaconda-简介">#</a>Anaconda 简介</h4>
<ul>
<li>
<p><a href="https://www.anaconda.com/" rel="external nofollow noreferrer">Anaconda</a>就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。<br>
<br></p>
</li>
<li>
<p>Anaconda、conda、pip、virtualenv的区别</p>
<ul>
<li>Anaconda
<ul>
<li>Anaconda是一个包含180+的科学包及其依赖项的发行版本。其包含的科学包包括：conda, numpy, scipy, ipython notebook等。</li>
</ul>
</li>
<li>conda
<ul>
<li>conda是包及其依赖项和环境的管理工具。</li>
</ul>
</li>
<li>pip
<ul>
<li>pip是用于安装和管理软件包的包管理器。</li>
</ul>
</li>
<li>virtualenv
<ul>
<li>virtualenv是用于创建一个独立的Python环境的工具。</li>
</ul>
</li>
<li>pip 与 conda 比较
<ul>
<li>依赖项检查
<ul>
<li>pip：不一定会展示所需其他依赖包，安装包时或许会直接忽略依赖项而安装，仅在结果中提示错误。</li>
<li>conda：列出所需其他依赖包；安装包时自动安装其依赖项；可以便捷地在包的不同版本中自由切换。</li>
</ul>
</li>
<li>环境管理
<ul>
<li>pip：维护多个环境难度较大。</li>
<li>conda：比较方便地在不同环境之间进行切换，环境管理较为简单。</li>
</ul>
</li>
<li>对系统自带Python的影响
<ul>
<li>pip：在系统自带Python中包的更新/回退版本/卸载将影响其他程序。</li>
<li>conda：不会影响系统自带Python。</li>
</ul>
</li>
<li>适用语言
<ul>
<li>pip：仅适用于Python。</li>
<li>conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。</li>
</ul>
</li>
</ul>
</li>
<li>conda与pip、virtualenv的关系
<ul>
<li>conda结合了pip和virtualenv的功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Anaconda-常用命令"><a class="header-anchor" href="#Anaconda-常用命令">#</a>Anaconda 常用命令</h4>
<ul>
<li>
<p><code>conda list</code> 查看安装了哪些包。</p>
</li>
<li>
<p><code>conda env list</code> 或 <code>conda info -e</code> 查看当前存在哪些虚拟环境</p>
</li>
<li>
<p><code>conda update conda</code> 检查更新当前conda</p>
</li>
<li>
<p><code>activate your_env_name</code> 激活当前环境</p>
</li>
<li>
<p><code>conda info --envs</code> 查看现有环境</p>
</li>
<li>
<p><code>conda create -n your_env_name python=X.X（2.7、3.6等)</code></p>
<ul>
<li>
<p>命令创建python版本为X.X、名字为your_env_name的虚拟环境。</p>
</li>
<li>
<p>your_env_name文件可以在Anaconda安装目录envs文件下找到。</p>
</li>
</ul>
</li>
<li>
<p><code>conda install -n your_env_name &lt;package&gt;</code>对虚拟环境中安装额外的包</p>
</li>
<li>
<p><code>conda deactivate</code> 关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)。</p>
</li>
<li>
<p><code>conda env remove --name your_env_name</code> 删除虚拟环境</p>
</li>
<li>
<p><code>conda env remove --name your_env_name package_name</code> 删除环境中的某个包。</p>
</li>
<li>
<p><code>conda config --remove-key channels</code> 恢复默认源，十分好使</p>
</li>
<li>
<p><code>conda install --yes --file requirements.txt</code> 一次性安装若干依赖</p>
</li>
<li>
<p><code>conda install scikit-learn-intelex</code> 可以加速</p>
</li>
<li>
<p><code>conda install &lt;package&gt;</code></p>
</li>
<li>
<p><code>conda unintall &lt;package&gt;</code></p>
</li>
<li>
<p><code>pip install &lt;package&gt;</code></p>
</li>
<li>
<p><code>pip unintall &lt;package&gt;</code></p>
</li>
<li>
<p><code>conda -help</code></p>
</li>
</ul>
<hr>
<h4 id="Anaconda-环境和包管理"><a class="header-anchor" href="#Anaconda-环境和包管理">#</a>Anaconda 环境和包管理</h4>
<ul>
<li>
<p>conda命令全自动安装Python包到指定环境</p>
<ul>
<li>
<p>激活当前环境</p>
<ul>
<li><code>activate &lt;you_environment&gt;</code></li>
</ul>
</li>
<li>
<p>安装指定包</p>
<ul>
<li><code>conda install &lt;pkg_name&gt;</code></li>
</ul>
</li>
<li>
<p>查找所需要的包</p>
<ul>
<li><code>anaconda search -t conda &lt;pkg_name&gt;</code></li>
</ul>
</li>
<li>
<p>获取包的相关信息</p>
<ul>
<li><code>anaconda show path/&lt;pkg_name&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>pip命令全自动安装Python包到指定环境</p>
<ul>
<li>
<p>激活当前环境</p>
<ul>
<li><code>activate &lt;you_environment&gt;</code></li>
</ul>
</li>
<li>
<p><code>easy_install &lt;pkg_name&gt; 或者 pip install &lt;pkg_name&gt; 或者 pip3 install &lt;pkg_name&gt;</code></p>
</li>
</ul>
</li>
<li>
<p>线下安装Python包到指定环境</p>
<ul>
<li>
<p>激活当前环境</p>
<ul>
<li><code>activate &lt;you_environment&gt;</code></li>
</ul>
</li>
<li>
<p>Anaconda安装本地whl包</p>
<ul>
<li><code>pip install 路径/whl文件名</code></li>
</ul>
</li>
<li>
<p>半自动安装&lt;pkg_name&gt;</p>
<ul>
<li>
<p>进入已解压的&lt;pkg_name&gt;文件夹下，可以看到setup.py文件，</p>
</li>
<li>
<p>直接在地址栏输入%comspec%，进入该目录的命令提示python.exe <a href="http://setup.py" rel="external nofollow noreferrer">setup.py</a> install，回车键后进行自动安装</p>
</li>
</ul>
</li>
<li>
<p>手动安装：将 &lt;pkg_name&gt; （指定的环境在envs）目录放置于当前目录或者 site-packages 目录</p>
<ul>
<li>Venv（虚拟环境）是Python用来创建和管理虚拟环境的模块</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Python扩展包的非官方Windows二进制文件</p>
<ul>
<li><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" rel="external nofollow noreferrer">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></li>
</ul>
</li>
<li>
<p>添加添加清华大学镜像</p>
<ul>
<li><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="Anaconda-环境的克隆"><a class="header-anchor" href="#Anaconda-环境的克隆">#</a>Anaconda 环境的克隆</h4>
<ul>
<li>
<p>复制或克隆环境：</p>
<ul>
<li>
<p>在本机上复制</p>
<ul>
<li><code>conda create -n &lt;environment]–clone &lt;new_environment]</code></li>
</ul>
</li>
<li>
<p>复制到其他机器</p>
<ul>
<li>
<p>方式一</p>
<ul>
<li>激活要导出的环境
<ul>
<li><code>conda activate &lt;environment]</code></li>
</ul>
</li>
<li>导出环境
<ul>
<li><code>conda env export ] &lt;environment].yaml</code></li>
</ul>
</li>
<li>使用yaml配置文件创建新环境
<ul>
<li><code>conda env create -f &lt;environment].yaml</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>方式二(只能复制环境中以conda install安装的包，不能复制pip install安装的包)</p>
<ul>
<li>导出环境
<ul>
<li><code>conda list --explicit ] env.txt</code></li>
</ul>
</li>
<li>创建新环境
<ul>
<li><code>conda create -n newenv -f env.txt</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="致谢"><a class="header-anchor" href="#致谢">#</a>致谢</h5>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/32925500" rel="external nofollow noreferrer">Anaconda介绍、安装及使用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Software Testing</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>conda</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - 应用层</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍网站请求流程中所用到的协议DNS，HTTP和DHCP相关概念和作用。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="应用层协议"><a class="header-anchor" href="#应用层协议">#</a>应用层协议</h4>
<ul>
<li>常见的应用层协议：
<ol>
<li>超文本传输：HTTP、HTTPS</li>
<li>文件传输：FTP</li>
<li>电子邮件：SMTP、POP3、IMAP</li>
<li>动态主机配置：DHCP</li>
<li>域名系统：DNS</li>
</ol>
</li>
</ul>
<hr>
<h4 id="域名"><a class="header-anchor" href="#域名">#</a>域名</h4>
<ul>
<li>
<p><strong>背景</strong></p>
<ul>
<li>由于IP地址不方便记忆，并且不能表达组织的名称和性质，人们设计出了 <strong>域名（<a href="http://xn--baidu-gv5i.com" rel="external nofollow noreferrer">如baidu.com</a>）</strong></li>
<li>但实际上，为了能够访问到具体的主机，<strong>最终还是得知道目标主机的IP地址</strong></li>
<li>域名申请注册：<a href="https://wanwang.aliyun.com/" rel="external nofollow noreferrer">https://wanwang.aliyun.com/</a></li>
<li>直接使用域名至少需要十几个字节，会增加路由器负担，浪费流量。</li>
</ul>
</li>
<li>
<p><strong>域名的级别和分类</strong></p>
<ul>
<li><strong>顶级域名（Top-lever Domain 简成TLD）</strong>
<ul>
<li><strong>通用顶级域名（General Top-level Domain，简称 gTLD）</strong>
<ul>
<li>.com（公司），.net（网络机构），.org（组织机构），.edu（教育）</li>
<li>.gov（政府部门），.int（国际组织）等</li>
</ul>
</li>
<li><strong>国家及地区顶级域名（Country Code Top-level Domain，简称 ccTLD）</strong>
<ul>
<li>.cn（中国）、.jp（日本）、.uk（英国）</li>
</ul>
</li>
<li><strong>新通用顶级域名（New Generic Top-level Domain，简称 New gTLD）</strong>
<ul>
<li>.vip、.xyz、.top、.club、.shop 等</li>
</ul>
</li>
</ul>
</li>
<li><strong>二级域名</strong>(顶级域名下的域名)
<ul>
<li>在<strong>通用顶级域名下</strong>，它一般指<strong>域名注册人的名称</strong>，例如 google、baidu、microsoft 等
<ul>
<li>例：<a href="http://google.com" rel="external nofollow noreferrer">google.com</a>、<a href="http://baidu.com" rel="external nofollow noreferrer">baidu.com</a>、<a href="http://microsoft.com" rel="external nofollow noreferrer">microsoft.com</a></li>
</ul>
</li>
<li>在<strong>国家及地区顶级域名</strong>下，它一般指<strong>注册类别</strong>的，例如 com、edu、gov、net 等
<ul>
<li>例：<a href="http://china.com.cn" rel="external nofollow noreferrer">china.com.cn</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%9F%9F%E5%90%8D%E7%9A%84%E7%BA%A7%E5%88%AB%E5%92%8C%E5%88%86%E7%B1%BB.png" alt="域名的级别和分类"></p>
</li>
</ul>
<hr>
<h5 id="DNS服务器和常用命令"><a class="header-anchor" href="#DNS服务器和常用命令">#</a>DNS服务器和常用命令</h5>
<ul>
<li>
<p><strong>简介</strong></p>
<ul>
<li>
<p>DNS的全称是：<strong>Domain Name System</strong>，译为：<strong>域名系统</strong></p>
</li>
<li>
<p>利用DNS协议，可以将 <strong>域名（<a href="http://xn--baidu-gv5ij80i.com" rel="external nofollow noreferrer">比如baidu.com</a>）</strong> 解析成对应的 <strong>IP地址（比如220.181.38.148）</strong></p>
</li>
<li>
<p>DNS可以基于UDP协议(<strong>大多数</strong>)，也可以基于TCP协议，服务器占用<strong>53端口</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>DNS解析流程</strong></p>
<ul>
<li>DNS服务器先访问最近的一台DNS服务器（就是是客户端自己配置的DNS服务器，也叫做本地DNS服务器）</li>
<li>所有的DNS服务器都记录了DNS<strong>根域名服务器</strong>的IP地址</li>
<li>上级DNS服务器记录了下级DNS服务器的IP地址</li>
<li>全球一共<strong>13台IPv4</strong>的DNS根域名服务器,<strong>25台IPv6</strong>的DNS根域名服务器<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/DNS%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png" alt="DNS解析流程"></li>
</ul>
</li>
<li>
<p><strong>DNS 常用命令</strong></p>
<ul>
<li><code>ipconfig /displaydns</code> 查看DNS缓存记录</li>
<li><code>ipconfig /flushdns</code> 清空DNS缓存记录</li>
<li><code>ping 域名</code> ping 域名会自动解析DNS</li>
<li><code>nslookup 域名</code> 主动解析DNS</li>
</ul>
</li>
</ul>
<hr>
<h4 id="IP地址的分配"><a class="header-anchor" href="#IP地址的分配">#</a>IP地址的分配</h4>
<ul>
<li>
<p><strong>静态IP地址</strong></p>
<ul>
<li>手动设置</li>
<li>适用场景： 不需要挪动的台式机（学校机房的台式机），服务器等</li>
</ul>
</li>
<li>
<p><strong>动态IP地址</strong></p>
<ul>
<li>DHCP服务器自动获取IP地址</li>
<li>适用场景： 移动设备、无线设备等<br>
<br></li>
</ul>
</li>
<li>
<p><strong>DHCP</strong>（DISCOVER OFFER REQUEST ACKNOWLEDGE）动态主机配置协议</p>
<ul>
<li>
<p>DHCP 是基于<strong>UDP协议的</strong>，客户端是<strong>68端口，<strong>服务器是</strong>67端口</strong>（双方端口固定）</p>
</li>
<li>
<p>DHCP服务器会从IP地址池中，挑选一份IP地址“<strong>出租</strong>”给客户端一段时间，时间到期就会回收</p>
</li>
<li>
<p>平时家里上网的路由器就可充当DHCP服务器。</p>
</li>
</ul>
</li>
<li>
<p><strong>DHCP的分配IP的四个阶段</strong></p>
<ul>
<li>
<p><strong>DISCOVER : 发现（服务器）</strong></p>
<ul>
<li>发送广播包（源IP是0.0.0.0，目标IP是255.255.255.255，目标MAC是FF:FF:FF:FF:FF:FF）</li>
</ul>
</li>
<li>
<p><strong>OFFER ：提供租约</strong></p>
<ul>
<li>服务器返回可以“租用”的IP地址、租用期限、子网掩码、网关、DNS等信息（注意：这里可能会有多个服务器提供租约）</li>
</ul>
</li>
<li>
<p><strong>REQUEST：选择IP地址</strong></p>
<ul>
<li>客户端选择一个OFFER，发送广播包进行回应</li>
</ul>
</li>
<li>
<p><strong>ACKNOWLEDGE：确认</strong></p>
<ul>
<li>被选中的服务器发送ACK数据包给客户端</li>
</ul>
</li>
<li>
<p><strong>DHCP一些细节</strong></p>
<ul>
<li>DHCP服务器是可以跨网段的，通过借助DHCP中继代理（DHCP Replay Agent）实现跨网段分配IP地址</li>
<li>客户端会在租期不足时，自动向DHCP服务器发送REQUEST信息申请续约</li>
<li>一些常用命令
<ul>
<li><code>ipconfig /all</code>：可以看到DHCP相关的详细信息，比如租约过期时间、DHCP服务器地址等</li>
<li><code>ipconfig /release</code>：释放租约</li>
<li><code>ipconfig /renew</code>：重新申请IP地址、申请续约（延长租期）<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/DHCP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png" alt="DHCP请求流程"></li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/DHCP%E6%8A%93%E5%8C%85.png" alt="DHCP抓包"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="HTTP协议"><a class="header-anchor" href="#HTTP协议">#</a>HTTP协议</h4>
<ul>
<li>
<p><strong>HTTP简介</strong></p>
<ul>
<li>
<p><strong>超文本传输协议</strong>（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</p>
</li>
<li>
<p>设计HTTP最初的目的是为了提供一种发布和接收<a href="https://www.hk.wiiaa.top/baike-HTML" rel="external nofollow noreferrer">HTML</a>页面的方法。通过HTTP或者<a href="https://www.hk.wiiaa.top/baike-HTTPS" rel="external nofollow noreferrer">HTTPS</a>协议请求的资源由<a href="https://www.hk.wiiaa.top/baike-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" rel="external nofollow noreferrer">统一资源标识符</a>（Uniform Resource Identifiers，URI）来标识。</p>
</li>
<li>
<p>后来HTTP协议传递的数据格式不仅仅是HTML，还包括图片，音频等，应用非常广泛。</p>
</li>
<li>
<p>HTTP是<strong>超文本标记语言</strong>。</p>
<ul>
<li>1991年，HTTP/0.9
<ul>
<li>只支持GET请求方法获取文本数据（比如HTML文档），且不支持请求头、响应头等，无法向服务器传递太多信息</li>
</ul>
</li>
<li>1996年，HTTP/1.0
<ul>
<li>支持POST、HEAD等请求方法，支持请求头、响应头等，支持更多种数据类型（不再局限于文本数据）</li>
<li>浏览器的每次请求都需要与服务器建立一个TCP连接，请求处理完成后立即断开TCP连接</li>
</ul>
</li>
<li>1997年，HTTP/1.1（最经典、使用最广泛的版本）
<ul>
<li>支持PUT、DELETE等请求方法</li>
<li>采用持久连接（Connection: keep-alive），多个请求可以共用同一个TCP连接</li>
</ul>
</li>
<li>2015年，HTTP/2.0</li>
<li>2018年，HTTP/3.0<br>
<br></li>
</ul>
</li>
<li>
<p>HTTP的标准</p>
<ul>
<li>由万维网协会（W3C）、互联网工程任务组（IETF）协调制定，最终发布了一系列的<a href="https://www.rfc-editor.org/standards" rel="external nofollow noreferrer">RFC</a>（Request For Comments，可以译为：请求意见稿）</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20210119001837544.png" alt="HTTP报文格式"></p>
</li>
<li>
<p><strong>相关补充</strong></p>
<ul>
<li>
<p>URI与URL区别</p>
<ul>
<li>URI统一资源标志符（英语：Uniform Resource Identifier，缩写：URI）在电脑术语中是用于标识某一互联网资源名称的字符串。</li>
<li>URL是一种URI，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。可能通过对主要访问手段的描述，也可能通过网络“位置”进行标识。</li>
</ul>
</li>
<li>
<p><strong>与URL和URN的关系</strong></p>
<ul>
<li>URI可被视为定位符（URL），名称（URN）或两者兼备。<a href="https://www.hk.wiiaa.top/baike-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%90%8D" rel="external nofollow noreferrer">统一资源名</a>（URN）如同一个人的名称，而<a href="https://www.hk.wiiaa.top/baike-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" rel="external nofollow noreferrer">统一资源定位符</a>（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。</li>
<li>技术上讲，URL和URN属于资源ID</li>
</ul>
</li>
<li>
<p><a href="http://www.asciima.com/" rel="external nofollow noreferrer">ASCll码表</a></p>
<ul>
<li>不同操作系统换行方式区别(CRLF)
<ul>
<li>windows: \r\n（回车换行）</li>
<li>linux: /n</li>
<li>mac: /r<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>ABNF</strong>（Augmented BNF）</p>
<ul>
<li>
<p><strong>简介</strong>：</p>
<ul>
<li>ABNF是BNF（Backus-Naur Form，译为：巴科斯-瑙尔范式）的修改、增强版</li>
<li>在 <a href="https://tools.ietf.org/html/rfc5234" rel="external nofollow noreferrer">RFC 5234</a> 中表明：<strong>ABNF用作 internet 中通信协议的定义语言</strong></li>
<li>ABNF是<strong>最严谨的HTTP报文格式描述形式</strong>，脱离ABNF谈论HTTP报文格式，往往都是不严谨的</li>
<li>关于HTTP报文的定义:
<ul>
<li><a href="https://tools.ietf.org/html/rfc2616#section-4" rel="external nofollow noreferrer">RFC 2616 4.HTTP Message</a>（旧）</li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-3" rel="external nofollow noreferrer">RFC 7230 3.Message Format</a>（新）</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>ABNF</strong> - 核心规则</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/ABNF-%E6%A0%B8%E5%BF%83%E8%A7%84%E5%88%99.png" alt="ABNF-核心规则"></p>
</li>
<li>
<p><strong>HTTP报文格式 - 整体</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-%E6%95%B4%E4%BD%93.png" alt="HTTP报文格式-整体"></p>
</li>
<li>
<p><strong>报文格式 - request-line、status -line</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210415092631967.png" alt="报文格式1"></p>
</li>
<li>
<p><strong>报文格式 - header-filed、message-body</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210415093146558.png" alt="报文格式2"></p>
</li>
<li>
<p><strong>URL的编码</strong>​    - URL中一旦出现了一些特殊字符（比如中文、空格），需要进行 <a href="https://tool.oschina.net/encode?type=4" rel="external nofollow noreferrer">编码</a></p>
<ul>
<li>
<p>在浏览器地址栏输入URL时，是采用 <strong>UTF-8</strong> 进行编码</p>
</li>
<li>
<p>例如:</p>
<ul>
<li><code>http://localhost:8080/socket/image/初音.png</code></li>
<li><code>http://localhost:8080/socket/image/%E5%88%9D%E9%9F%B3.png</code></li>
</ul>
</li>
<li>
<p>Host请求头指明了请求将要发送到的服务器主机名和端口号。Host让虚拟主机托管成为了可能，也就是一个IP上提供多个Web服务。<br>
<br></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Xshell + telnet 面向报文与服务器交互</strong></p>
<ul>
<li>
<p><code>telnet</code> 命令可以理解为 <strong>建立TCP连接</strong>，然后我们可以 <strong>直接输入报文</strong> 来获取响应。</p>
</li>
<li>
<p>简单的 HTTP 报文格式：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">GET /hello/ HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>RFC只是规范，服务器在实现相关的功能可能会提高容错能力（也就是不遵守规范）</p>
</li>
</ul>
</li>
<li>
<p><strong>请求方法</strong>(9种)</p>
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc7231#section-4" rel="external nofollow noreferrer">RFC 7231, section 4: Request methods</a>：描述了 8 种请求方法<br>
GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE</p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc5789#section-2" rel="external nofollow noreferrer">RFC 5789, section 2: Patch method</a>：描述了 PATCH 方法</p>
</li>
<li>
<p>GET：常用于读取的操作，请求参数直接拼接在URL的后面（浏览器对URL是有长度限制）</p>
</li>
<li>
<p>POST：常用于添加、修改、删除的操作，请求参数可以放到请求体中（没有大小限制）</p>
</li>
<li>
<p>HEAD：请求得到与GET请求相同的响应，但没有响应体使用场景：在下载一个大文件前，先获取其大小(HEAD)，再决定是否要下载(GET)。以此可以节约带宽资源。</p>
</li>
<li>
<p><strong>OPTIONS</strong>：用于获取目的资源所支持的通信选项，比如 <strong>服务器支持的请求方法</strong></p>
</li>
<li>
<p>OPTIONS * HTTP/1.1</p>
</li>
<li>
<p>通过向 Tomcat 发送 OPTIONS请求，可以知道它支持以下请求方法<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/OPTIONS%E8%AF%B7%E6%B1%82.png" alt="OPTIONS请求"></p>
</li>
<li>
<p>PUT：用于对已存在的资源进行整体覆盖</p>
</li>
<li>
<p>PATCH：用于对资源进行部分修改（资源不存在，会创建新的资源）</p>
</li>
<li>
<p>DELETE：用于删除指定的资源</p>
</li>
<li>
<p>TRACE：请求服务器回显其收到的请求信息，主要用于HTTP请求的测试或诊断</p>
</li>
<li>
<p>CONNECT：可以开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道（tunnel）</p>
<ul>
<li>可以用来访问采用了 SSL (HTTPS) 协议的站点<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>头部字段(Head Fileds)</strong></p>
<ul>
<li>
<p><strong>请求头字段</strong>（Request Header Fields）</p>
<ul>
<li>有关要获取的资源或客户端本身信息的消息头</li>
</ul>
</li>
<li>
<p><strong>响应头字段</strong>（Response Header Fields）</p>
<ul>
<li>有关响应的补充信息，比如服务器本身（名称和版本等）的消息头</li>
</ul>
</li>
<li>
<p><strong>实体头字段</strong>（Entity Header Fields）</p>
<ul>
<li>有关实体主体的更多信息，比如主体长度（Content-Length）或其MIME类型</li>
</ul>
</li>
<li>
<p><strong>通用头字段</strong>（General Header Fields）</p>
<ul>
<li>同时适用于请求和响应消息，但与消息主体无关的消息头<br>
<br></li>
</ul>
</li>
<li>
<p><strong>请求头字段</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210416100243001.png" alt="图1"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210416100402547.png" alt="图2"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210419091714226.png" alt="图3"></p>
</li>
<li>
<p>Referer字段可以用于防盗链</p>
<ul>
<li>注意：(*;q=0.2用逗号隔开为一个整体) 值越大，表示优先级越高，如果不指定q值，默认是1.0（1.0是最大值）</li>
<li>多线程断点下载（Range）<br>
<br></li>
</ul>
</li>
<li>
<p><strong>响应头字段</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210416122123221.png" alt="图4"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210416123303273.png" alt="图5"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210416122158176.png" alt="图6"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      response.setContentType(<span class="string">&quot;text/plain; charset=UTF8&quot;</span>);</span><br><span class="line">      response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=\&quot;lzy.txt\&quot;&quot;</span>);</span><br><span class="line">      response.getWriter().write(<span class="string">&quot;这是我的文件数据&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>状态码（Status Code）</strong></p>
<ul>
<li>
<p>在 <a href="https://tools.ietf.org/html/rfc2616#section-10" rel="external nofollow noreferrer">RFC 2616 10.Status Code Definitions</a> <strong>规范中定义</strong></p>
</li>
<li>
<p>状态码指示HTTP请求是否已成功完成</p>
</li>
<li>
<p>状态码分类</p>
<ul>
<li>信息响应：100~199
<ul>
<li><strong>100 Continue</strong>
<ul>
<li>客户端在需要请求服务器的一些（敏感）资源时候会需要发送(url ,请求头)区判断服务器是否愿意接受请求（服务器通过url或请求头判断），如果未被拒绝就会继续发送剩余请求体，如果请求已经完成，就忽略这个响应。(一些情况下如果服务器不看请求体就拒绝请求，客户端还发送的请求体是不恰当的或是低效的）</li>
</ul>
</li>
</ul>
</li>
<li>成功响应：200~299
<ul>
<li><strong>200 OK</strong>：请求成功</li>
</ul>
</li>
<li>重定向：300~399s
<ul>
<li><strong>302 Found</strong>：请求的资源被暂时的移动到了由Location头部指定的URL上（重定向）</li>
<li><strong>304 Not Modified</strong>：说明无需再次传输请求的内容，也就是说<strong>可以使用缓存的内容</strong>（静态资源）(依旧会发送请求，只是接收时没有响应体)</li>
</ul>
</li>
<li>客户端错误：400~499
<ul>
<li><strong>400 Bad Request</strong>：由于语法无效，服务器无法理解该请求, 或是（不满足要求）服务器主动给的</li>
<li><strong>401 Unauthorized</strong>：由于缺乏目标资源要求的身份验证凭证</li>
<li><strong>403 Forbidden</strong>：服务器端有能力处理该请求，但是拒绝授权访问</li>
<li><strong>404 Not Found</strong>：服务器端无法找到所请求的资源</li>
<li><strong>405 Method Not Allowed</strong>：服务器禁止了使用当前HTTP方法的请求</li>
<li><strong>406 Not Acceptable</strong>：服务器端无法提供与Accept-Charset以及Accept-Language指定的值相匹配的响应</li>
<li><strong>408 Request Timeout</strong>：服务器想要将没有在使用的连接关闭
<ul>
<li>一些服务器会在空闲连接上发送此信息，即便是在客户端没有发送任何请求的情况下</li>
</ul>
</li>
</ul>
</li>
<li>服务器错误 ：500~599
<ul>
<li><strong>500 Internal Server Error：所请求的服务器遇到意外的情况并阻止其执行请求</strong></li>
<li><strong>501 Not Implemented</strong>：请求的方法不被服务器支持，因此无法被处理
<ul>
<li>服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD</li>
</ul>
</li>
<li><strong>502 Bad Gateway</strong>：作为网关或代理角色的服务器，从上游服务器（如tomcat）中接收到的响应是无效的</li>
<li><strong>503 Service Unavailable</strong>：服务器尚未处于可以接受请求的状态
<ul>
<li>通常造成这种情况的原因是由于服务器停机维护或者已超载</li>
</ul>
</li>
</ul>
</li>
<li>CTRL+ F5 强制刷新，不使用缓存（浏览器）<br>
<br></li>
</ul>
</li>
<li>
<p><strong>form 提交 - 常用属性、multipart/form-data</strong></p>
<ul>
<li>
<p><strong>action</strong>：请求的URI</p>
</li>
<li>
<p><strong>method</strong>：请求方法（GET、POST）</p>
</li>
<li>
<p><strong>enctype</strong>：POST请求时，请求体的编码方式：</p>
<ul>
<li>application/x-www-form-urlencoded（默认值）
<ul>
<li>会用&amp;分隔参数，用=分隔键和值，（不论get/post）通过表单提交的<strong>queryString</strong>字段编码是文件按方式（请求的Html）的编码方式为准，而请求的<strong>pathInfo</strong>部分则按照浏览器设定的编码方式编码为准。</li>
</ul>
</li>
<li>multipart/form-data
<ul>
<li>文件上传时必须使用这种编码方式</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>multipart/form-data</strong> 可参考 <a href="https://tools.ietf.org/html/rfc1521" rel="external nofollow noreferrer">RFC 1521</a></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="文件上传请求头"></p>
</li>
</ul>
</li>
<li>
<p><strong>同源策略、跨域资源共享</strong></p>
<ul>
<li>
<p>浏览器有个同源策略（<strong>Same-Origin Policy</strong>）</p>
<ul>
<li>
<p>artifacts ：编译后的Java类，Web资源等的整合，用以测试、部署等工作。再白话一点，就是说某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式。某个module有了 Artifacts 就可以部署到应用服务器中了。（打包）</p>
</li>
<li>
<p><strong>jar</strong>：Java ARchive，通常用于聚合大量的Java类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便分发Java平台应用软件或库；</p>
</li>
<li>
<p><strong>war</strong>：Web application ARchive，一种JAR文件，其中包含用来分发的JSP、Java Servlet、Java类、XML文件、标签库、静态网页（HTML和相关文件），以及构成Web应用程序的其他资源；</p>
</li>
<li>
<p><strong>exploded</strong>：在这里你可以理解为展开，不压缩的意思。也就是war、jar等产出物没压缩前的目录结构。建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。</p>
</li>
<li>
<p>默认情况下，IDEA的 Modules 和 Artifacts 的 output目录已经设置好了，不需要更改，打成war包的时候会自动在 WEB-INF目录下生成classes，然后把编译后的文件放进去。</p>
</li>
</ul>
</li>
<li>
<p>默认情况下，AJAX请求只能发给同源的URL</p>
<ul>
<li>同源：指的是<strong>协议、域名（IP）、端口</strong>相同<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%90%8C%E6%BA%90URL.png" alt="同源URL"></li>
</ul>
</li>
<li>
<p><strong>CORS (Cross-Origin Resource Sharing)，跨域资源共享</strong>(解决Ajax请求)</p>
<ul>
<li>CORS实现需要客户端和服务器同时支持</li>
<li>客户端所有的浏览器都支持（IE至少为IE10）服务器需要返回响应的响应头（Access-Control-Allow-Origin）</li>
</ul>
</li>
<li>
<p><strong>注意</strong>：<code>img、script、link</code>等标签是不受同源策略影响。<br>
<br></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>代理服务器（Proxy Server）</strong></p>
<ul>
<li><strong>特点</strong>:
<ul>
<li><strong>本身不生产内容</strong></li>
<li>处于中间位置转发上下游的请求和响应
<ul>
<li>面向下游的客户端：它是服务器</li>
<li>面向上游的服务器：它是客户端<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>正向代理</strong>和<strong>反向代理</strong></p>
<ul>
<li>
<p><strong>正向代理</strong>： 代理对象是<strong>客户端</strong></p>
<ul>
<li>正向代理的作用：
<ul>
<li>隐藏客户端身份（IP隐藏）</li>
<li>绕过防火墙（突破访问限制）</li>
<li>Internet访问控制</li>
<li>数据过滤</li>
<li>…</li>
<li>一些免费的正向代理
<ul>
<li><a href="https://ip.jiangxianli.com/" rel="external nofollow noreferrer">https://ip.jiangxianli.com/</a></li>
<li><a href="https://www.kuaidaili.com/free/inha/" rel="external nofollow noreferrer">https://www.kuaidaili.com/free/inha/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="正向代理"></p>
</li>
<li>
<p><strong>反向代理</strong>： 代理对象是<strong>服务端</strong></p>
<ul>
<li>隐藏服务器身份</li>
<li>安全防护</li>
<li>负载均衡</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="反向代理"></p>
</li>
<li>
<p>补充</p>
<ul>
<li><strong>Fiddler、Charles 等抓包工具的原理</strong>：在客户端启动了<strong>正向代理</strong>服务</li>
<li><strong>Wireshark的原理</strong>：通过<strong>底层驱动</strong>，<strong>拦截网卡</strong>上流过的数据</li>
</ul>
</li>
<li>
<p><strong>代理服务器 - 相关的头部字段</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E5%A4%B4%E5%AD%97%E6%AE%B5.png" alt="代理服务器相关头字段"><br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>CDN （Content Delivery Network或Content Distribution Network）内容分发网络</strong></p>
<ul>
<li>利用最靠近每位用户的服务器来服务</li>
<li>更快更可靠地将音乐、图片、视频等资源文件（一般是<strong>静态资源</strong>）传递给用户</li>
<li>CDN运营商在全国、乃至全球的各个大枢纽城市都建立了机房
<ul>
<li>部署了大量拥有高存储高带宽的节点，构建了一个跨运营商、跨地域的专用网络</li>
<li>内容所有者向CDN运营商支付费用，CDN将其内容交付给最终用户</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210423162938803.png" alt="图7"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210425100745273.png" alt="图8"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210423163037681.png" alt="图9"></p>
</li>
<li>
<p><strong>注意</strong>：</p>
<ul>
<li>向源站发起请求之前，会向逐渐上层CDN父节点请求，如果没有对应资源那么才会逐层向上请求。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>DHCP</tag>
        <tag>HTTP</tag>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - 传输层</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍传输层的两个协议<strong>TCP</strong>和<strong>UDP</strong>，也介绍了TCP的<strong>可靠传输</strong>（超时重传）、<strong>流量控制</strong>（点到点）、<strong>拥塞控制</strong> (共同维护)、<strong>连接管理</strong>（建立连接、释放连接）四个方面技术。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="传输层的两个主要协议"><a class="header-anchor" href="#传输层的两个主要协议">#</a>传输层的两个主要协议</h4>
<ul>
<li>
<p>TCP（Transmission Control Protocol）传输控制协议（<strong>不丢包</strong>）<br>
<br></p>
</li>
<li>
<p>UDP（User Datagram Protocol）用户数据报协议（<strong>丢包，实时</strong>（时间同步））</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210326084636152.png" alt="TCP和UDP协议对比"></p>
</li>
</ul>
<hr>
<h4 id="UDP协议"><a class="header-anchor" href="#UDP协议">#</a>UDP协议</h4>
<ul>
<li>
<p><strong>数据格式</strong></p>
<ul>
<li>
<p><strong>UDP</strong>是<strong>无连接</strong>的，减少了建立和释放连接的开销</p>
</li>
<li>
<p><strong>UDP</strong>尽最大的能力交付，不保证可靠交付，因此不需要维护一些复杂的数据，首部只有<strong>8个字节</strong>（TCP首部至少需要<strong>20 字节</strong>）</p>
</li>
<li>
<p><strong>UDP格式</strong>（首部 + 数据）<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210326085530166.png" alt="UDP格式"></p>
</li>
<li>
<p>注：</p>
<ul>
<li>其中UDP的长度为16位，为： 首部的长度 + 数据的长度</li>
<li><strong>UDP的数据长度</strong>字段是<strong>冗余</strong>的，因为完全可以通过IP数据包的首部长度和总长度计算出来传输层的数据长度。</li>
<li><strong>传输层的数据长度 = 网络层的总长度 - 网络层的首部长度 - 传输层的首部长度</strong><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>检验和（Checksum）</strong></p>
<ul>
<li>检验和的计算内容：<strong>伪首部</strong>  + <strong>首部</strong> + <strong>数据</strong></li>
<li><strong>伪首部</strong>：占12字节</li>
<li><strong>伪首部</strong>： 仅在计算首部检验和的时候起作用， 并不会将伪首部传递分网络层。（增强检验功能）<br>
<br></li>
</ul>
</li>
<li>
<p><strong>相关补充 - 常用命令、端口（Port）</strong></p>
<ul>
<li>
<p>UDP首部中<strong>端口</strong>是占用<strong>2字节</strong>，端口的<strong>取值范围</strong>： 0-65535</p>
</li>
<li>
<p>在请求的过程中客户发送数据的端口是<strong>随机开启的端口</strong>。</p>
</li>
<li>
<p>可以通过防火墙设置开启或关闭某些端口来<strong>提高安全性</strong>。（例如：服务器关闭Mysql数据库3306端口， 不允许外部访问。）</p>
</li>
<li>
<p>常用端口：<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210326090544507.png" alt="不同协议默认端口号"></p>
<ul>
<li>
<p><code>netstat –an</code>：查看被占用的端口</p>
</li>
<li>
<p><code>netstat –anb</code>：查看被占用的端口、占用端口的应用程序</p>
</li>
<li>
<p><code>telnet 主机 端口</code>：查看是否可以访问主机的某个端口</p>
</li>
<li>
<p>安装telnet：控制面板 – 程序 – 启用或关闭Windows功能 – 勾选“Telnet Client” – 确定</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="TCP协议"><a class="header-anchor" href="#TCP协议">#</a>TCP协议</h4>
<ul>
<li>
<p><strong>TCP协议 - 数据格式、检验和、标志位(Flags)</strong></p>
<ul>
<li>
<p>数据偏移（数据的偏移值或者是首部长度）</p>
<ul>
<li>占四位，取值范围是0x0101- 0x1111(5 - 15)</li>
<li>乘以4：首部长度（Header Length）</li>
<li>首部长度范围： 20到60字节</li>
</ul>
</li>
<li>
<p>检验和(Checksum)</p>
<ul>
<li>同UDP一样,仅在计算首部检验和的时候起作用， 并不会将伪首部传递分网络层<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210329160845774.png" alt="UDP报文数据格式"></li>
</ul>
</li>
<li>
<p>标志位(Flags)</p>
<ul>
<li>URG(Urgent)
<ul>
<li>当URG为1的时候,紧急指针数值有效.表明当前报文段中有紧急数据,应优先传送</li>
</ul>
</li>
<li>ACK(Acknowledgment)
<ul>
<li>当ACK为1 ,确认号字段才有效.</li>
</ul>
</li>
<li>RST(Reset)
<ul>
<li>当RST=1时, 表明连接中出现严重差错,应释放连接,然后再重新建立连接.</li>
</ul>
</li>
<li>SYN(Synchronization)（同步）
<ul>
<li>当SYN为1,ACK为0表明是建立连接请求</li>
<li>同意建立连接的回复,回复为SYN为1,ACK为1</li>
<li>对连接的回应时，回复为SYN为0，ACK为1</li>
</ul>
</li>
<li>FIN (Finish)
<ul>
<li>表明数据释放完毕,要求释放连接</li>
</ul>
</li>
<li>PSH(Push)</li>
</ul>
</li>
<li>
<p>保留</p>
<ul>
<li>占6位，目前全为0</li>
</ul>
</li>
<li>
<p>补充小细节</p>
<ul>
<li>有些资料保留位(Reserved)是3位，标志位是6位，由于<strong>前3位标志位是不用的</strong>，所以两种说法都没问题，并且wireshark就是这样的<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210327095100114.png" alt="TCP报文数据格式"><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>TCP的几个要点</strong></p>
<ol>
<li>可靠传输 （超时重传）</li>
<li>流量控制（点到点）</li>
<li>拥塞控制 (共同维护)</li>
<li>连接管理（建立连接、释放连接）<br>
<br></li>
</ol>
</li>
<li>
<p><strong>TCP - 序号、确认号、窗口</strong></p>
<ul>
<li><strong>序号（Sequence Number）</strong>
<ul>
<li>占四个字节</li>
<li>在传输过程中的每一个字节（段）都有一个编号</li>
<li>建立连接之后，这个编号代表这一次TCP数据部分的第一个字节的编号</li>
</ul>
</li>
<li><strong>确认号</strong>
<ul>
<li>占四个字节</li>
<li>在建立连接之后，确认号代表，期望对方下一次传来的TCP数据部分的第一个字节编号</li>
</ul>
</li>
<li><strong>窗口(Window)</strong>
<ul>
<li>占两个字节（具体需要乘以窗口缩放系数）</li>
<li>这个字段具有流量控制功能, 用以告诉下一次发送语序的而数据大小(单位为字节)<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>TCP可靠传输 - 停止等待ARQ协议</strong></p>
<ul>
<li>
<p><strong>ARQ</strong>(Auto Repeat-reQuest), 自动重传请求(超时重传)<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210329090628315.png" alt="可靠传输-ARQ协议"></p>
</li>
<li>
<p>连续ARP协议 + 滑动窗口协议(提高效率)</p>
<ul>
<li>发送方的窗口大小是由接受方的窗口的缓存大小决定的<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210329092914707.png" alt="连续ARQ协议-滑动窗口协议"></li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20210112201816204.png" alt="连续ARQ协议-滑动窗口协议-详细流程"><br>
<br></p>
</li>
<li>
<p><strong>TCP可靠传输 - SACK</strong>（选择性确认技术 )</p>
<ul>
<li>
<p><strong>背景</strong></p>
<ul>
<li>在传输过程中,若发送的序列中间某个数据包丢失(1,2,3,4,5其中3丢失了)TCP会通过重传<strong>最后确认的分组后续的分组</strong>（若最后确认的是2，会重传3、4、5）</li>
<li>这样原先已经正确传输的分组也可能重复发送（比如4、5），降低了传输性能</li>
</ul>
</li>
<li>
<p><strong>选择性确认技术</strong></p>
<ul>
<li>告诉发送方哪些数据丢失，哪些数据已经提前收到</li>
<li>使TCP只重新发送丢失的包（比如3），不用发送后续所有的分组（比如4、5)<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20210112221856596.png" alt="丢包过程"></li>
</ul>
</li>
<li>
<p>SACK信息会放在TCP首部的<strong>选项</strong>部分（当Kind=5,代表这是SACK选项）</p>
<ul>
<li>Kind：占1字节。值为5代表这是SACK选项</li>
<li>Length：占1字节。表明SACK选项一共占用多少字节</li>
<li>Left Edge：占4字节，左边界</li>
<li>Right Edge：占4字节，右边界</li>
<li>(左边界301 - 右边界401的范围就代表301 - 400)<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210329173549813.png" alt="抓包中的SACK信息"></li>
</ul>
</li>
<li>
<p>返回确认的过程中,会告诉窗口缓存大小</p>
<ul>
<li>一对边界信息需要占用8字节，由于TCP首部的选项部分最多40字节，所以
<ul>
<li>SACK选项最多携带4组边界信息</li>
<li>SACK选项的最大占用字节数 = 4 * 8 + 2 = 34<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>相关补充</strong></p>
<ul>
<li><strong>一个包多次重传失败</strong>
<ul>
<li>不会一直重传知道成功为止，这个取决于操作系统的设置（有些系统，重传5次未成功（未收到确认报文）就会发送<strong>reset报文</strong>（RST）断开TCP连接，然后重新建立连接。</li>
</ul>
</li>
<li><strong>不足接收窗口大小</strong>
<ul>
<li>接收方会<strong>等待一定时间</strong>后没有后续包，就会返回确人接收到的包</li>
</ul>
</li>
<li><strong>在传输层分片（而不是在网络层）</strong>
<ul>
<li>提高传输的性能（可以（在传输层）发送指定分片丢失的包）</li>
<li>可靠传输是在<strong>传输层</strong>中进行控制的，如果不分段，一旦出现数据丢失，整个传输层数据都得重传（SACK）</li>
<li>需要明确的是可靠传输是在传输层进行控制。<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>TCP - 流量控制</strong>（端到端）</p>
<ul>
<li>
<p>背景</p>
<ul>
<li>接受方的缓存区大小是有限的（灵活调整的），发送方还发送数据，那么接受方就丢掉数据，这样会造成网络堵塞，所以需要流量控制（控制发送速率）。</li>
</ul>
</li>
<li>
<p>原理</p>
<ul>
<li>通过确认报文中的窗口字段来控制发送方的发送速率</li>
<li>发送方发送的额窗口大小不能大于接受方给出的窗口大小（接受窗口大小为0，发送方就会停止发送数据）</li>
</ul>
</li>
<li>
<p><strong>特殊情况</strong></p>
<ul>
<li>一开始，接受方给发送方发送的窗口为0的报文段，但是后面又有了一些空间，但是给发送方发送的非0窗口的确认报文段丢失了，于是双方陷入僵局。</li>
<li><strong>解决方案</strong>
<ul>
<li>发送方接受到0窗口大小的报文就会停止发送报文，并且会开启一个计时器，隔一段时间发送一个测试报文询问接受方 最新窗口大小，窗口大小为0就会继续开启计时器。<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>TCP - 拥塞控制</strong></p>
<ul>
<li>
<p><strong>简介</strong></p>
<ul>
<li>背景：
<ul>
<li>拥塞控制是为了<strong>防止过多的数据注入网络</strong>，从而<strong>避免网络中的路由器或链路过载</strong>，产生的，拥塞控制是<strong>全局性</strong>的，涉及降低网络传输性能有关的所有因素。<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E4%B8%A2%E5%8C%85%E8%BF%87%E7%A8%8B.png" alt="网络拥塞丢包过程"></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>TCP - 拥塞控制的方法</strong></p>
<ul>
<li>
<p><strong>慢开始（slow start，慢启动）</strong></p>
</li>
<li>
<p><strong>拥塞避免（congestion avoidance）</strong></p>
</li>
<li>
<p><strong>快速重传（fast retransmit）</strong></p>
</li>
<li>
<p><strong>快速恢复（fast recovery）</strong><br>
<br></p>
</li>
<li>
<p><strong>MSS（Maximum Segment Size）</strong>：每个段最大的数据部分大小（在建立连接时确定）（<strong>理论值</strong>）MTU一般是(1500) - 20 - 20 = 1460</p>
</li>
<li>
<p><strong>cwnd（congestion window</strong>）：拥塞窗口</p>
</li>
<li>
<p><strong>rwnd（receive window）</strong>：接收窗口（可发送所有数据的大小）</p>
</li>
<li>
<p><strong>swnd（send window）</strong>：发送窗口</p>
</li>
<li>
<p><strong>swnd = min(cwnd, rwnd)</strong><br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>TCP -【拥塞控制】- 慢开始（slow start）</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%85%A2%E5%BC%80%E5%A7%8B.png" alt="慢开始"><br>
<br></p>
</li>
<li>
<p><strong>TCP -【拥塞控制】- 拥塞避免（congestion avoidance）</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" alt="拥塞避免"></p>
<ul>
<li>ssthresh (slow start threshold)：慢开始阈值，cwnd达到阈值后，开始拥塞避免（加法增大）</li>
<li>拥塞避免（加法增大）：拥塞窗口cwnd 缓慢增大，以防止网络过早出现拥塞</li>
<li>乘法减小：只要出现网络拥塞，把ssthresh减为拥塞峰值的一半，同时执行慢开始算法（cwnd又恢复到初始值）</li>
<li>当网络出现频繁拥塞时，ssthresh值就下降的很快<br>
<br></li>
</ul>
</li>
<li>
<p><strong>TCP -【拥塞控制】- 快重传、快恢复</strong></p>
<ul>
<li>
<p><strong>快重传：</strong></p>
<ul>
<li><strong>接收方：</strong>
<ul>
<li>每接收到一个失序的分组就立即发送重复确认</li>
<li>使发送方能快速确认有分组没有到达</li>
<li>不需要等待自己再发送数据，再确认哪些数据丢失了（SACK）</li>
</ul>
</li>
<li><strong>发送方：</strong>
<ul>
<li>只要发送方连续接受到3个连续的确认（总共4个），就应当立即重传对方尚未接收到的报文段</li>
<li>不必继续等待重传计时器到期后再重传<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%BF%AB%E9%87%8D%E4%BC%A0.png" alt="快重传"><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>快恢复：</strong></p>
<ul>
<li>当发送方连续收到三个重复确认，说明网络出现拥塞</li>
<li>就执行 “乘法减小” 算法，把ssthresh（slow start threshold）减为拥塞峰值的一半</li>
<li>与慢开始不同之处是现在不执行慢开始算法，即cwnd现在不恢复到初始值</li>
<li>而是把cwnd值设置为新的ssthresh值（减小后的值）</li>
<li>然后开始执行拥塞避免算法（“<strong>加法增大</strong>”），使拥塞窗口缓慢地线性增大<br>
<br></li>
</ul>
</li>
<li>
<p><strong>快重传 + 快恢复</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%BF%AB%E9%87%8D%E4%BC%A0+%E5%BF%AB%E6%81%A2%E5%A4%8D.png" alt="快重传+快恢复"></p>
<ul>
<li><strong>发送窗口的最大值swnd = min(接收窗口cwnd, 堵塞窗口rwnd)</strong>
<ul>
<li>当 rwnd &lt; cwnd 时，是接收方的<strong>接收能力限制</strong>发送窗口的最大值</li>
<li>当 cwnd &lt; rwnd 时，则是<strong>网络的拥塞限制</strong>发送窗口的最大值<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>TCP的连接管理</strong></p>
<ul>
<li>
<p><strong>TCP - 序号和确认号（详细步骤）</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210407101921886.png" alt="图1"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210407093814029.png" alt="图2"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20210114194728620.png" alt="图3"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20210114195014571.png" alt="图4"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20210114230526157.png" alt="图5"></p>
</li>
<li>
<p><strong>TCP - 【建立连接】- 3次握手</strong></p>
<ul>
<li><strong>状态解读：</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/TCP-3%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP-3次握手"></li>
<li><strong>状态</strong>
<ul>
<li><strong>CLOSED</strong>：client处于关闭状态</li>
<li><strong>LISTEN</strong>：server处于监听状态，等待client连接</li>
<li><strong>SYN-RCVD</strong>：表示server接受到了SYN报文，当收到client的ACK报文后，它会进入到 <strong>ESTABLISHED</strong> 状态</li>
<li><strong>SYN-SENT</strong>：表示client已发送SYN报文，等待server的第2次握手<strong>ESTABLISHED</strong>：表示连接已经建立</li>
</ul>
</li>
<li><strong>前2次握手的相同点</strong>
<ul>
<li>YN 都设置为1</li>
<li>数据部分的长度都为0</li>
<li>TCP头部的长度一般是32字节
<ul>
<li>固定头部：20字节</li>
<li><strong>选项部分</strong>：12字节</li>
</ul>
</li>
<li>双方会交换确认一些信息
<ul>
<li>比如<strong>MSS</strong>、<strong>是否支持SACK</strong>、<strong>Window scale（窗口缩放系数）</strong> 等</li>
<li>这些数据都放在了TCP头部的<strong>选项部分</strong>中（12字节)</li>
</ul>
</li>
</ul>
</li>
<li><strong>采用三次握手原因</strong>
<ul>
<li><strong>主要目的</strong>：<strong>防止server端一直等待，浪费资源</strong></li>
<li>当client发出的第一个连接请求报文段因为网络延迟（并且重发），</li>
<li>后续请求在服务器连接释放以后的某个时间才到达server，导致server端认为想建立新连接，并且服务器返回确认给客户端</li>
<li>client对server确认不理睬</li>
<li>进而会导致server一直等待，浪费资源。</li>
</ul>
</li>
<li><strong>第三次握手失败处理</strong>
<ul>
<li>此时server的状态为 <code>SYN-RCVD</code>，若等不到client的 ACK，server会重新发送 SYN+ACK 包</li>
<li>如果server多次重发 SYN+ACK 都等不到client的 ACK（也就是超时），就会发送 <strong>RST包</strong>，<strong>强制关闭连接</strong>（被杀死）</li>
<li>如果收到其他报文段或报文，就会发出差错报文。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>TCP - 【释放连接】- 4次挥手</strong></p>
<ul>
<li><strong>状态解读</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/TCP-4%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP-4次挥手"></li>
<li><strong>FIN-WAIT-1</strong>：表示想主动关闭连接
<ul>
<li>向对方发送了FIN报文，此时进入到FIN-WAIT-1状态</li>
</ul>
</li>
<li><strong>CLOSE-WAIT</strong>：表示在等待关闭
<ul>
<li>当对方发送FIN给自己，自己会回应一个ACK报文给对方，此时则进入到CLOSE-WAIT状态</li>
<li>在此状态下，需要考虑自己是否还有数据要发送给对方，如果没有，发送FIN报文给对方</li>
</ul>
</li>
<li><strong>FIN-WAIT-2</strong>：只要对方发送ACK确认后，主动方就会处于FIN-WAIT-2状态，然后等待对方发送FIN报文</li>
<li><strong>CLOSING</strong>：一种比较罕见的例外状态
<ul>
<li>表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN 报文</li>
<li>如果双方几乎在同时准备关闭连接的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态(不会进入FIN-WAIT-2状态，最终进入TIME-WAIT状态）</li>
<li>表示双方都正在关闭连接</li>
</ul>
</li>
<li><strong>LAST-ACK</strong>：被动关闭一方在发送FIN报文后，最后等待对方的ACK报文
<ul>
<li>当收到ACK报文后，即可进入CLOSED状态了</li>
</ul>
</li>
<li><strong>TIME-WAIT</strong>：表示收到了对方的FIN报文，并发送出了ACK报文，就等 2<strong>MSL</strong> 后即可进入CLOSED状态了
<ul>
<li>如果FIN-WAIT-1状态下，收到了对方同时带FIN标志和ACK标志的报文时</li>
<li>可以直接进入到TIME-WAIT状态，而无须经过FIN-WAIT-2状态</li>
</ul>
</li>
<li><strong>CLOSED</strong>：关闭状态
<ul>
<li>由于有些状态的时间比较短暂，所以很难用 <code>netstat</code> 命令看到，比如SYN-RCVD、FIN-WAIT-1等</li>
</ul>
</li>
<li><strong>归纳</strong>
<ul>
<li>前两次是关闭了客户端到服务器的发送通道，后两次是关闭了服务器到客户端的发送通道。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>相关补充</strong></p>
<ul>
<li><strong>TCP / IP 协议栈</strong>在设计上，允许<strong>任何一方</strong>先发起断开连接。</li>
<li>一般是等待2倍的 <strong>MSL</strong>（Maximum Segment Lifetime，<strong>最大分段生存期</strong>）（MSL是TCP报文段在Internet上的最长生存时间）
<ul>
<li>每个具体的TCP实现都必须选择一个确定的MSL值，<a href="https://www.rfc-editor.org/rfc/rfc1122.html" rel="external nofollow noreferrer">RFC 1122</a>建议是2分钟，<strong>可以防止本次连接中产生的数据包误传到下一次连接中</strong>（因为本次连接中的数据包都会在2<strong>MSL</strong>时间内消失了）</li>
</ul>
</li>
<li>为什么会在Client发送确认Server的ACK后，需要有个<strong>TIME-WAIT</strong>阶段，等待一段时间后，然后再真正关闭连接？
<ul>
<li>如果客户端在发送完ACK后直接进入<strong>CLOSED</strong> 状态，中间可能因为网络原因，server丢失了client的ACK，就会重发FIN来释放连接也就会引发以下的<strong>两种状况</strong>：
<ul>
<li>客户端关闭了，没有任何反应，服务器就会等很久，甚至多次发送FIN报文，浪费资源。</li>
<li>客户端刚好打开一个应用程序分配和刚刚那个同一个端口，新的应用程序就会收到FIN，执行关闭连接的操作（本来是需要建立来连接的）</li>
</ul>
</li>
</ul>
</li>
<li><strong>四次挥手的原因</strong>
<ol>
<li>TCP是<strong>全双工模式</strong>的，双方同时可以发送和接收数据。</li>
<li>第一次挥手，表示主机1告诉主机2没有数据需要发送，此时主机1仍可以接收主机2的数据。</li>
<li>第二次挥手，表示主机2知道主机1没有数据需要发送，此时主机2仍可以发送数据到主机1。</li>
<li>第三次挥手，表示主机2告诉主机1没有数据需要发送</li>
<li>第四次挥手，表示主机1已经知道主机2没有数据发送了。随后正式断开整个TCP连接</li>
<li>有时通过抓包可以发现，又是后只有三次挥手，其实是将第二和第0三次挥手合并了，在接收到FIN的同时，通知没有数据需要发送了。</li>
</ol>
</li>
<li><strong>长连接和短连接</strong>（建立连接的目的）
<ul>
<li><strong>长连接</strong>：客户端建立完连接，只需要拿完数据不断开（频繁数据交互）就是长连接。</li>
<li><strong>短连接</strong>：客户端建立完连接，只需要拿完数据后立刻断开连接</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - 物理层和数据链路层</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E7%89%A9%E7%90%86%E5%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍网络互联模型中数据在物理层和数据链路层传输方式以及相关协议。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="网络互联模型"><a class="header-anchor" href="#网络互联模型">#</a>网络互联模型</h4>
<ul>
<li>
<p><strong>网络分层</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210316091413100.png" alt="网络分层"><br>
<br></p>
</li>
<li>
<p><strong>物理层</strong></p>
<ul>
<li><strong>物理层</strong>定义了<strong>接口标准、线缆标准、传输速率、传输方式</strong>等。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>数字信号、模拟信号</strong></p>
<ul>
<li>模拟信号（Analog Signal）
<ul>
<li>连续的信号、适合长距离传输</li>
<li>抗干扰能力差，受到干扰时波形变形很难纠正</li>
</ul>
</li>
<li>数字信号（Digital Signal）
<ul>
<li>离散的信号、不适合长距离传输</li>
<li>抗干扰能力强，受到干扰时波形失真可以修复<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数据通信模型</strong></p>
<ul>
<li>
<p>局域网通信模型</p>
<ul>
<li>PC - 数字信号 | 网线 - 集线器 | 交换机 - 数字信号 | 网线 - PC</li>
<li><strong>注意</strong>：网线传输的是数字信号，只适用于短距离传输，一般不超过100米。</li>
</ul>
</li>
<li>
<p>广域网通信模型</p>
<ul>
<li>
<p>PC - 数字信号 | 网线 - 调制解调器 - 模拟信号 | 电话线 - 调制解调器 - 数字信号 | 网线 - PC</p>
</li>
<li>
<p>PC - 数字信号 | 网线 - 光电转换器 - 光信号 | 光纤 - 光电转换器 - 数字信号 | 网线 - 2、信道（单工、半双工、全双工）PC</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="信道（单工、半双工、全双工）"><a class="header-anchor" href="#信道（单工、半双工、全双工）">#</a>信道（单工、半双工、全双工）</h4>
<ul>
<li>信道
<ul>
<li>信息传输的通道，一条传输介质上（比如网线）上可以有<strong>多条信道</strong></li>
<li>单向通信
<ul>
<li>信道只能往一个方向传输，任何时候都不能改变信道的传输方向（无线电广播、有线电视广播）</li>
</ul>
</li>
<li>半双工通信
<ul>
<li>信号可以<strong>双向传输</strong>，但必须是<strong>交替进行</strong>，同一时间只能往一个方向传输（对讲机）</li>
</ul>
</li>
<li>全双工通信
<ul>
<li>信号可以同时<strong>双向传输</strong>（打电话）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="数据链路层-Data-Link"><a class="header-anchor" href="#数据链路层-Data-Link">#</a>数据链路层(Data Link)</h4>
<ul>
<li>链路：从1个节点到相邻节点的一段<strong>物理线路（有线或无线）</strong>，中间没有其他交换节点</li>
<li>数据链路：在一条链路上传输数据时，需要有对应的<strong>通信协议</strong>来控制数据的传输；不同类型的数据链路，所用的通信协议可能是不同的</li>
<li>举例：
<ul>
<li>广播信道:<strong>CSMA/CD协议</strong>（比如同轴线缆、集线器等组成的网络）</li>
<li>点对点信道:<strong>PPP协议</strong>（比如两个路由器之间的信道）</li>
</ul>
</li>
<li>数据链路的三个基本问题：
<ul>
<li>封装成帧
<ul>
<li>帧（Frame）的数据部分： 网络层传递下来的<strong>数据包 （IP数据包，Packet</strong>）</li>
<li>最大传输单元MTU（Maximum Transfer Unit）(IP数据包，Packet)：</li>
<li>每一种数据链路层协议都规定了所能够传送的帧的数据长度上限</li>
<li>以太网的<strong>MTU为1500个字节</strong></li>
</ul>
</li>
<li>透明传输
<ul>
<li>数据部分中出现SOH、EOT，就需要转义（加上ESC转义）</li>
<li>转义过程是透明。</li>
<li>使用 SOH（Start Of Header）作为 <strong>帧开始符</strong></li>
<li>使用 EOT（End Of Transmission）作为 <strong>帧结束符</strong></li>
</ul>
</li>
<li>差错检验
<ul>
<li>每一帧包括帧开始结束符、帧结束符、帧的数据部分、数据链路层首部和FCS.</li>
<li>FCS（Frame Check Sequence）是根据**帧的数据部分*- + <strong>数据链路层的首部</strong>计算得出的，源站到目标站的数据传输都会计算FCS用来检验数据是否出错。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="CSMA-CD协议"><a class="header-anchor" href="#CSMA-CD协议">#</a>CSMA/CD协议</h4>
<ul>
<li><strong>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）</strong>
<ul>
<li>传统以太网络使用<a href="https://baike.baidu.com/item/CSMA%2FCD/986847" rel="external nofollow noreferrer">CSMA/CD</a>（<a href="https://baike.baidu.com/item/%E8%BD%BD%E6%B3%A2%E7%9B%91%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE" rel="external nofollow noreferrer">载波监听多路访问</a>及<a href="https://baike.baidu.com/item/%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B" rel="external nofollow noreferrer">冲突检测</a>技术）技术</li>
</ul>
</li>
<li>以太网帧的格式:
<ul>
<li>
<p><strong>Ethernet V2标准</strong>、IEEE的802.3标准。</p>
<ul>
<li>
<p>其中使用最多的是：<strong>Ethernet V2标准</strong><br>
<br></p>
</li>
<li>
<p>为了检测以太网帧是否产生了冲突，以太网的帧至少要<strong>64字节</strong>。（正常传输需要<strong>两个信道长度</strong>来区分是否为冲突信号，保证在传输一个信道数据过程中，收到冲突信号时，自身还在发送数据，进而能判断时冲突信号）<br>
<br></p>
</li>
<li>
<p>用交换机和集线器传输的数据都叫<strong>以太网帧</strong>（其中交换机组建的网络已经支持<strong>全双工通信</strong>，不再使用CSMA/CD协议，交换机的每个端口就是一个冲突域）。<br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>Ethernet V2帧的格式</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210316075837777.png" alt="Ethernet V2帧的格式"></p>
<ul>
<li><strong>首部</strong>：目标MAC + 源MAC + 网络类型（IPv4, IPv6）</li>
<li><strong>以太网帧</strong>：首部 + 数据 + FCS</li>
<li>数据的长度至少：64-目标MAC(6)-源MAC(6)-类型(2)-FCS(4) = <strong>46字节</strong><br>
<br></li>
</ul>
</li>
<li>
<p><strong>Ethernet V2标准</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210319090027708.png" alt="Ethernet V2标准"></p>
<ul>
<li>当数据部分小于46字节，会在数据后面添加一些字节填充，接收端会将添加的字节去掉。</li>
<li>以太网帧数据部分是46到1500字节</li>
<li><strong>以太网帧的长度</strong>：64到1518字节为了能够检测正在发送的帧是否产生了冲突，以太网的帧至少要 64 字节<br>
1518字节 = 目标MAC(6) + 源MAC(6) + 网络类型(2) + 数据(1500) + FCS(4)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="PPP协议"><a class="header-anchor" href="#PPP协议">#</a>PPP协议</h4>
<ul>
<li>
<p>PPP（Point to Point Protocol）协议是在点到点链路上承载网络层数据包的一种链路层协议，由于它能够提供用户验证、易于扩充，并且支持同/异步通信，因而获得广泛应用。</p>
</li>
<li>
<p>帧开始符、帧结束符：0x7E</p>
</li>
<li>
<p>Address 字段：图中的值是 0xFF，形同虚设，<strong>点到点信道不需要源MAC、目标MAC地址</strong></p>
<ul>
<li>Control 字段：图中的值是 0x03，目前没有什么作用</li>
<li>Protocol 字段：内部用到的协议类型<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210319090951009.png" alt="PPP帧的格式"></li>
</ul>
</li>
<li>
<p><strong>PPP协议字节补充</strong></p>
<ul>
<li>将 0x7E 替换成 0x7D5E
<ul>
<li>将 0x7D 替换成 0x7D5D<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210319091442332.png" alt="PPP帧的格式补充"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="网卡"><a class="header-anchor" href="#网卡">#</a>网卡</h4>
<ul>
<li>网卡工作在（物理层和数据链路层）这两层。</li>
<li>Wireshark抓到的帧没有FCS,是因为抓到的是校验通过的帧（帧尾的FCS被硬件去掉）<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20221122133712.png" alt="网卡的工作"></li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>CSMA/CD</tag>
        <tag>PPP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - 网络层</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍网络层的数据段，重点介绍网络层首部相关信息。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="网络层简介"><a class="header-anchor" href="#网络层简介">#</a>网络层简介</h4>
<ul>
<li><strong>数据</strong>：<strong>很多时候</strong>是由传输层传递下来的<strong>数据段</strong>（Segments）（IP、ICMP和ARP协议就是网络层协议，不涉及运输层）</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210501103831755.png" alt="网络层帧格式"></p>
<hr>
<h4 id="网络层首部-版本、首部长度、区分服务、总长度"><a class="header-anchor" href="#网络层首部-版本、首部长度、区分服务、总长度">#</a>网络层首部 - 版本、首部长度、区分服务、总长度</h4>
<ul>
<li>
<p>版本（Version）</p>
<ul>
<li>占4位</li>
<li>0b0100：IPv4</li>
<li>0b0100：IPv6</li>
</ul>
</li>
<li>
<p>首部长度</p>
<ul>
<li>占4位，二进制转十进制值乘4才是最终长度</li>
<li>0b0101 -&gt; 20(min)</li>
<li>0b1111 -&gt; 60(max)</li>
<li>可变部分最多是40字节</li>
</ul>
</li>
<li>
<p>区分服务（Differentiated Services Field）</p>
<ul>
<li>占8位</li>
<li>用于提高网络服务质量（<code>QoS</code>, Quality of Service）</li>
</ul>
</li>
<li>
<p>总长度</p>
<ul>
<li>占16位</li>
<li>首部 + 数据的长度之和，最大值是 65535（IP数据包MAX长度）字节</li>
<li>帧的长度不能超过1500字节，所以帧的数据部分中网络层数据部分最大长度是1500 - 20 = 1480字节，而且在传输给数据链路层的过程中就需要<strong>分片</strong>（fragments），其中米都有自己的网路层首部（IP首部）。</li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210321164853754.png" alt="网络层数据段"></p>
<hr>
<h4 id="网络层首部-标识、标志、片偏移"><a class="header-anchor" href="#网络层首部-标识、标志、片偏移">#</a>网络层首部 - 标识、标志、片偏移</h4>
<ul>
<li>标识（Identification）
<ul>
<li>占16位</li>
<li>数据包的ID,当数据包过大进行分片时， 同一数包的标识时一样的，用于代表</li>
<li>有一个计数器专门管理数据包的ID,每发出一个数据包，ID就加1， 超出范围（65535）就会重新开始。</li>
</ul>
</li>
<li>标志（Flags）
<ul>
<li>占3位</li>
<li>第一位（0… = Reserved bit: Not set）保留位</li>
<li>第二位（.1. = Don’t fragment: Set）1表示允许分片</li>
<li>第三位（…0 = More fragments: Not set）0代表是最后一片</li>
</ul>
</li>
<li>片偏移（Fragment offset）
<ul>
<li>占13位</li>
<li>片偏移乘以8就是字节偏移</li>
<li>每一片的长度时8的整数倍（片偏移 = 片的长度/8, 因为13位不一定存得下）</li>
</ul>
</li>
</ul>
<hr>
<h4 id="ping-的几个用法，wireshark抓包"><a class="header-anchor" href="#ping-的几个用法，wireshark抓包">#</a>ping 的几个用法，<code>wireshark</code>抓包</h4>
<ul>
<li>
<p><code>ping /?</code> 查看ping的用法</p>
</li>
<li>
<p><code>ping ip地址 -l 数据包大小</code> 发送指定大小的数据包</p>
</li>
<li>
<p><code>ping ip地址 -f</code> 不允许分片</p>
</li>
<li>
<p><code>ping ip地址 -i TTL数值</code></p>
</li>
<li>
<p><code>tracert pathping</code><br>
<br></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210321174656873.png" alt="图1"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210321174347524.png" alt="图2"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210321180403768.png" alt="图3"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210321182232746.png" alt="图4"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210321181914569.png" alt="图5"></p>
</li>
</ul>
<hr>
<h4 id="网络层首部-生存时间、协议、首部校验和"><a class="header-anchor" href="#网络层首部-生存时间、协议、首部校验和">#</a>网络层首部 - 生存时间、协议、首部校验和</h4>
<ul>
<li>
<p>生存时间（Time To Live， TTL）</p>
<ul>
<li>占8位</li>
<li>每个路由器转发前TTL减1，一旦发现TTL为0，路由器就会返回错误报告（防止路由表配置错误占用带宽）<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="带宽一词最初指的是电磁波频带的宽度，也就是信号的最高频率与最低频率的差值。目前，它被更广泛地借用在数字通信中，用来描述网络或线路理论上传输数据的最高速率">[1]</span></a></sup></li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210321184906875.png" alt="不同操作系统的的TTL"></p>
</li>
<li>
<p>协议（Protocol）</p>
<ul>
<li>占8位</li>
<li>表明网络层封装的数据使用的协议<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210321182902910.png" alt="不同协议的代号"></li>
</ul>
</li>
<li>
<p>首部校验和（Header Checksum）</p>
<ul>
<li>用于检测首部是否有错误</li>
</ul>
</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">带宽一词最初指的是电磁波频带的宽度，也就是信号的最高频率与最低频率的差值。目前，它被更广泛地借用在数字通信中，用来描述网络或线路理论上传输数据的最高速率<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
  </entry>
  <entry>
    <title>网络协议 - 网络基础知识</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍现实中的网络和IP分配的相关知识。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="网络基础知识"><a class="header-anchor" href="#网络基础知识">#</a>网络基础知识</h4>
<ul>
<li>
<p>网络</p>
<ul>
<li>互联网
<ul>
<li>多个网络连接起来</li>
</ul>
</li>
<li>因特网
<ul>
<li>全世界最大的互联网是：因特网（Internet）</li>
<li>将<strong>全世界</strong>所有的计算机都连接在一起</li>
<li>一般使用大写 I 开头的 Internet 特指因特网</li>
<li>上不了网，其实就是指：电脑没有连接到因特网。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>ISP（Internet Service Provider）</strong>，Internet 服务提供商，比如移动、电信。<br>
<br></p>
</li>
<li>
<p><strong>局域网（ Local Area Network, LAN ）</strong></p>
<ul>
<li>一般是范围在几百米到十几公里内的计算机所构成的计算机网络</li>
<li>局域网中使用最广泛的网络技术叫：<strong>以太网（ Ethernet）</strong></li>
<li>在电脑、手机上经常见到的一个英文 <strong>WLAN（Wireless LAN ）</strong>，意思<strong>是无线局域网</strong><br>
<br></li>
</ul>
</li>
<li>
<p><strong>城域网（Metropolitan Area Network，MAN）</strong></p>
<ul>
<li>一般范围是数十公里到数百公里，可以覆盖一个城市<br>
<br></li>
</ul>
</li>
<li>
<p><strong>广域网（Wide Area Network，WAN）</strong></p>
<ul>
<li>一般范围是几百公里到几千公里，可以覆盖一个国家。通常都需要租通用 ISP 的线路<br>
<br></li>
</ul>
</li>
<li>
<p><strong>常见接口（FastEthernet、GigabitEthernet、Serial）</strong></p>
<ul>
<li>FastEthernet —— 快速以太网接口（100M）</li>
<li>GigabitEthernet —— 千兆以太网接口（1000M）</li>
<li>Serial —— 串行接口<br>
<br></li>
</ul>
</li>
<li>
<p>上网方式（电话线入户、光纤入户、网线入户、无线路由器）</p>
<ul>
<li>
<p>ADSL电话拨号上网（Asymmetric Digital Subscriber Line ）</p>
<ul>
<li>非对称数字用户线路，提供上、下行不对称的传输带宽</li>
</ul>
</li>
<li>
<p><strong>猫（ Modem）</strong>，<strong>调制解调器</strong>，进行<strong>数字信号</strong>和<strong>模拟信号</strong>的转换</p>
</li>
<li>
<p>光猫（ Optical Modem），<strong>光调制解调器</strong>，进行<strong>数字信号</strong>和<strong>光信号</strong>的转换<br>
<br></p>
</li>
</ul>
</li>
<li>
<p>家用无线路由器的逻辑结构<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20210310193941904.png" alt="家用无线路由器的逻辑结构"></p>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>公网 IP、私网IP</strong></p>
<ul>
<li>
<p><strong>公网IP</strong></p>
<ul>
<li>Internet上的路由器只有到达公网的路由表，没有到达私网的路由表</li>
<li>公网IP是由<strong>因特网信息中心</strong>（Internet Network Information Center, Inter NIC ）统一分配和管理</li>
<li>ISP 需要向 Inter NIC 申请 公网IP</li>
</ul>
</li>
<li>
<p><strong>私网IP</strong></p>
<ul>
<li>私网IP（Private）主要用于<strong>局域网</strong>。下面是保留的私网网段</li>
<li>A类：10.0.0.0/8，1个A类网络</li>
<li>B类：172.16.0.0/16 ~ 172.31.0.0/16，16个B类网络</li>
<li>C类：192.168.0.0/24 ~ 192.168.255.0/24，256个C类网络<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>NAT（Network Address Translation）</strong></p>
<ul>
<li>
<p>私网IP访问Internet需要进行NAT转换为公网IP，这一步由<strong>路由器</strong>完成。</p>
</li>
<li>
<p>只有<strong>路由器</strong>或者<strong>防火墙</strong>才能完成NAT的功能。</p>
</li>
<li>
<p>NAT优点</p>
<ul>
<li>节约公网IP资源</li>
<li>隐藏内部真实IP</li>
</ul>
</li>
<li>
<p>NAT的分类</p>
<ul>
<li>静态转换
<ul>
<li>需要手动配置NAT映射表</li>
<li>一（源IP）对一（公网IP）转换</li>
</ul>
</li>
<li>动态转换
<ul>
<li>定义外部地址池</li>
<li>一对一转换</li>
</ul>
</li>
</ul>
</li>
<li>
<p>端口地址转换<strong>PAT</strong>(Port Address Translation)</p>
<ul>
<li>
<p>采用多对一转换，最大程度节省了<strong>公网IP资源</strong></p>
</li>
<li>
<p>采用<strong>端口多复用</strong>的方式，用<strong>端口号</strong>表示不同<strong>数据流</strong></p>
</li>
<li>
<p>PAT(（Port Address Translation）)是目前运用最广泛的实现方式</p>
</li>
<li>
<p>举例: （客户端端口是随机生成的）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">192.168.1.10:3375  -&gt; 200.100.1.10:3375  </span><br><span class="line">192.168.1.11:5579  -&gt; 200.100.1.10:5579  </span><br><span class="line">192.168.1.12:7474  -&gt; 200.100.1.10:7474  </span><br><span class="line">192.168.1.13:7474  -&gt; 200.100.1.10:8999</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>IP</tag>
        <tag>NAT</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - 路由器</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍网络通信中路由器的作用及其相关概念。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="路由器简介"><a class="header-anchor" href="#路由器简介">#</a>路由器简介</h4>
<ul>
<li>在不同网段之间<strong>转发数据</strong>，需要有路由器的支持。</li>
</ul>
<br>
<ul>
<li>默认情况下，路由器只知道跟它<strong>直连</strong>的网段，非直连的网段需要通过 <strong>静态路由、动态路由</strong> 告诉它。（路径选择）
<ul>
<li><strong>需要</strong>
<ul>
<li>广域网的接入</li>
<li>路由协议支持</li>
</ul>
</li>
<li><strong>静态路由</strong>
<ul>
<li>管理员手动添加路由信息</li>
<li>适用于小规模网络</li>
</ul>
</li>
<li><strong>动态路由</strong>
<ul>
<li>路由器通过<strong>路由选择协议</strong>（比如RIP、OSPF）<strong>自动获取</strong>路由信息</li>
<li>适用于大规模网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="路由表的分类"><a class="header-anchor" href="#路由表的分类">#</a>路由表的分类</h4>
<ul>
<li>网络路由
<ul>
<li><code>194.180.1.0/24 via 194.170.1.2</code></li>
<li><code>194.180.1.0/24 via 194.170.1.2</code></li>
</ul>
</li>
<li>特定主机路由
<ul>
<li><code>194.180.1.10/32 via 194.170.1.2</code></li>
<li><code>194.180.1.11/32 via 194.170.1.2</code></li>
</ul>
</li>
<li>默认路由
<ul>
<li><code>0.0.0.0/0 via 194.170.1.2</code></li>
</ul>
</li>
<li>汇总路由
<ul>
<li><code>194.180.0.0/16 via 194.170.1.2</code></li>
<li><code>194.0.0.0/8 via 194.170.1.2</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="数据包的传输过程"><a class="header-anchor" href="#数据包的传输过程">#</a>数据包的传输过程</h4>
<ul>
<li>数据包的传输过程中，主要分四类数据据、包括
<ul>
<li>源IP</li>
<li>目标IP</li>
<li>源MAC</li>
<li>目标MAC</li>
</ul>
</li>
<li>在传输过程中<strong>源IP</strong>、和<strong>目标IP</strong>一直没变，<strong>源MAC</strong>和<strong>目标MAC</strong>一直再改变。</li>
</ul>
<hr>
<h4 id="路由器的第一个数据包丢失分析"><a class="header-anchor" href="#路由器的第一个数据包丢失分析">#</a>路由器的第一个数据包丢失分析</h4>
<ul>
<li><strong>原因：<strong>在数据包在传输过程中，当一个端设备在知道路由器的MAC地址后，再向路由器发送发送ICMP数据包后，由于</strong>路由器不知道目标IP的MAC地址</strong>，进而丢失了源端设备的<strong>ICMP数据包</strong>，转而发送ARP数据包。所以ping过程中会丢失第一个ICMP数据包。</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - MAC地址、IP地址和子网掩码</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20MAC%E5%9C%B0%E5%9D%80%E3%80%81IP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍网络通信中的端与端互相通信的基础：IP地址和MAC地址以及子网掩码。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="MAC地址"><a class="header-anchor" href="#MAC地址">#</a>MAC地址</h4>
<ul>
<li>
<p>每个网卡都有一个<strong>6字节（48bit）<strong>的</strong>MAC地址</strong>（Media Access Control Address）</p>
</li>
<li>
<p>MAC地址全球唯一，固化在网卡的ROM中，由 IEEE802 标准规定</p>
<ul>
<li>前3字节：<strong>OUI (Organizationally Unique Identifier)，组织唯一标识符</strong>由 IEEE 的注册管理机构分配给厂商</li>
<li>后3字节：<strong>网络接口标识符</strong>由厂商自行分配</li>
<li>如： 40-55-82-0A-8C-6D</li>
</ul>
</li>
<li>
<p>OUI 查询：可以根据OUI查询出对应的厂商</p>
<ul>
<li><a href="http://standards-oui.ieee.org/oui.txt" rel="external nofollow noreferrer">http://standards-oui.ieee.org/oui.txt</a></li>
<li><a href="https://mac.bmcx.com/" rel="external nofollow noreferrer">https://mac.bmcx.com/</a></li>
</ul>
</li>
</ul>
<hr>
<h4 id="MAC地址不同操作系统表示格式（windows、Linux）"><a class="header-anchor" href="#MAC地址不同操作系统表示格式（windows、Linux）">#</a>MAC地址不同操作系统表示格式（windows、Linux）</h4>
<ul>
<li>
<p><strong>Windows</strong></p>
<ul>
<li>40-55-82-0A-8C-6D</li>
</ul>
</li>
<li>
<p><strong>Linux、Android、Mac、iOS（类Unix操作系统）</strong></p>
<ul>
<li>40:55:82:0A:8C:6D</li>
</ul>
</li>
<li>
<p><strong>Packet Tracer</strong></p>
<ul>
<li>4055.820A.8C6D</li>
</ul>
</li>
<li>
<p><strong>补充</strong></p>
<ul>
<li>48位全为1时，代表<strong>广播地址</strong>：FF-FF-FF-FF-FF-FF</li>
</ul>
</li>
</ul>
<hr>
<h4 id="MAC地址的相关操作"><a class="header-anchor" href="#MAC地址的相关操作">#</a>MAC地址的相关操作</h4>
<ul>
<li>
<p>查看MAC地址：<code>ipconfig /all</code></p>
</li>
<li>
<p>修改操作系统MAC地址</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FMAC%E5%9C%B0%E5%9D%80.png" alt="修改操作系统MAC地址"></p>
</li>
</ul>
<hr>
<h4 id="MAC地址的获取"><a class="header-anchor" href="#MAC地址的获取">#</a>MAC地址的获取</h4>
<ul>
<li>
<p>当不知道对方主机的MAC地址时，可以通过发送ARP广播获取对方的MAC地址</p>
<ul>
<li>获取成功后，会缓存IP地址、MAC地址的映射信息，俗称：<strong>ARP缓存</strong></li>
<li>通过ARP广播获取的MAC地址，属于 <strong>动态（dynamic）缓存</strong></li>
<li>存储时间比较短（<strong>默认是2分钟</strong>），过期就自动删除<br>
<br></li>
</ul>
</li>
<li>
<p><strong>ARP（Address Resolution Protocol）</strong>，地址解析协议</p>
<ul>
<li>用IP地址换MAC地址用IP地址换MAC地址</li>
<li><code>arp -a</code>[主机地址]：查看ARP缓存</li>
<li><code>arp -d</code> [主机地址]：删除ARP缓存</li>
<li><code>arp -s</code> 主机地址 MAC地址：增加一条缓存信息（这是静态缓存，存储时间较久，不同系统的存储时间不同）<br>
<br></li>
</ul>
</li>
<li>
<p><strong>RARP (Reverse Address Resolution Protocol)</strong>，逆地址解析协议</p>
<ul>
<li>使用与ARP相同的报头结构</li>
<li>作用与ARP相反，用于将MAC地址转换为IP地址</li>
<li>后来被 BOOTP、DHCP 所取代<br>
<br></li>
</ul>
</li>
<li>
<p><strong>ICMP（Internet Control Message Protocol）</strong>，互联网控制消息协议</p>
<ul>
<li>IPv4中的ICMP被称作 ICMPv4，IPv6中的ICMP则被称作 ICMPv6</li>
<li>通常用于返回错误信息</li>
<li>比如 TTL值过期、目的不可达</li>
<li>ICMP的错误消息总是包括了源数据并返回给发送者</li>
</ul>
</li>
</ul>
<hr>
<h4 id="IP地址"><a class="header-anchor" href="#IP地址">#</a>IP地址</h4>
<ul>
<li>
<p><strong>IP地址 (Internet Protocol Address)</strong></p>
<ul>
<li>
<p>互联网上的每一个主机都有一个IP地址</p>
</li>
<li>
<p>最初是 <strong>IPv4</strong> 版本，<strong>32bit（4字节）</strong>，2019年11月25日，全球的IP地址已经用完</p>
</li>
<li>
<p>后面推出了 <strong>IPv6</strong> 版本，<strong>128bit（16字节）</strong><br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>IP地址的组成</strong>（网络ID + 主机ID）</p>
<ul>
<li>IP地址 由2部分组成：<strong>网络标识（网络ID）、主机标识（主机ID）</strong></li>
<li>通过子网掩码（subnet mask）可以得知 网络ID 、主机ID</li>
<li>同一<strong>网段</strong>的计算机、<strong>网络ID</strong>相同。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>网段</strong></p>
<ul>
<li>
<p><strong>主机所在的网段</strong> = 子网掩码 按位与（&amp;）IP地址</p>
</li>
<li>
<p>例如：</p>
<ul>
<li>IP地址：192.168.1.10</li>
<li>子网掩码：255.255.255.0</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">  1100 0000 . 1010 1000 . 0000 0001 . 0000 1010 </span><br><span class="line">&amp; 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000</span><br><span class="line">1100 0000 . 1010 1000 . 0000 0001 . 0000 0000</span><br><span class="line">网段：192.168.1.0</span><br><span class="line">网络ID：192.168.1</span><br><span class="line">主机ID: 10</span><br><span class="line">---------------------</span><br><span class="line">该网段下IP地址数量：256-2=254 （主机ID全0为网段、全1为广播）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>IP地址的分类</strong></p>
<ul>
<li>
<p><strong>A类地址</strong>(默认子网掩码 255.0.0.0)</p>
<table>
<thead>
<tr>
<th style="text-align:center">8bit</th>
<th style="text-align:center">24bit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">网络ID（0开头）</td>
<td style="text-align:center">主机ID</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>B类地址</strong>(默认子网掩码 255.255.0.0)</p>
<table>
<thead>
<tr>
<th style="text-align:center">16bit</th>
<th style="text-align:center">16bit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">网络ID (10开头)</td>
<td style="text-align:center">主机ID</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>C类地址</strong>(默认子网掩码 255.255.255.0)</p>
<table>
<thead>
<tr>
<th style="text-align:center">24bit</th>
<th style="text-align:center">8bit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">网络ID (110开头)</td>
<td style="text-align:center">主机ID</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>D类地址</strong>没有子网掩码，用于多播（组播）地址</p>
<table>
<thead>
<tr>
<th style="text-align:center">8bit</th>
<th style="text-align:center">24bit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">网络ID (1110开头)</td>
<td style="text-align:center">主机ID</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>E类地址</strong>保留为今后使用</p>
<table>
<thead>
<tr>
<th style="text-align:center">8bit</th>
<th style="text-align:center">24bit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">网络ID (1111开头)</td>
<td style="text-align:center">主机ID</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li><strong>注意：</strong>
<ul>
<li>
<p>只有 A、B、C 类地址才能分配给主机.</p>
<ul>
<li>A类网络ID取值范围: 1~126</li>
<li>B类网络ID取值范围: 128~191</li>
<li>C类网络ID取值范围: 192~223</li>
<li>D类网络ID取值范围: 240~255</li>
</ul>
</li>
<li>
<p>A类地址 网络ID不能全为0,并且127为保留网段。（如：127.0.0.1是本地环回地址<strong>Loopback</strong>表示本机地址）所以A类地址网络ID范围（1到126）</p>
</li>
<li>
<p>A类地址 所能容纳的最大主机（IP）数量为: 256 - 256 - 256 - 2</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="子网掩码的CIDR表示方法"><a class="header-anchor" href="#子网掩码的CIDR表示方法">#</a>子网掩码的CIDR表示方法</h4>
<ul>
<li>
<p><strong>CIDR (Classless Inter-Domain Routing)，无类别域间路由</strong></p>
</li>
<li>
<p>192.168.1.100/24，代表子网掩码有24个1，也就是 255.255.255.0</p>
</li>
<li>
<p>计算工具：<a href="https://www.sojson.com/convert/subnetmask.html" rel="external nofollow noreferrer">https://www.sojson.com/convert/subnetmask.html</a></p>
</li>
</ul>
<hr>
<h4 id="子网划分（避免IP地址资源浪费）"><a class="header-anchor" href="#子网划分（避免IP地址资源浪费）">#</a>子网划分（避免IP地址资源浪费）</h4>
<ul>
<li>
<p><strong>子网划分</strong></p>
<ul>
<li><strong>等长子网划分</strong>：将一个网段等分成多个子网，<strong>每个子网的可用IP地址数量一样</strong></li>
<li><strong>变长子网划分</strong>：<strong>每个子网的可用IP地址数量可以是不一样的</strong></li>
<li>子网划分器：<a href="http://www.ab126.com/web/3552.html" rel="external nofollow noreferrer">http://www.ab126.com/web/3552.html</a></li>
</ul>
</li>
<li>
<p><strong>等长子网划分</strong>：<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E7%AD%89%E9%95%BF%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="等长子网划分"></p>
<ul>
<li><code>以此类推：每划分2的n次方个等长子网，就需要子网掩码后移n位（添加n个1）。</code></li>
</ul>
</li>
<li>
<p><strong>变长子网划分</strong><br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%8F%98%E9%95%BF%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="变长子网划分"></p>
<ul>
<li><code>以此类推：如果子网网址的长度是原网址的（1/2)^n，那么子网掩码就应在原子网掩码基础上后移n位（添加n个1）。</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="超网（合并网段）"><a class="header-anchor" href="#超网（合并网段）">#</a>超网（合并网段）</h4>
<ul>
<li>
<p>超网是将多个连续的网段<strong>合并</strong>成一个更大的网段。</p>
</li>
<li>
<p><strong>合并网段</strong>（子网掩码前移）</p>
<ul>
<li>
<p><strong>合并两个网段</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">192.168.0.0/24</span><br><span class="line">192.168.1.0/24</span><br><span class="line">--------------</span><br><span class="line">子网掩码：255.255.254.0</span><br><span class="line">新网段：192.168.0.0/23(其中192.168.0.255/23，不再为广播)</span><br><span class="line">新广播地址：192.168.1.255/23</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>合并四个网段</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">192.168.0.0/24</span><br><span class="line"></span><br><span class="line">192.168.1.0/24</span><br><span class="line"></span><br><span class="line">192.168.2.0/24</span><br><span class="line"></span><br><span class="line">192.168.3.0/24</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">子网掩码：255.255.252.0</span><br><span class="line">新网段：192.168.0.0/22</span><br><span class="line">新广播地址：192.168.3.255/22</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>相关练习</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/%E5%8F%98%E9%95%BF%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="变长子网划分"></p>
<ul>
<li>假设上有图是对192.168.0.0/24</li>
<li>C网段：子网掩码：255.255.255.128/25 网络号: 192.168.0.128/25</li>
<li>B网段：子网掩码：255.255.255.192/26 网络号: 192.168.0.192/26</li>
<li>A网段：子网掩码：255.255.255.224/27 网络号: 192.168.0.224/27</li>
<li>D网段：子网掩码：255.255.255.252/30 网络号: 192.168.0.252/30</li>
<li>E网段：子网掩码：255.255.255.252/30 网络号: 192.168.0.252/30</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>规律总结：</strong></p>
<ul>
<li>合并不同网段后，所能容纳的IP数量+2</li>
<li>n = 2^k（k&gt;=1） 不会有IP浪费的合并方式，需合并的第一个网络号（<strong>二进制</strong>）末位为0且（<strong>相对于其他连续的网络号</strong>）有k个连续的0，就代表该网络号能合并n个连续网络号，子网掩码前移k位。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>子网和超网的判断方法</strong></p>
<ul>
<li>该网段和默认子网掩码位数多：<strong>子网（后移）</strong></li>
<li>该网段和默认 子网掩码位数少：<strong>超网（前移）</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>MAC</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议 - 基本概念</title>
    <url>/Network-Protocols/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%20-%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍网络通信的基础协议、网络中的一些基础设备的优缺点。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="网络互连模型（OSI参考模型）"><a class="header-anchor" href="#网络互连模型（OSI参考模型）">#</a>网络互连模型（OSI参考模型）</h4>
<ul>
<li>
<p>简介： 国际标准化组织 ISO在 1985 年制定了网络互连模型 <strong>OSI 参考模型(Open System Interconnect Reference Model)</strong>，具有7层结构。<br>
<br></p>
</li>
<li>
<p>OSI参考模型(7层)更偏理论，TCP/IP 协议(4层) 在才是在实际中使用的协议，而为了研究和学习计算机网络，又常将之划分为 5层（也就是应用层、会话层和表示层三层统称为应用层）。<br>
<br></p>
</li>
<li>
<p>数据通过网络协议来传播。<br>
<br></p>
</li>
<li>
<p><strong>协议</strong><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="一种通用的标准。">[1]</span></a></sup>本质就是<strong>包装</strong>和<strong>解包</strong>的过程。</p>
</li>
</ul>
<hr>
<h4 id="计算机通信基础"><a class="header-anchor" href="#计算机通信基础">#</a>计算机通信基础</h4>
<ul>
<li><strong>IP地址</strong>和<strong>MAC地址</strong>（网卡地址）<br>
<br></li>
<li>通过网卡判断目标<strong>MAC地址</strong>来决定数据（PDU）是传递还是丢弃。</li>
</ul>
<hr>
<h4 id="计算机互联方式"><a class="header-anchor" href="#计算机互联方式">#</a>计算机互联方式</h4>
<ul>
<li>
<p>网线直连、同轴线缆、集线器、网桥、交换机</p>
<ul>
<li>连接的设备必须在<strong>同一网段</strong>
<ul>
<li><strong>网段</strong>： 计算机网络中使用<strong>同一物理层</strong>直接通讯的部分。（非直连的（也就是通过工作在物理层的设备）如：集线器，中继器(信号增强)转接连接的也视为工作在同一物理层的设备）</li>
<li>补充：通常使用<strong>同一物理层</strong>的设备必然通过相同介质直接连接。</li>
</ul>
</li>
<li>连接的设备处在<strong>同一广播域</strong>。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>广播域和冲突域</strong></p>
<ul>
<li>
<p><strong>广播</strong>是一种信息的<strong>传播方式</strong>，指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为<strong>广播域</strong>(Broadcast Domain)。<br>
<br></p>
</li>
<li>
<p>简单点说，广播域就是指网络中所有能接<strong>收到同样广播消息的设备的集合</strong>。<br>
<br></p>
</li>
<li>
<p><strong>广播域</strong>（Broadcast domain）是<a href="https://www.tw.wiiaa.top/baike-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" rel="external nofollow noreferrer">计算机网络</a>的一个逻辑划分。</p>
<ul>
<li>广播域中的任意一个<a href="https://www.tw.wiiaa.top/baike-%E8%8A%82%E7%82%B9" rel="external nofollow noreferrer">节点</a>可以在<a href="https://www.tw.wiiaa.top/baike-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" rel="external nofollow noreferrer">数据链路层</a>通过<a href="https://www.tw.wiiaa.top/baike-%E5%B9%BF%E6%92%AD" rel="external nofollow noreferrer">广播</a>的方式到达任意一个节点。</li>
<li>广播域可以被部署在同一个局域网或者被桥接到其他的局域网。<br>
<br></li>
</ul>
</li>
<li>
<p>与广播域相对的是<a href="https://www.tw.wiiaa.top/w/index.php?title=%E5%86%B2%E7%AA%81%E5%9F%9F&amp;action=edit&amp;redlink=1" rel="external nofollow noreferrer">冲突域</a>。<br>
<br></p>
</li>
<li>
<p><strong>冲突域</strong>（collision domain)：在以太网中，如果某个<strong>CSMA/CD</strong><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="**载波侦听多路访问**（英语：Carrier Sense Multiple Access，缩写：CSMA）是一种[介质访问控制](https://www.tw.wiiaa.top/baike-介质访问控制)（MAC）的协议。**载波侦听**（英语：Carrier Sense）指任何连接到介质的设备在欲发送帧前，必须对介质进行侦听，当确认其空闲时，才可以发送。**多路访问**（英语：Multiple Access）指多个设备可以同时访问介质，一个设备发送的帧也可以被多个设备接收。
">[2]</span></a></sup>网络上的两台计算机在<strong>同时通信时会发生冲突</strong>，那么这个<strong>CSMA/CD</strong>网络就是一个<strong>冲突域</strong>。</p>
<ul>
<li>冲突域中所有节点都链接到同一个被交换机和学习型网桥划分的<strong>相互连接的中继器集合</strong>。</li>
<li>如果以太网中的各个网段以集线器连接，因为不能避免冲突，所以它们仍然是一个冲突域。</li>
<li>冲突域一般来说<strong>小于或者包含</strong>在广播域中。 一些处在<a href="https://www.tw.wiiaa.top/baike-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82" rel="external nofollow noreferrer">数据链路层</a>的设备能够划分冲突域，但是广播域只能由像路由器或者网络层交换机这样的<a href="https://www.tw.wiiaa.top/baike-%E7%BD%91%E7%BB%9C%E5%B1%82" rel="external nofollow noreferrer">网络层</a>的设备来进行划分。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>广播域和冲突域的区别：</strong></p>
<ul>
<li>
<p>广播域可以跨网段，而冲突域只是发生的同一个网段的。 以太网中，冲突域是由hub组织的。一个hub就是一个冲突域。交换机的每个端口都是一个冲突域。<strong>网段</strong>，又叫<strong>潜在冲突域</strong>。<br>
<br></p>
</li>
<li>
<p>冲突域在同一个冲突域中的每一个节点都能收到所有被发送的帧。广播域在网络中能接收任一设备发出的广播帧的所有设备的集合<br>
<br></p>
</li>
<li>
<p>冲突域是基于第一层（<strong>物理层</strong>），而广播域是机于第二层（<strong>数据链路层</strong>） 。<br>
<br></p>
</li>
<li>
<p>广播域就是说，如果站点发出一个广播信号后能接收到这个信号的范围，通常来说一个<strong>局域网</strong>就是一个广播域。（用路由器连接的除外）。冲突域是一个站点向另一个站点发出信号，除目的站点外，有多少站点能收到这个信号，这些站点就构成一个冲突域。<br>
<br></p>
</li>
<li>
<p>HUB 所有端口都在同一个广播域，冲突域内。<strong>switch</strong>所有端口都在同一个广播域内，而每一个端口就是一个冲突域<br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>网线直连</strong>（使用铜交叉线非直通线）</p>
<ul>
<li>通过ARP协议，广播<strong>IP地址</strong>来获得<strong>MAC地址</strong>，可以通过<code>arp -a</code> 命令查看ARP缓存。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>同轴线缆</strong></p>
<ul>
<li>半双工通信(单向)</li>
<li>容易冲突</li>
<li>不安全</li>
<li>中间线路断开，整个网络瘫痪<br>
<br></li>
</ul>
</li>
<li>
<p><strong>集线器</strong></p>
<ul>
<li>半双工通信</li>
<li>容易冲突</li>
<li>不安全<br>
<br></li>
</ul>
</li>
<li>
<p><strong>网桥</strong></p>
<ul>
<li>能够区分两侧<strong>MAC地址</strong>（通过学习左右侧记录MAC地址）</li>
<li>隔绝了冲突域<br>
<br></li>
</ul>
</li>
<li>
<p><strong>交换机</strong></p>
<ul>
<li>
<p>全双工通信</p>
</li>
<li>
<p>比集线器安全</p>
</li>
<li>
<p>相当于接口更多的网桥（前身都消失德）</p>
</li>
<li>
<p>二层交换机没有IP层(不存在IP地址和MAC地址)<br>
<br></p>
</li>
<li>
<p>当全球使用交换机连接会出现的问题有：</p>
<ul>
<li>处在同一网段会导致<strong>IP地址不够用</strong></li>
<li>由于所有设备都处在同一广播域，都能接收广播帧，也就会出现<strong>广播风暴</strong>。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>路由器</strong></p>
<ul>
<li>可以在不同网段传播数据</li>
<li>隔绝广播域</li>
<li>不在同一网段的IP会通过路由器的<strong>网关</strong>（Gateway）通过路由器转发数据</li>
</ul>
</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">一种通用的标准。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><strong>载波侦听多路访问</strong>（英语：Carrier Sense Multiple Access，缩写：CSMA）是一种<a href="https://www.tw.wiiaa.top/baike-%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6" rel="external nofollow noreferrer">介质访问控制</a>（MAC）的协议。<strong>载波侦听</strong>（英语：Carrier Sense）指任何连接到介质的设备在欲发送帧前，必须对介质进行侦听，当确认其空闲时，才可以发送。<strong>多路访问</strong>（英语：Multiple Access）指多个设备可以同时访问介质，一个设备发送的帧也可以被多个设备接收。<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Network Protocols</category>
      </categories>
      <tags>
        <tag>MAC</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试模型</title>
    <url>/Software-Testing/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍自动化测试模型相关概念和实例。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="区分自动化测试库、框架和工具"><a class="header-anchor" href="#区分自动化测试库、框架和工具">#</a>区分自动化测试库、框架和工具</h3>
<ul>
<li>自动化测试库（Library）
<ul>
<li>类似于面向对象的类库，面向过程的函数库，自动化测试库剔红了一组操作Web页面的方法。</li>
</ul>
</li>
<li>框架（Framework）
<ul>
<li>框架是为解决<strong>一个或一类问题</strong>而开发得产品，<code>unittest</code>框架主要用于测试用例组织和执行工作，因此通常称为<strong>单元测试框架</strong>。</li>
<li>工具（Tools）
<ul>
<li>工具与框架类似，只是会有<strong>更高的抽象</strong>（一般会有单独得操作界面），<strong>屏蔽了底层代码</strong>，例如selenium IDE和QTP就是自动化测试工具。</li>
</ul>
</li>
</ul>
</li>
<li>自动化测试模型：
<ul>
<li>可以认为是自动化测试框架与工具设计的思想。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="自动化测试模型介绍"><a class="header-anchor" href="#自动化测试模型介绍">#</a>自动化测试模型介绍</h4>
<ul>
<li>
<p><strong>线性测试</strong></p>
<ul>
<li>通过录制或编写对应程序的操作步骤的线性脚本，每个脚本相对独立，且不产生其他依赖与调用。</li>
<li>优点：
<ul>
<li>每个脚本独立完整可单独执行。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>测试用例的开发和维护成本高。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>模块化驱动测试</strong></p>
<ul>
<li>借鉴编程语言中的模块化思想，抽取重复的操作独立成公共模块。</li>
<li>优点：
<ul>
<li>提高了开发效率，降低了维护复杂性<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数据驱动测试</strong></p>
<ul>
<li>由于数据的改变从而驱动自动化测试的执行，最终引起测试结果的改变。（脚本与数据分离，也就是<strong>参数化</strong>）</li>
<li>优点：
<ul>
<li>进一步增强了脚本的复用性。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>关键字驱动测试</strong></p>
<ul>
<li>
<p>封装了底层代码，通过关键字的改变从而引起测试结果的改变。（过程式的编写用例）</p>
</li>
<li>
<p>典型的关键字驱动工具以UTF、RIDE为主。（封装了底层代码实现，提供用户独立的用户界面）</p>
</li>
<li>
<p>优点：</p>
<ul>
<li>降低了脚本编写的难度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="模块化驱动测试实例"><a class="header-anchor" href="#模块化驱动测试实例">#</a>模块化驱动测试实例</h4>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mail163.py</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> .public <span class="keyword">import</span> Login</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://email.163.com/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用登录模块</span></span><br><span class="line">Login().user_login(driver)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收信 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用退出模块</span></span><br><span class="line">Login().user_logout(driver)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># public.py</span></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">user_login</span>(<span class="params">self, driver</span>):</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.j-inputtext&quot;</span>).clear()</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.j-inputtext&quot;</span>).send_keys(<span class="string">&quot;xxxxxx&quot;</span>)</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.dlpwd&quot;</span>).clear()</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.dlpwd&quot;</span>).send_keys(<span class="string">&quot;xxxxxxx&quot;</span>)</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.u-loginbtn&quot;</span>).click()</span><br><span class="line"><span class="comment"># 收信</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">user_logout</span>(<span class="params">self, driver</span>):</span><br><span class="line">        driver.find_element_by_link_text(<span class="string">&quot;退出&quot;</span>).click()</span><br><span class="line">        driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="数据驱动测试实例"><a class="header-anchor" href="#数据驱动测试实例">#</a>数据驱动测试实例</h4>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mail163.py</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> .public <span class="keyword">import</span> Login</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://email.163.com/&quot;</span>)</span><br><span class="line"></span><br><span class="line">username = <span class="string">&quot;guest&quot;</span></span><br><span class="line">password = <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用登录模块</span></span><br><span class="line">Login().user_login(driver, username, password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收信 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用退出模块</span></span><br><span class="line">Login().user_logout(driver)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># public.py</span></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">user_login</span>(<span class="params">self, driver, username, password</span>):</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.j-inputtext&quot;</span>).clear()</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.j-inputtext&quot;</span>).send_keys(username)</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.dlpwd&quot;</span>).clear()</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.dlpwd&quot;</span>).send_keys(password)</span><br><span class="line">        driver.find_element_by_css_selector(<span class="string">&quot;.u-loginbtn&quot;</span>).click()</span><br><span class="line"><span class="comment"># 收信</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">user_logout</span>(<span class="params">self, driver</span>):</span><br><span class="line">        driver.find_element_by_link_text(<span class="string">&quot;退出&quot;</span>).click()</span><br><span class="line">        driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Software Testing</category>
      </categories>
      <tags>
        <tag>Automated Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>WebDriver API</title>
    <url>/Software-Testing/WebDriver%20API/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>WebDriver是一个用于实现Web自动化的第三方库，本文主要介绍WebDriver的用法及原理。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="定位元素"><a class="header-anchor" href="#定位元素">#</a>定位元素</h4>
<ul>
<li>
<p>WebDriver 提供了八种定位方法(tag 标签，partial局部的)</p>
<ul>
<li>id -&gt; name</li>
<li>class name -&gt; tag name</li>
<li>link text -&gt; partial link text</li>
<li>xpath -&gt; css selector</li>
<li>find_element_by_id() -&gt; find_element_by_name()</li>
<li>find_element_by_class_name() -&gt; find_element_by_tag_name()</li>
<li>find_element_by_link_text() -&gt; find_element_by_partial_link_text()</li>
<li>find_element_by_xpath() -&gt; find_element_by_css_selector<br>
<br></li>
</ul>
</li>
<li>
<p><strong>Xpath定位</strong>(find_element_by_xpath())</p>
<ul>
<li>
<p>Xpath简介：<strong>XPath 是一门在 XML 文档中查找信息的语言</strong></p>
</li>
<li>
<p>Xpath主要用：标签名的层级关系来定位元素的绝对路径。举例:div[2]代表当前层级下第二个div</p>
</li>
<li>
<p><strong>绝对路径定位</strong>：使用XPath语言定位。</p>
</li>
<li>
<p><strong>利用元素属性定位</strong>(XPath可使用<strong>元素的任意属性</strong>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element_by_xpath(<span class="string">&quot;//input[@id=&#x27;kw&#x27;]&quot;</span>)</span><br><span class="line">find_element_by_xpath(<span class="string">&quot;//input[@name=&#x27;wd&#x27;]&quot;</span>)</span><br><span class="line">find_element_by_xpath(<span class="string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>)</span><br><span class="line">find_element_by_xpath(<span class="string">&quot;//*[@class=&#x27;bg s_btn&#x27;]&quot;</span>)</span><br><span class="line">find_element_by_xpath(<span class="string">&quot;//input[@maxlength=&#x27;100&#x27;]&quot;</span>)</span><br><span class="line">find_element_by_xpath(<span class="string">&quot;//input[@autocomplete=&#x27;off&#x27;]&quot;</span>)</span><br><span class="line">find_element_by_xpath(<span class="string">&quot;//input[@type=&#x27;submit&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>//<strong>代表当前页面某个目录</strong></p>
<ul>
<li>不指定标签名，也可以用- 代替</li>
</ul>
</li>
<li>
<p><strong>层级与属性结合</strong>（元素本身没有唯一可标识的属性值）’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element_by_xpath(<span class="string">&quot;//span[@class=&#x27;bg s_ipt_wr&#x27;]/input&quot;</span>)</span><br><span class="line">find_element_by_xpath(<span class="string">&quot;//from[@id=&#x27;from&#x27;]/span/input&quot;</span>)</span><br><span class="line">find_element_by_xpath(<span class="string">&quot;//from[@id=&#x27;from&#x27;]/sapn[2]/input&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用逻辑运算符(属性不能唯一得区分一个元素,连接多个属性)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element_by_xpath(<span class="string">&quot;//input[@id=&#x27;kw&#x27; and @class=&#x27;su&#x27;]/span/input&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>FirePath插件直接生成Xpath语法</p>
</li>
<li>
<p><strong>使用starts-with方法</strong></p>
<ul>
<li><code>//*[starts-with(@attribute, &quot;xxx&quot;)]</code></li>
</ul>
</li>
<li>
<p><strong>使用contains方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># driver.find_element_by_xpath(&quot;//a[contains(text(),&#x27;一个很长的&#x27;)]&quot;)</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&quot;//span[contains(@class,&#x27;s_ipt_wr&#x27;)]/input&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>使用text()方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># //*[text()=&quot;xxx&quot;]</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&quot;//a[text(),&#x27;新闻&#x27;)]&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p><strong>CSS定位</strong>(一般情况下速度要比XPath快)</p>
<ul>
<li>
<p>选择所有元素</p>
<ul>
<li><code>find_element_by_class_selector(&quot;*&quot;)</code></li>
</ul>
</li>
<li>
<p>使用class属性定位</p>
<ul>
<li><code>find_element_by_class_selector(&quot;.s_ipt&quot;)</code></li>
</ul>
</li>
<li>
<p>使用id属性来定位：</p>
<ul>
<li><code>find_element_by_class_selector(&quot;#kw&quot;)</code></li>
</ul>
</li>
<li>
<p>使用标签名来定位元素</p>
<ul>
<li><code>find_element_by_class_selector(&quot;input&quot;)</code></li>
</ul>
</li>
<li>
<p>通过父子关系来定位</p>
<ul>
<li>span下的所有input
<ul>
<li><code>find_element_by_class_selector(&quot;span&gt;input&quot;)</code></li>
</ul>
</li>
<li>同一级span之后的所有input
<ul>
<li><code>find_element_by_class_selector(&quot;span+input&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过属性定位</p>
<ul>
<li><code>find_element_by_class_selector(&quot;[name='kw']&quot;)</code></li>
</ul>
</li>
<li>
<p>组合定位</p>
<ul>
<li><code>find_element_by_class_selector(&quot;span.bg si_sipt_wr&gt;input.s_ipt&quot;)</code></li>
</ul>
</li>
<li>
<p>使用属性的部分定位的CSS表达式：</p>
<ul>
<li>标签[属性^=‘值’] 属性开头包含</li>
<li>标签[属性$=‘值’] 属性结尾包含</li>
<li>标签[属性*=‘值’] 属性开头包含</li>
</ul>
</li>
<li>
<p>使用伪类选择器的CSS表达式</p>
<ul>
<li>伪类选择器（简称：伪类）通过冒号来定义，它定义了元素的状态，如点击按下，点击完成等，通过伪类可以为元素的状态修改样式。</li>
<li>div#div1:first-child</li>
<li>div#div1:nth-child</li>
<li>div#div1:last-child</li>
<li>input:focus</li>
<li>input:enabled</li>
<li>input:checked</li>
</ul>
</li>
<li>
<p>查找同级元素的CSS表达式</p>
<ul>
<li>div#div1 - input + a</li>
<li>div#div1 - input + a + img</li>
<li>div#div1 - input + - + img<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用谷歌console验证</p>
<ul>
<li>$(‘css表达式’)验证css表达式</li>
<li>输入$x(‘xpath表达式’)验证xpath表达式<br>
<br></li>
</ul>
</li>
<li>
<p><strong>使用By定位</strong></p>
<ul>
<li>
<p>用By定位元素（统一调用find_element()方法）</p>
</li>
<li>
<p>将By类导入: <code>from selenium.webdriver.common.by import By</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element(By.ID,<span class="string">&quot;kw&quot;</span>)</span><br><span class="line">find_element(By.NAME,<span class="string">&quot;wd&quot;</span>)</span><br><span class="line">find_element(By.TAG_NAME,<span class="string">&quot;input&quot;</span>)</span><br><span class="line">find_element(By.LINK_TEXT,<span class="string">&quot;新闻&quot;</span>)</span><br><span class="line">find_element(By.PARTIAL-LINK-TEXT,<span class="string">&quot;新&quot;</span>)</span><br><span class="line">find_element(By.XPATH,<span class="string">&quot;//*[@class=&#x27;bg s_btn&#x27;]&quot;</span>)</span><br><span class="line">find_element(By.CSS_SELECTOR,<span class="string">&quot;span.bg s_btn-wr&gt;input#su&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意事项</p>
<ul>
<li>WebDriver更加推荐前面介绍的写法（父子类）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="控制浏览器"><a class="header-anchor" href="#控制浏览器">#</a>控制浏览器</h4>
<ul>
<li>
<p>WebDriver 主要提供的是操作页面上各种元素的方法，但是也提供了操作浏览器的一些方法，例如控制浏览器的大小，操作浏览器的前进和后退等。<br>
<br></p>
</li>
<li>
<p>控制浏览窗口的大小</p>
<ul>
<li><code>set_window_size()</code></li>
<li><code>maximize_window()</code>方法打开浏览器的全屏显示</li>
</ul>
</li>
<li>
<p>模拟浏览器刷新</p>
<ul>
<li><code>dirver.refresh()</code>   # 刷新当前页面<br>
<br></li>
</ul>
</li>
<li>
<p>简单的元素操作</p>
<ul>
<li><code>driver.forword()</code>前进</li>
<li><code>driver.back()</code>后退</li>
<li><code>clear()</code>清除文本</li>
<li><code>send_keys(*value)</code> 模拟按键输入</li>
<li><code>click()</code>单击元素</li>
<li><code>submit（）</code>方法用来提交表单<br>
<br></li>
</ul>
</li>
<li>
<p><strong>获取元素的属性</strong></p>
<ul>
<li>size     返回元素的尺寸。</li>
<li>text     获取元素的文本</li>
<li><code>get_attribute(name)</code>获得属性值</li>
<li><code>is_displayed()</code>设置该元素是否用户可见。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>鼠标事件</strong></p>
<ul>
<li>需要导入ActionChains类</li>
<li>ActionChains(driver)</li>
<li>perform()执行所有ActionChains的存储行为, 提交动作</li>
<li>context(right_click)模拟鼠标右键操作，需要元素定位</li>
<li>double_click()双击</li>
<li>drag_and_drop()拖动和释放</li>
<li>move_to_element()鼠标悬停<br>
<br></li>
</ul>
</li>
<li>
<p><strong>键盘事件</strong></p>
<ul>
<li>Keys类几乎提供了键盘上的所有方法。</li>
<li>send_keys(Keys.BACK_SPACE) 删除键（BackSpace）</li>
<li>send_keys(Keys.SPACE) 空格键(Space)</li>
<li>send_keys(Keys.TAB) 制表键(Tab)</li>
<li>send_keys(Keys.ESCAPE) 回退键（Esc）</li>
<li>send_keys(Keys.ENTER) 回车键（Enter）</li>
<li>send_keys(Keys.CONTROL,‘a’) 全选（Ctrl+A）</li>
<li>send_keys(Keys.CONTROL,‘c’) 复制（Ctrl+C）</li>
<li>send_keys(Keys.CONTROL,‘x’) 剪切（Ctrl+X）</li>
<li>send_keys(Keys.CONTROL,‘v’) 粘贴（Ctrl+V）</li>
<li>send_keys(Keys.F1) 键盘 F1</li>
<li>send_keys(Keys.F12) 键盘 F12<br>
<br></li>
</ul>
</li>
<li>
<p><strong>获取验证信息</strong></p>
<ul>
<li>通常用的最多的验证信息（title、URL和text）</li>
<li>获取当前页面的title
<ul>
<li><code>driver.title</code></li>
</ul>
</li>
<li>获取当前页面的url
<ul>
<li><code>driver.current_url</code></li>
</ul>
</li>
<li>获取标签的文本
<ul>
<li><code>driver.find_element_by _id(&quot;kw&quot;).text</code><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>设置元素等待</strong></p>
<ul>
<li>
<p>页面上元素可能并不是同时被加载完成的（web应用程序使用了大量的AJAX技术）这给定位增加了困难</p>
</li>
<li>
<p><strong>显示等待</strong>（达到最大时限时抛出超时异常）</p>
<ul>
<li>WebDriverWait类时WebDriver提供的等待方法，在设置时间内，默认每隔一段时间检测当前页面元素是否存在，如果超过设定时间检测不到则抛出异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> `selenium.webdriver.support` <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">element = WebDriverWaitdriver(driver,<span class="number">5</span>,<span class="number">0.5</span>).until</span><br><span class="line">(EC.presence_of_element_located((By.ID,<span class="string">&quot;kw&quot;</span>)))</span><br><span class="line">element.send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>隐式等待</strong>（抛出无此元素异常）</p>
<ul>
<li>
<p>超过设定时常元素还没有被加载，就抛出NoSuchElementException异常。</p>
</li>
<li>
<p>implicitly_wait()实现隐式等待</p>
</li>
<li>
<p>webdriver提供了implicitly_wait()来实现隐式等待, 默认为0 , 一般在元素定位操作之前设置</p>
</li>
</ul>
</li>
<li>
<p><strong>强制等待</strong>: <code>sleep()</code></p>
<ul>
<li>通过Python内置time模块提供，通过sleep(n秒)强制等待来延迟执行下一个操作 （参数可以是小数）</li>
</ul>
</li>
<li>
<p>不同等待之间的区别</p>
<ul>
<li>强制等待的时间是固定的<br>
<br></li>
<li>显式等待是在等待时间内对条件轮询(0.5s),当超出等待时间条件仍不满足,抛出超时异常(TimeOutException), <strong>建议在js异步和需要延时才能查找到元素的场景下使用显式等待.</strong>（能够确定等待时间时使用）<br>
<br></li>
<li>隐式等待是在等待时间内对页面加载完毕的当前dom轮询,查看元素是否加载,当超出等待时间,抛出无此元素的异常(NoSuchElementException), 如有多个元素查找会创建多个隐式等待<br>
<br></li>
<li>若同时设置显示等待和隐式等待，当显示等待在设定的等待时间内条件满足,则停止等待,执行后面的操作(使用隐式等待),否则抛出超时异常。<br>
<br></li>
<li><strong>显示等待会优先于隐式等待，当显式等待超时少于隐式等待超时,会继续进入隐式等待。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="WebDriver-常用操作"><a class="header-anchor" href="#WebDriver-常用操作">#</a>WebDriver 常用操作</h4>
<ul>
<li>
<p><strong>定位一组元素</strong></p>
<ul>
<li><code>find_elements_xxx(&quot;xx&quot;)</code>   定位一组元素</li>
</ul>
</li>
<li>
<p><strong>多表单切换</strong></p>
<ul>
<li><code>switch_to.frame()</code>  进入表单</li>
<li><code>switch_to.default_content()</code>  退出表单至根页面</li>
</ul>
</li>
<li>
<p><strong>多窗口切换</strong></p>
<ul>
<li><code>switch_to.window()</code>切换窗口</li>
<li>current_window_handle 获得当前窗口的句柄</li>
<li>window_handles：返回所有窗口的句柄到当前会话</li>
</ul>
</li>
<li>
<p><strong>警告框</strong></p>
<ul>
<li>text：返回 alert/confirm/prompt 中的文字信息。</li>
<li>accept()：接受现有警告框。</li>
<li>dismiss()：解散现有警告框。</li>
<li>send_keys(keysToSend)： 发送文本至警告框。</li>
</ul>
</li>
<li>
<p><strong>下拉框</strong></p>
<ul>
<li>Select  操作select标签的下拉框。</li>
<li>select_by_value()  选择value属性选择。</li>
<li>select_by_visible_text() 通过选项名称选择。</li>
<li>select_by_index() 通过索引选择</li>
</ul>
</li>
<li>
<p><strong>文件上传</strong></p>
<ul>
<li>
<p><strong>Chrome浏览器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">chrome浏览器实现下载</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">options = webdriver.ChromeOptions() </span><br><span class="line">prefs = &#123;<span class="string">&#x27;profile.default_content_settings.popups&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;download.default_directory&#x27;</span>: os.getcwd()&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;prefs&#x27;</span>, prefs) </span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(chrome_options=options) </span><br><span class="line">driver.get(<span class="string">&quot;https://pypi.org/project/selenium/#files&quot;</span>)</span><br><span class="line">driver.find_element_by_partial_link_text(<span class="string">&quot;selenium-3.141.0.tar.gz&quot;</span>).click()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Firefox浏览器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">firefox浏览器实现下载</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">fp = webdriver.FirefoxProfile()</span><br><span class="line">fp.set_preference(<span class="string">&quot;browser.download.folderList&quot;</span>, <span class="number">2</span>)</span><br><span class="line">fp.set_preference(<span class="string">&quot;browser.download.dir&quot;</span>, os.getcwd())</span><br><span class="line">fp.set_preference(<span class="string">&quot;browser.helperApps.neverAsk.saveToDisk&quot;</span>, <span class="string">&quot;binary/octet-stream&quot;</span>)</span><br><span class="line">driver = webdriver.Firefox(firefox_profile=fp)</span><br><span class="line">driver.get(<span class="string">&quot;https://pypi.org/project/selenium/#files&quot;</span>)</span><br><span class="line">driver.find_element_by_partial_link_text(<span class="string">&quot;selenium-3.141.0.tar.gz&quot;</span>).click()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>Cookie</strong></p>
<ul>
<li>
<p><code>driver.add_cookie(dict)</code></p>
</li>
<li>
<p><code>driver.get_cookies()</code></p>
</li>
</ul>
</li>
<li>
<p><strong>调用js代码</strong></p>
<ul>
<li><code>driver.execute_script(js)</code></li>
</ul>
</li>
<li>
<p><strong>窗口截图</strong></p>
<ul>
<li>driver.get_screenshot_as_file(“/Screenshots/foo.png”)</li>
</ul>
</li>
<li>
<p><strong>关闭窗口</strong></p>
<ul>
<li><code>driver.close()</code></li>
</ul>
</li>
<li>
<p><strong>使用logging模块basicCofig()方法</strong></p>
<ul>
<li>
<p>开启debug模块捕获客户端向服务器发送的post请求。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="WebDriver原理"><a class="header-anchor" href="#WebDriver原理">#</a>WebDriver原理</h5>
<ul>
<li>
<p>WebDriver启动目标浏览器，并绑定到指定的端口，将创建的浏览器实例作为WebDriver的Remote Server（远程服务器）</p>
</li>
<li>
<p>Client端通过<code>CommandExcuter</code>发送<code>HTTPRequest</code>给Remote Server的侦听端口。</p>
</li>
<li>
<p>Remote Server需要原生的浏览器组件（<code>chromdriver</code>，等来转换浏览器的本地（native）调用）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing</category>
      </categories>
      <tags>
        <tag>WebDriver</tag>
      </tags>
  </entry>
  <entry>
    <title>环境搭建基础</title>
    <url>/Software-Testing/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍自动化测试环境搭建、Python相关概念和pip包管理工具。</li>
</ul>
<span id="more"></span>
<h4 id="环境搭建"><a class="header-anchor" href="#环境搭建">#</a>环境搭建</h4>
<ul>
<li>
<p>安装<a href="https://www.python.org/" rel="external nofollow noreferrer">Python</a></p>
</li>
<li>
<p>更换国内源镜像源</p>
<ul>
<li><code>pip install selenium==xx.xx -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code><br>
<br></li>
</ul>
</li>
<li>
<p>安装Selenium包</p>
<ul>
<li>运行命令 <code>pip install --user selenium</code><br>
<br></li>
</ul>
</li>
<li>
<p>pip国内软件源可供安装的地址：</p>
<ul>
<li><code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></li>
<li><code>https://pypi.doubanio.com/simple/</code><br>
<br></li>
</ul>
</li>
<li>
<p>配置浏览器驱动</p>
<ul>
<li>
<p>pip命令安装chromedriver（推荐）</p>
<ul>
<li>安装
<ul>
<li><code>pip install chromedriver-py</code></li>
</ul>
</li>
<li>使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> chromedriver_py <span class="keyword">import</span> binary_path</span><br><span class="line">driver = webdriver.Chrome(executable_path=binary_path) <span class="comment"># driver初始化的时候一定要指定executable_path参数为chromedriver_py模块的binary_path变量。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/breuerfelix/chromedriver-py" rel="external nofollow noreferrer">chromedriver_py</a>的本地文件夹
<ul>
<li>由于使用的pip安装，所以<code>chromedriver</code>在Python环境下的<code>Lib\site-packages\chromedriver_py</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>手动下载安装chromedriver</p>
<ul>
<li>下载<a href="http://www.seleniumhq.org/download/" rel="external nofollow noreferrer">浏览器驱动</a>放于Python安装目录下。</li>
<li><a href="http://chromedriver.storage.googleapis.com/index.html" rel="external nofollow noreferrer">chrome浏览器驱动下载</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>pip的常用命令</p>
<ul>
<li><code>pip freeze</code> 或<code>pip list</code> 列举已安装的包
<ul>
<li>导出requirements.txt(用于生成记录所有依赖包及其精确的版本号。以便新环境部署。)</li>
</ul>
</li>
<li><code>pip freeze</code>  &lt;目录&gt;/requirements.txt</li>
<li><code>pip install</code> &lt;目录&gt;/&lt;文件名&gt;</li>
<li><code>pip intstall -upgrade</code> 或 <code>pip install -U</code> &lt;包名&gt;升级包</li>
<li><code>pip pip install -U pip</code> 升级</li>
<li><code>pip show</code> &lt;包名-现实指定包版本</li>
<li><code>pip show -f</code> &lt;包名-显示包所在目录</li>
<li><code>pip search</code> &lt;搜索关键字&gt;</li>
<li><code>pip list -o</code> 查询可升级的包</li>
<li><code>pip install</code> &lt;包名–d &lt;目录-或 <code>pip install -d</code> &lt;目录–r requirements.txt 下载包而不安装</li>
<li><code>pip wheel</code> &lt;包名-打包</li>
<li><code>pip install</code> 软件名称 == 很大的数字 查看全部可安装版本</li>
<li><code>ctrl + c</code> 打断<br>
<br></li>
</ul>
</li>
<li>
<p><code>Chrome Driver</code>下载</p>
<ul>
<li><code>chromedriver</code>的版本一定要与Chrome的版本一致，不然就不起作用。</li>
<li>有两个下载地址：
<ul>
<li><code>http://chromedriver.storage.googleapis.com/index.html</code></li>
<li><code>https://npm.taobao.org/mirrors/chromedriver</code></li>
</ul>
</li>
<li><code>Firefox Driver</code> 下载
<ul>
<li><code>https://github.com/mozilla/geckodriver/releases</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Python-基础"><a class="header-anchor" href="#Python-基础">#</a>Python 基础</h4>
<ul>
<li>
<p>print函数</p>
<ul>
<li>转换说明符</li>
<li>%s  字符串，采用str()</li>
<li>%r  采用repr()显示</li>
<li>%c  Unicode 码点</li>
<li>%d  十进制整数</li>
<li>%i  十进制整数</li>
<li>%o  八进制整数</li>
<li>%x  十六进制整数</li>
<li>%e  指数（基底为e）</li>
<li>%E  指数（基底为E）</li>
<li>%f  浮点数</li>
<li>%F  浮点数</li>
<li>%g  指数（e）或浮点数</li>
<li>%G  指数（e）或浮点数</li>
<li>格式化输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>))  <span class="comment"># 保留两位小数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<ul>
<li>
<p>引号与注释</p>
<ul>
<li>单行注释 #</li>
<li>多行注释 ```注释内容```</li>
<li>支持三引号（不论单双）</li>
</ul>
</li>
<li>
<p>引用模块import</p>
<ul>
<li>
<p>如果确定不会从把不同模块导入同名函数</p>
<ul>
<li>from 模块名称 import -</li>
</ul>
</li>
<li>
<p>注意：自定函数名与导入函数同名会覆盖原函数。</p>
</li>
<li>
<p>理解执行import，Python到底做了那些操作</p>
<ul>
<li>创建一个<code>module</code>（可能包含多个<code>module</code>）</li>
<li>把这个<code>module</code>插入到<code>sys.module</code>中</li>
<li>装载<code>module</code>的代码（如果需要，则必须先编译）</li>
<li>创建对象，插入对象，装载要执行的代码，执行对应代码。</li>
</ul>
</li>
<li>
<p>装载代码过程：</p>
<ul>
<li>当前路径（以及从当前目录指定的<code>sys.path</code>）</li>
<li>Python的PATH</li>
<li>Python安装时的默认路径。</li>
<li>执行新的module中对应的代码</li>
</ul>
</li>
<li>
<p>补充</p>
<ul>
<li>./ 代表当前目录</li>
<li>…/ 代表上一级目录</li>
<li>/是根目录<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>异常</p>
<ul>
<li>异常抛出机制
<ul>
<li>程序运行时发生异常，解释器会查询相应处理语句（称为handler）</li>
<li>如果再当前函数理没有找到就会将异常传递给上层调用函数</li>
<li>如果再最外层（全局“main”）中还是未找到，解释器就会退出，同时打印Traceback，方便用户找到错误产生原因。</li>
<li>所有异常都继承Exception，所以可以使用它来接受所有类型的异常。</li>
<li>Python2.5后所有的异常类都继承与基类<code>BaseException</code>，Exception同样继承与<code>BaseException</code><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Python运算符优先级表<br>
<img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/image-20200325204946064.png" alt="Python运算符优先级"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试基础</title>
    <url>/Software-Testing/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍软件测试、软件自动化测试相关概念和工具。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="软件测试分类"><a class="header-anchor" href="#软件测试分类">#</a>软件测试分类</h4>
<ul>
<li>
<p>根据项目流程划分</p>
<ul>
<li>
<p>单元测试（模块测试）</p>
<ul>
<li>子程序或具有独立功能代码块</li>
</ul>
</li>
<li>
<p>集成测试</p>
<ul>
<li>先组成系统或子系统再测试，重点检查模块间的接口</li>
</ul>
</li>
<li>
<p>系统测试</p>
<ul>
<li>整个产品系统（需求说明书）</li>
</ul>
</li>
<li>
<p>验收测试</p>
<ul>
<li>最终测试（完成系统和功能测试后，产品发布之前的测试）(验证功能和性能)<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>按照对代码可见度来划分</p>
<ul>
<li>白盒测试
<ul>
<li>关注内部动作</li>
</ul>
</li>
<li>黑盒测试
<ul>
<li>关注外部输入输出</li>
</ul>
</li>
<li>灰盒测试
<ul>
<li>既关注外部输入输出又关注内部动作。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>软件的不同测试面来划分</p>
<ul>
<li>功能测试
<ul>
<li>逻辑功能测试，界面测试，易用性测试，安装测试，兼容性测试等。</li>
</ul>
</li>
<li>性能测试
<ul>
<li>时间性能(具体环境)</li>
</ul>
</li>
<li>空间性能（带宽，CPU）<br>
<br></li>
</ul>
</li>
<li>
<p>按照自动化程度划分</p>
<ul>
<li>手工测试</li>
<li>自动化测试
<ul>
<li>功能自动化和性能自动化<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>测试周期中的一些方法</p>
<ul>
<li>冒烟测试
<ul>
<li>测试新版本之前，投入较少人力和时间验证软件主要功能。</li>
</ul>
</li>
<li>回归测试
<ul>
<li>修改了旧代码后，重新进行测试以确定修改没有引入新错误或导致其他代码产生错误。（第二轮）</li>
</ul>
</li>
<li>随机测试
<ul>
<li>测试输入数据随机生成，目的是模拟用户<strong>真实操作</strong>，发现<strong>边缘错误。</strong></li>
</ul>
</li>
<li>探索性测试
<ul>
<li>测试的思维技术，一种<strong>思维方式</strong>，强调测试人员<strong>主观能动性</strong>，遇到问题时<strong>改变测试策略</strong>。</li>
</ul>
</li>
<li>安全测试
<ul>
<li>生命周期中特别是<strong>开发基本完成到发布阶段</strong>，对产品验证符合产品<strong>安全需求定义</strong>和<strong>质量标准</strong>的过程</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="分层的自动化测试"><a class="header-anchor" href="#分层的自动化测试">#</a>分层的自动化测试</h4>
<ul>
<li>
<p>背景</p>
<ul>
<li>传统的自动化测试：
<ul>
<li>基于产品的UI的自动化测试，将黑盒测试转化为通过程序或工具执行的一种自动化测试。</li>
</ul>
</li>
<li>传统的自动化测试缺点（黑盒测试环节尽可能全面覆盖，自动化）
<ul>
<li>测试规模增大</li>
<li>全面UI自动化测试（由于UI易变，使得UI维护成本相对高昂）<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>分层自动化测试</p>
<ul>
<li>
<p>强调从黑盒（UI）单层到黑白盒多层的自动化测试体系</p>
</li>
<li>
<p>从全面黑盒自动化测试到对系统的不同层次进行自动化测试</p>
</li>
<li>
<p>单元自动化测试（10%）</p>
<ul>
<li>对软件中的最小可测试单元检查和验证。（类，函数，窗口）<br>
<br></li>
</ul>
</li>
<li>
<p>接口自动化测试(20%)</p>
<ul>
<li>模块接口测试和Web接口测试
<ul>
<li>模块接口测试（单元测试基础 -&gt; 单元结果验证）
<ul>
<li>工具与单元自动化测试相同</li>
</ul>
</li>
<li>Web接口测试
<ul>
<li><strong>服务器接口测试</strong>和<strong>外部接口测试</strong></li>
</ul>
</li>
</ul>
</li>
<li>服务器接口测试
<ul>
<li>浏览器与服务器的接口（通过HTTP协议实现前后端数据传递）</li>
</ul>
</li>
<li>外部接口测试(70%)
<ul>
<li>第三方系统提供的接口（第三方登录接口）</li>
</ul>
</li>
<li>接口测试相应的类库和工具： HttpUnit 、Postman<br>
<br></li>
</ul>
</li>
<li>
<p>UI自动化测试</p>
<ul>
<li>由于所有功能的展示都在这一层，所以测试工作大多集中在这一层。</li>
<li>因此建议提倡<strong>半自动化</strong>开展测试工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="自动化测试应用场景"><a class="header-anchor" href="#自动化测试应用场景">#</a>自动化测试应用场景</h4>
<ul>
<li>一般满足以下三个条件就可开展自动化测试
<ul>
<li>软件需求变动不频繁</li>
<li>项目的周期长</li>
<li>自动化测试脚本可重复利用</li>
</ul>
</li>
<li>任务测试明确，不会频繁变动(<strong>重要</strong>)</li>
<li>每日构建后的测试验证</li>
<li>比较频繁的回归测试</li>
<li>软件系统界面稳定，变动少</li>
<li>需要在多个平台上运行相同的测试案例、组合遍历型的测试、大量重复的任务。</li>
<li>软件维护的周期长（<strong>重要</strong>）</li>
<li>项目的进度压力不大。</li>
<li>被测软件系统开发较为规范，能够保证系统可测试性。</li>
<li>具备大量自动化测试平台。</li>
<li>测试人员具备较强的编程能力。</li>
<li>自动化测试脚本可重复利用（<strong>重要</strong>）</li>
</ul>
<hr>
<h4 id="自动化测试及其工具"><a class="header-anchor" href="#自动化测试及其工具">#</a>自动化测试及其工具</h4>
<ul>
<li>
<p><strong>广义</strong>上的自动化测试：指的是借助工具来辅助进行软件测试的方式</p>
</li>
<li>
<p><strong>狭义</strong>上的自动化测试：指的是基于UI的功能测试</p>
</li>
<li>
<p>自动化测试工具</p>
<ul>
<li>UFT（QTP和ST合并）</li>
<li>Robot FrameWork（基于python）</li>
<li>Watir(基于ruby)</li>
<li>selenium</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Selenium工具介绍"><a class="header-anchor" href="#Selenium工具介绍">#</a>Selenium工具介绍</h4>
<ul>
<li>
<p>Selenium工具介绍</p>
<ul>
<li>主要用于Web应用程序的自动化测试</li>
</ul>
</li>
<li>
<p>Selenium IDE</p>
<ul>
<li>火狐插件，方便开发脚本</li>
</ul>
</li>
<li>
<p>Selenium Grid</p>
<ul>
<li><strong>自动化测试辅助工具</strong>可加快Web-App功能测试，很方便在对台机器和异构环境执行测试用例（不同计算机和系统的网络环境）</li>
</ul>
</li>
<li>
<p>Selenium RC</p>
<ul>
<li>Selenium家族核心部分,支持多种语言编写的自动化测试脚本。</li>
</ul>
</li>
<li>
<p>Selenium2.0</p>
<ul>
<li>Selenium1.0 = Selenium IDE+Selenium Grid+Selenium RC</li>
<li>Selenium2.0 = Selenium 1.0 +WebDirver</li>
<li>Selenium3.0</li>
<li>WebDriver是通过原生的浏览器支持或浏览器扩展来直接控制浏览器</li>
<li>WebDriver能利用操作系统级别调用，能够更好模拟用户输入。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="前端基础（补充）"><a class="header-anchor" href="#前端基础（补充）">#</a>前端基础（补充）</h4>
<ul>
<li>基础知识
<ul>
<li>HTMl 超文本标记语言</li>
<li>JavaScript 前端脚本语言（轻量级语言），是一种解释性的语言，不需要预编译</li>
<li>XML 可扩展标记语言 通用标记语言的一个子集。作为传输工具和存储数据。（数据内容）</li>
</ul>
</li>
<li>前端工具
<ul>
<li>Fire Bug  火狐开发类插件</li>
<li>FirePath XPath(XML的路径语言,用来确定XML文档中的部分位置)</li>
<li>Chrome开发人员工具</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing</category>
      </categories>
      <tags>
        <tag>Automated Testing</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Git 的使用</title>
    <url>/Blog/%E5%85%B3%E4%BA%8E%20Git%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>Git 是一个分布式版本控制系统，每个客户端都是一个完整的版本库。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="Git-简述"><a class="header-anchor" href="#Git-简述">#</a>Git 简述</h3>
<ul>
<li>
<p>Git 背景</p>
<ul>
<li>Git是创建之初是为了辅助Linux内核使用的。<br>
<br></li>
</ul>
</li>
<li>
<p>Git 简介</p>
<ul>
<li>Git是一个分布式版本控制软件，主要用于<strong>版本迭代</strong>，每一个客户端都是包含整个版本控制过程中的完整镜像。<br>
<br></li>
</ul>
</li>
<li>
<p>Linux 基础命令</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基础命令</span></span><br><span class="line">1. cd &lt;path&gt;</span><br><span class="line">2. cd ... &lt;返回上一级目录&gt;</span><br><span class="line">3. pwd &lt;当前路径&gt;</span><br><span class="line">4. ls(ll) &lt;列出当前目录所有文件&gt;</span><br><span class="line">5. touch &lt;filename&gt; &lt;新建文件&gt;</span><br><span class="line">6. mkdir &lt;folder&gt; &lt;新建文件夹&gt;</span><br><span class="line">7. rm -f &lt;folder&gt; &lt;删除文件夹&gt;</span><br><span class="line">8. mv &lt;filename&gt; &lt;folder&gt; &lt;移动文件到文件夹&gt;</span><br><span class="line">9. cd- 返回之前所在的目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扩展命令</span></span><br><span class="line">10. reset &lt;初始化终端&gt;</span><br><span class="line">11. clear &lt;清屏&gt;</span><br><span class="line">12. history &lt;查看历史命令&gt;</span><br><span class="line">13. help </span><br><span class="line">14. exit</span><br><span class="line">15. #表示注释</span><br><span class="line">16. cd - &lt;返回之前所在的目录&gt;</span><br><span class="line">17. set -e &lt;确保脚本抛出遇到的错误&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Git-配置"><a class="header-anchor" href="#Git-配置">#</a>Git 配置</h4>
<ul>
<li>
<p><code>git config --local -l</code></p>
<ul>
<li>查看仓库配置 【优先级最高】<br>
<br></li>
</ul>
</li>
<li>
<p><code>git config --global -l</code></p>
<ul>
<li>查看用户配置 【优先级次之】<br>
<br></li>
</ul>
</li>
<li>
<p><code>git config --system -l</code></p>
<ul>
<li>查看系统配置 【优先级最低】<br>
<br></li>
</ul>
</li>
<li>
<p><code>git config -l</code></p>
<ul>
<li>查看所有的配置信息，依次是系统级别、用户级别、仓库级别<br>
<br></li>
</ul>
</li>
<li>
<p>Git对配置文件使用</p>
<ul>
<li>配置文件的权重是：仓库 &gt; 全局 &gt; 系统。</li>
<li>配置文件的查找是：系统 &gt; 全局 &gt; 仓库。<br>
<br></li>
</ul>
</li>
<li>
<p>git config 的配置文件路径</p>
<ul>
<li>仓库配置
<ul>
<li>路径：当前路径</li>
</ul>
</li>
<li>用户配置(全局)
<ul>
<li>路径：<code>C:\Users\username\gitconfig</code></li>
</ul>
</li>
<li>系统配置
<ul>
<li>路径：<code>Git安装目录\etc\gitconfig</code><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>git config 常用配置</p>
<ul>
<li>
<p>编辑配置文件</p>
<ul>
<li><code>git config --local -e</code> 编辑仓库级别配置文件</li>
<li><code>git config --global -e</code> 编辑用户级别配置文件</li>
<li><code>git config --system -e</code> 编辑系统级别配置文件<br>
<br></li>
</ul>
</li>
<li>
<p>配置全局的用户名和邮箱</p>
<ul>
<li><code>git config [--global] user.name &quot;[name]&quot;</code></li>
<li><code>git config [--global] user.email &quot;[email address]&quot;</code><br>
<br></li>
</ul>
</li>
<li>
<p>关于配置项的使用(默认都是在local配置中)</p>
<ul>
<li>增加配置项
<ul>
<li><code>git config [--local|--global|--system] --add section.key value</code></li>
</ul>
</li>
<li>获取配置项
<ul>
<li><code>git config [--local|--global|--system] --get section.key</code></li>
</ul>
</li>
<li>删除配置项
<ul>
<li><code>git config [--local|--global|--system] --unset section.key</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Git-的工作流程"><a class="header-anchor" href="#Git-的工作流程">#</a>Git 的工作流程</h4>
<ul>
<li>
<p>工作区：就是你在电脑里能看到的目录。</p>
</li>
<li>
<p>暂存区：英文叫stage或index。一般存放在&quot;git目录&quot;下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</p>
</li>
<li>
<p>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>
<br></p>
</li>
<li>
<p>创建本地仓库</p>
<ul>
<li><code>git init [project-name]</code></li>
<li><code>git clone [url]</code><br>
<br></li>
</ul>
</li>
<li>
<p>将需要进行版本控制的文件添加到暂存区</p>
<ul>
<li><code>git add .</code><br>
<br></li>
</ul>
</li>
<li>
<p>将暂存区中的文件提交到本地仓库</p>
<ul>
<li><code>git commit -m [message]</code><br>
<br></li>
</ul>
</li>
<li>
<p>将本地仓库的文件提交到远程</p>
<ul>
<li><code>git push [remote] [branch]</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="Git-工作原理"><a class="header-anchor" href="#Git-工作原理">#</a>Git 工作原理</h4>
<ul>
<li>
<p>Git 工作区域</p>
<ul>
<li>本地工作区域
<ul>
<li>Workspace：工作区
<ul>
<li>需要进行版本控制的区域</li>
</ul>
</li>
<li>Index/Stage：暂存区
<ul>
<li>用于临时存放工作区中的改动，只是一个文件。</li>
</ul>
</li>
<li>Repository：仓库区
<ul>
<li>本地仓库，保存提交文件的所有版本信息。其中Head指向最新放入的仓库版本。</li>
</ul>
</li>
</ul>
</li>
<li>中心服务器
<ul>
<li>Remote：远程仓库
<ul>
<li>托管代码的服务器，主要进行数据版本控制和多人协同开发。<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Git 文件状态</p>
<ul>
<li>已修改（modified）</li>
<li>已暂存（staged）</li>
<li>已提交(committed)<br>
<br></li>
</ul>
</li>
<li>
<p>Git 的key-value的数据库</p>
<ul>
<li>git数据库存储文件时，只关心文件整体内容，不关心单个文件内容是否改变。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Git-使用"><a class="header-anchor" href="#Git-使用">#</a>Git 使用</h4>
<ul>
<li>
<p>Git 本地仓库搭建</p>
<ul>
<li>创建本地仓库
<ul>
<li><code>git init</code> 初始化Git仓库</li>
<li><code>git add .</code> 添加所有文件到暂存区</li>
<li><code>git status [filename]</code> 查看文件状态</li>
<li><code>git commit -m &quot;message&quot;</code> 提交暂存区内容到本地仓库</li>
</ul>
</li>
<li>克隆远程仓库
<ul>
<li>git push 提交本体仓库内容到远程服务器<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>.gitignore文件的使用</p>
<ul>
<li>注释：<code>#</code>用于注释。</li>
<li>通配符：<code>*</code>代表任意多个；<code>？</code>代表一个字符；<code>！</code>表示不被忽略。</li>
<li><code>folder/</code>: 该目录下的所有文件，不包括该目录下的子目录。</li>
<li><code>/folder</code>: 该目录下面的所有文件，默认文件和目录都忽略。<br>
<br></li>
</ul>
</li>
<li>
<p>.gitkeep文件</p>
<ul>
<li>使 Git 保留一个空文件夹<br>
<br></li>
</ul>
</li>
<li>
<p>创建SSH密钥</p>
<ul>
<li><code>ssh-keygen -t rsa -C 'youremail@outlook.com'</code>
<ul>
<li>创建的公私钥对默认位于：<code>C:\Users\username\.ssh</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Git-分支操作"><a class="header-anchor" href="#Git-分支操作">#</a>Git 分支操作</h5>
<ul>
<li>
<p>Git分支基础操作：</p>
<ul>
<li>创建：
<ul>
<li>创建仓库和分支：<code>git init -b &lt;branch_name&gt;</code></li>
<li>创建分支：<code>git branch &lt;branch_name&gt;</code></li>
<li>创建并切换分支：<code>git checkout -b &lt;branch_name&gt;</code></li>
</ul>
</li>
<li>查看：<code>git branch</code>(仓库没有提交内容的话会看不见分支me)</li>
<li>切换：<code>git checkout &lt;branch_name&gt;</code></li>
<li>删除：<code>git &lt;branch_name&gt;</code>(-d是删除已经合并过的， -D是删除没有合并过的)</li>
<li>重命名：
<ul>
<li><code>git branch -m &lt;old_name&gt; &lt;new_name&gt;</code></li>
<li><code>git branch -m new-name</code></li>
</ul>
</li>
<li>合并：<code>git merge &lt;target_branch_name&gt;</code><br>
<br></li>
</ul>
</li>
<li>
<p>Git分支常用操作</p>
<ul>
<li><code>git add .</code> 和 <code>git add -A</code> 区别
<ul>
<li><code>git add .</code> 会把当前目录及子孙目录里的变动都加到暂存区</li>
<li><code>git add -A</code> 添加当前目录下的所有文件到暂存区，包括已修改的文件</li>
</ul>
</li>
<li>在本地仓库中建立一个与远程仓库的别名，以便之后提交代码而不是每次都要输入远程仓库地址。
<ul>
<li><code>git remote add homepage git@github.com:shuguang2000/homepage.git</code></li>
</ul>
</li>
<li>确认已添加远程仓库别名
<ul>
<li><code>git remote -v</code></li>
</ul>
</li>
<li>gh-pages分支和main分支推送到远程仓库，推送完成会自动添加关联映射
<ul>
<li><code>git push -u homepage gh-pages</code></li>
<li><code>git push -u homepage main</code></li>
</ul>
</li>
<li>将本地分支gh-pages与远程homepage仓库分支关联</li>
<li>关联目的是在执行git pull, git push操作时就不需要指定对应的远程分支，你只要没有显示指定，git pull的时候，就会提示你。
<ul>
<li><code>git branch --set-upstream-to=homepage/gh-pages gh-pages</code></li>
</ul>
</li>
<li>删除建立的关联关系
<ul>
<li><code>git branch --unset-upstream</code></li>
</ul>
</li>
<li>强行拉取不同项目，解决不通项目不能合并问题，拉取完后再推送
<ul>
<li><code>git pull  homepage main --allow-unrelated-histories</code></li>
</ul>
</li>
<li>查看本地分支与远程分支的映射关系
<ul>
<li><code>git branch -vv</code></li>
</ul>
</li>
<li>查看所有分支，包括本地和远程分支
<ul>
<li><code>git branch -a</code></li>
</ul>
</li>
<li>拉取远程仓库gh-pages的变化，并与本地分支gh-pages合并
<ul>
<li><code>git pull</code></li>
</ul>
</li>
<li>比较本地两个分支的文件差异
<ul>
<li><code>git diff gh-pages</code></li>
</ul>
</li>
<li>git push命令的–force或-f 强制推送
<ul>
<li><code>git push --force homepage main:main</code></li>
</ul>
</li>
<li>将当前分支更改推送到远程仓库中的main分支
<ul>
<li><code>git push homepage main</code></li>
</ul>
</li>
<li>本地main发布更新到远程仓库gh-pages分支
<ul>
<li><code>git push homepage main:gh-pages</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="关于Git在VScode中的使用"><a class="header-anchor" href="#关于Git在VScode中的使用">#</a>关于Git在VScode中的使用</h5>
<ul>
<li>
<p>配置默认终端配置为： <code>Git Bash</code></p>
<ul>
<li>在xxx.code-workspace文件中添加如下代码：<br>
<br></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.defaultProfile.linux&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.defaultProfile.osx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.defaultProfile.windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Git Bash&quot;</span><span class="punctuation">,</span> <span class="comment">// 如果你在 Windows 上使用 Git Bash</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<ul>
<li>
<p>使用快捷键 Ctrl+` 打开终端窗口<br>
<br></p>
</li>
<li>
<p>安装VScode插件<a href="https://github.com/gitkraken/vscode-gitlens.git" rel="external nofollow noreferrer">GitLens</a></p>
</li>
</ul>
<hr>
<h5 id="Thanks"><a class="header-anchor" href="#Thanks">#</a>Thanks</h5>
<ul>
<li>
<p><a href="https://github.com/gitkraken/vscode-gitlens.git" rel="external nofollow noreferrer">GitLens</a><br>
<br></p>
</li>
<li>
<p><a href="https://git-scm.com/book/zh/v2" rel="external nofollow noreferrer">Pro Git book</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 常用操作</title>
    <url>/Blog/Hexo%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本文主要介绍了关于Hexo<strong>基础知识</strong>和<strong>常用命令</strong>，更多相关内容参考<a href="https://hexo.io/zh-cn/docs/" rel="external nofollow noreferrer">Hexo文档</a>。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="Hexo-简介"><a class="header-anchor" href="#Hexo-简介">#</a>Hexo 简介</h3>
<ul>
<li>
<p><strong>Hexo文档</strong>：<a href="https://hexo.io/zh-cn/docs/" rel="external nofollow noreferrer">https://hexo.io/zh-cn/docs/</a><br>
<br></p>
</li>
<li>
<p><strong>Hexo目录结构</strong></p>
<ul>
<li>_config.yml
<ul>
<li>网站的配置信息。</li>
</ul>
</li>
<li>package.json
<ul>
<li>应用程序的信息（依赖）。</li>
</ul>
</li>
<li>scaffolds
<ul>
<li>模版文件夹，Hexo 会根据 scaffold 来建立文章。</li>
</ul>
</li>
<li>source
<ul>
<li>资源文件夹是存放用户资源的地方。</li>
<li>除_posts文件夹之外，开头命名为_(下划线)的文件 | 文件夹和隐藏的文件将会被忽略。</li>
<li>Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li>
</ul>
</li>
<li>themes
<ul>
<li>主题文件夹。Hexo 会根据主题来生成静态页面。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Hexo基础知识</strong></p>
<ul>
<li>
<p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。（如默认可渲染mark down和ejs格式文章：hexo-renderer-marked 和 hexo-renderer-ejs）<br>
<br></p>
</li>
<li>
<p>Hexo相关配置：<a href="https://hexo.io/zh-cn/docs/configuration" rel="external nofollow noreferrer">https://hexo.io/zh-cn/docs/configuration</a><br>
<br></p>
</li>
<li>
<p>Hexo 有三种默认布局：post、page 和 draft。</p>
<ul>
<li>page将储存到source，draft将储存到source/_drafts；而自定义的其他布局和 post 相同（默认）储存到 source/_posts 文件夹。<br>
<br></li>
</ul>
</li>
<li>
<p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量。（这也是Hexo文章于普通Markdown文章的区别）<br>
<br></p>
</li>
<li>
<p>分类和标签</p>
<ul>
<li>分类具有顺序性和层次性，而标签没有顺序和层次。(不允许指定多个同级分类)</li>
<li>为文章添加多个分类，可以尝试使用list，每个列表是该文章一个分类，list中除第一个元素外其余元素都是该list的子分类。<br>
<br></li>
</ul>
</li>
<li>
<p>标签插件</p>
<ul>
<li>用于在文章中快速插入特定内容的插件。</li>
<li>标签插件不应包含在Markdown语法中。<br>
<br></li>
</ul>
</li>
<li>
<p>关于相对路径中引用的标签插件</p>
<ul>
<li>使用相对路径的常规 markdown语法资源不会出现在首页上。（但是它会在文章中按你期待的方式工作）</li>
<li>但使用标签插件后资源会同时出现在文章和主页以及归档页中。<br>
<br></li>
</ul>
</li>
<li>
<p>数据文件</p>
<ul>
<li>有时可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。</li>
<li>如：next主题配置文件中存在相关配置，只需要在source/_data下创建对应的YAML 或 JSON 文件即可。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Hexo自定义</strong></p>
<ul>
<li>
<p>永久链接</p>
<ul>
<li>_config.yml 配置中或者在每篇文章的 Front-matter 中，均可调整网站的永久链接（permalink）。</li>
<li><a href="https://hexo.io/zh-cn/docs/permalinks" rel="external nofollow noreferrer">permalink参数变量</a>
<ul>
<li>:title文件名称 (relative to “source/_posts/“ folder)</li>
<li>:name文件名称</li>
<li>:post_title文章标题<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>多语种支持</p>
<ul>
<li>修改 new_post_name 和 permalink 参数</li>
<li>在新建文章时指定<code>--lang language</code><br>
<br></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:lang/:title.md</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:lang/:title/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Hexo常用命令"><a class="header-anchor" href="#Hexo常用命令">#</a>Hexo常用命令</h4>
<ul>
<li>
<p><strong>部署</strong></p>
<ul>
<li>
<p><code>hexo init [folder]</code></p>
<ul>
<li>新建一个网站（git远程克隆hexo-starter 和 hexo-theme-landscape主题，并使用包管理器下载依赖）<br>
<br></li>
</ul>
</li>
<li>
<p><code>hexo clean</code></p>
<ul>
<li>清除缓存文件 db.json 和已生成的静态文件 public。<br>
<br></li>
</ul>
</li>
<li>
<p><code>hexo generate | hexo g</code></p>
<ul>
<li>生成静态文件到public（默认）文件夹。
<ul>
<li><code>-w, --watch</code> 监视文件变动</li>
<li><code>-b, --bail</code> 生成过程中如果发生任何未处理的异常则抛出异常</li>
<li><code>-f, --force</code> 强制重新生成文件，Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</li>
<li>如果使用自动部署（使用插件hexo-deployer-git），不需要先执行该命令。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>hexo server</code></p>
<ul>
<li>启动本地服务器，用于预览主题
<ul>
<li><code>-p, --port</code> 重设端口</li>
<li><code>-s, --static</code> 只使用静态文件
<ul>
<li>在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理文件变动（通常用于生产环境（production mode）下。）</li>
</ul>
</li>
<li><code>-l, --log</code> 启动日记记录，使用覆盖记录格式<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>hexo deploy | hexo d</code></p>
<ul>
<li>部署网站。<br>
<br></li>
</ul>
</li>
<li>
<p><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></p>
<ul>
<li>建议使用。</li>
<li>不建议使用 <code>hexo g -d</code> 或者 <code>hexo d -g</code> 这类组合命令</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>写作</strong></p>
<ul>
<li>
<p><code>hexo new [layout] &lt;title&gt;</code></p>
<ul>
<li>Hexo 有三种默认布局：<strong>post</strong>、<strong>page</strong> 和 <strong>draft</strong>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</li>
<li>新建一篇文章（布局默认使用default_layout参数代替）</li>
<li>若标题包含空格，需使用<strong>引号括起来</strong>。默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。(title/index.md)。</li>
<li><code>-p, --path &lt;path&gt; &lt;title&gt;</code> 自定义新文章的路径，指定路径后(默认会在source/_posts下创建)，Hexo 会使用路径下当前文件夹作为文件名称。（path/current_dir.md）</li>
<li><code>-r, --replace</code> 如果存在同名文章，将其替换</li>
<li><code>--lang &lt;language&gt;</code> 创建指定语言文件夹下的文章，文章的标题将不再决定文章的路径（language/title.md）<br>
<br></li>
</ul>
</li>
<li>
<p><code>hexo render &lt;file1&gt; [file2] ...</code></p>
<ul>
<li>渲染文件。</li>
<li><code>-o, --output</code> 设置输出路径<br>
<br></li>
</ul>
</li>
<li>
<p><code>hexo publish [layout] &lt;filename&gt;</code></p>
<ul>
<li>通过 publish 命令将草稿移动到 source/_posts 文件夹。</li>
<li>草稿默认不会显示在页面中，可在执行时加上 <code>--draft</code> 参数，或是把 render_drafts 参数设为 true 来预览草稿。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Hexo标签插件"><a class="header-anchor" href="#Hexo标签插件">#</a>Hexo标签插件</h4>
<ul>
<li>
<p>Hexo 使用内建 <a href="https://mozilla.github.io/nunjucks/" rel="external nofollow noreferrer">Nunjucks</a> 模板引擎。<br>
<br></p>
</li>
<li>
<p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。<br>
<br></p>
</li>
<li>
<p>虽然可以使用任何格式书写你的文章，但是<strong>标签插件永远可用</strong>，且语法也都是一致的。<br>
<br></p>
</li>
<li>
<p>完整的标签列表参考：<a href="https://hexo.io/docs/tag-plugins.html" rel="external nofollow noreferrer">https://hexo.io/docs/tag-plugins.html</a></p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Pages中的自定义域</title>
    <url>/Blog/GitHub%20Pages%20%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>关于 GitHub Pages 使用自定义域使用的基础知识。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="GitHub-Pages中的自定义域"><a class="header-anchor" href="#GitHub-Pages中的自定义域">#</a>GitHub Pages中的自定义域</h3>
<ul>
<li>
<p><strong>支持的自定义域</strong></p>
<ul>
<li>GitHub支持子域和顶点域（apex）。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>多仓库使用自定义域</strong></p>
<ul>
<li>默认情况下（也就是说项目 Github Pages 站点已发布但不定义自定义域名时），Github Pages 的个人站点的域名将会作用于名下所有已发布的项目站点（<a href="http://xn--www-kd9d0x15v1rpy0slw1f18hc0a.octocat.com/%E9%A1%B9%E7%9B%AE%E5%90%8D%E6%9D%A5%E8%AE%BF%E9%97%AE%EF%BC%89%E3%80%82" rel="external nofollow noreferrer">也就是说可以通过www.octocat.com/项目名来访问）。</a><br>
<br></li>
</ul>
</li>
<li>
<p><strong>验证自定义域</strong></p>
<ul>
<li>当Github Pages 站点被禁用，但设置了自定义域，则存在域接管的风险。通过验证自定义域可以防止其他 GitHub 用户将你的域用于他们的存储库。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>自定义域使用方法</strong></p>
<ul>
<li>关于 Github Pages常见的使用流程和方法。</li>
</ul>
</li>
</ul>
<br>
<ul>
<li><strong>自定义域相关问题</strong>
<ul>
<li>关于 Github Pages 实际使用中遇到的问题解决方案。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="支持的自定义域"><a class="header-anchor" href="#支持的自定义域">#</a>支持的自定义域</h4>
<ul>
<li>GitHub Pages 适用于两种类型的域：
<ul>
<li>
<p>子域</p>
<ul>
<li>www子域：<code>www.example.com</code></li>
<li>自定义子域：<code>blog.example.com</code><br>
<br></li>
</ul>
</li>
<li>
<p>顶级域（apex 域）：<code>example.com</code></p>
<ul>
<li>顶点域是不包含子域的自定义域<br>
<br></li>
</ul>
</li>
<li>
<p>始终建议使用 www 子域</p>
<ul>
<li>www 子域不受 GitHub 服务器的 IP 地址变动的影响。</li>
<li>如果通过 DNS 提供程序配置每种域类型的正确记录，GitHub Pages 将自动在域之间创建重定向（自动重定向仅适用于 www 子域和顶点域之间）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="验证自定义域"><a class="header-anchor" href="#验证自定义域">#</a>验证自定义域</h4>
<ul>
<li>
<p>当 GitHub Pages 站点被禁用时，能避免域被接管</p>
<ul>
<li>可防止其他 GitHub 用户将你的域用于他们的存储库。</li>
<li>验证的域会阻止其他 GitHub 用户接管你的自定义域并使用它来发布他们自己的 GitHub Pages 站点。<br>
<br></li>
</ul>
</li>
<li>
<p>不建议使用自定义子域指向顶点域</p>
<ul>
<li>会遇到对网站强制实施 HTTPS 的问题，此外还可能会遇到子域根本无法访问 GitHub Pages 网站的问题。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="自定义域使用方法"><a class="header-anchor" href="#自定义域使用方法">#</a>自定义域使用方法</h4>
<ul>
<li>
<p><strong>关于 DNS 解析的使用</strong></p>
<ul>
<li><a href="https://developers.cloudflare.com/dns/" rel="external nofollow noreferrer">Cloudflare DNS 文档</a><br>
<br></li>
</ul>
</li>
<li>
<p><strong>配置子域和顶点域</strong></p>
<ul>
<li>使用 DNS 提供商配置 A 记录（如<code>www.username.com</code> -&gt; <code>185.199.108.153</code>）</li>
<li>使用 DNS 提供商配置 CNAME 记录（如<code>www.username.com</code> -&gt; <code>www.username.github.io</code>）<br>
<br></li>
</ul>
</li>
<li>
<p><strong>验证自定义域</strong></p>
<ul>
<li>通过 DNS 提供商配置 TXT record 验证顶点域
<ul>
<li>使用 GitHub 提供 TXT 记录</li>
<li>使用 DNS 提供商配置该 TXT 记录<br>
<br></li>
</ul>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/images/20240922214418.png" alt="Github Pages 验证顶点域"></p>
</li>
</ul>
<hr>
<h4 id="自定义域相关问题"><a class="header-anchor" href="#自定义域相关问题">#</a>自定义域相关问题</h4>
<ul>
<li>
<p>关于Hexo个人站点添加自定义域</p>
<ul>
<li>Hexo可以直接手动在source目录添加CNAME文件并填写自定义域（<code>www.example.com</code>）, 这样就可以实现自定义域 -&gt; 个人站点的默认域（<code>username.github.io.</code>）跳转。<br>
<br></li>
</ul>
</li>
<li>
<p>关于<a href="https://www.godaddy.com/" rel="external nofollow noreferrer">GoDaddy</a></p>
<ul>
<li>由于GoDaddy购买的域名默认是停放的（Parked），并且 www 子域名是默认指向顶级域。
<ul>
<li>删除关于&quot; A @ Parked&quot; 的 A 记录</li>
<li>建议将 www 子域指向 <code>username.github.io.</code>，将顶点域名指向 www 子域。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>关于使用强制 HTTPS</p>
<ul>
<li>GitHub 不会默认颁发 TSL 证书，除非的 CNAME 记录www子域指向站点默认域（<code>username.github.io.</code>）</li>
<li>关于项目站点：在站点默认域成功更改自定义域后，项目站点即可勾选强制HTTPS</li>
</ul>
</li>
</ul>
<hr>
<h5 id="Thanks"><a class="header-anchor" href="#Thanks">#</a>Thanks</h5>
<ul>
<li>
<p><a href="https://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages" rel="external nofollow noreferrer">GitHub Pages 中的自定义域</a><br>
<br></p>
</li>
<li>
<p><a href="https://github.com/orgs/community/discussions/22052" rel="external nofollow noreferrer">GitHub 证书请求错误</a><br>
<br></p>
</li>
<li>
<p><a href="https://developers.cloudflare.com/dns/" rel="external nofollow noreferrer">Cloudflare DNS 文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>Domain</tag>
      </tags>
  </entry>
  <entry>
    <title>礼品卡</title>
    <url>/Games/%E7%A4%BC%E5%93%81%E5%8D%A1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>礼品卡在国外已经很成熟了，这里简要解释礼品卡一些相关知识。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h3>
<ul>
<li>
<p>实体物品礼品卡：以等价值商品为<strong>信用</strong>，从而进行资金回流的经营手段，能创造流动性。（本质类似于<strong>发债</strong>）<br>
<br></p>
</li>
<li>
<p>虚拟物品礼品卡：虚拟类行业以等价值虚拟物品为信用，从而进行资金回流的经营手段，能创造流动性。（本质类似于<strong>发债</strong>）</p>
</li>
</ul>
<h3 id="礼品卡简述"><a class="header-anchor" href="#礼品卡简述">#</a>礼品卡简述</h3>
<ul>
<li>
<p>实体物品礼品卡</p>
<ul>
<li>商家通过礼品卡的方式能快速创造流动性，快速获得流动性的资金，类似于资本市场的<strong>发债</strong>。</li>
<li>礼品卡的本质是：该商家的一种<strong>负债</strong><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="还能创造价值。
">[1]</span></a></sup>，商家必须需要支付等价值的商品。<br>
<br></li>
</ul>
</li>
<li>
<p>虚拟物品礼品卡</p>
<ul>
<li>虚拟类商家的一种发债手段，与实体行业相比的优势是：
<ul>
<li>虚拟物品商家只支付虚拟物品，本身的虚拟<strong>资产</strong><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="不能再创造价值。
">[2]</span></a></sup>已独家代理给商家，商家只需要支付对应销量虚拟物品价值的分成给开发者（比如Steam就是抽30%）。</li>
<li>需要支付的虚拟类商品不存在负债，还能增加流动性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="使用场景"><a class="header-anchor" href="#使用场景">#</a>使用场景</h4>
<ul>
<li>外汇管制
<ul>
<li>提现的手续费比较高
<ul>
<li>例如： 中国自然人一年的结汇额度是五万美金。</li>
<li>Paypal -&gt; 用礼品卡套出现金。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>不愿意透露收入来源</li>
<li>洗钱或跑路等手段</li>
</ul>
<hr>
<h4 id="个人破产制度"><a class="header-anchor" href="#个人破产制度">#</a>个人破产制度</h4>
<ul>
<li>
<p>为了稳定的社会中的个人的一种制度。<br>
<br></p>
</li>
<li>
<p>有钱人完成原始积累 -&gt; 资产泡沫 -&gt; 普通人 -&gt; 转移自己的资产<br>
<br></p>
</li>
<li>
<p>扩展</p>
<ul>
<li>纸面资产
<ul>
<li>不一定能创造价值。</li>
</ul>
</li>
<li>人口红利
<ul>
<li>债务转移。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">还能创造价值。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">不能再创造价值。<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Games</category>
      </categories>
  </entry>
  <entry>
    <title>博客优化</title>
    <url>/Blog/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本次博客优化包含: 对整个博客站点的<strong>模板配置</strong>以及<strong>性能优化</strong>。主要是对Next的性能和网站推广优化。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="简述"><a class="header-anchor" href="#简述">#</a>简述</h3>
<ul>
<li><strong>模板选择</strong>
<ul>
<li>在前面我们已经完成了Next主题的使用，关于更多模板请参考: <a href="https://hexo.io/themes/" rel="external nofollow noreferrer">Hexo 主题</a></li>
</ul>
</li>
</ul>
<hr>
<h4 id="模板配置"><a class="header-anchor" href="#模板配置">#</a>模板配置</h4>
<ul>
<li>
<p>关于Next主题的使用参考: <a href="http://theme-next.iissnan.com/theme-settings.html" rel="external nofollow noreferrer">Next主题文档</a><br>
<br></p>
</li>
<li>
<p>界面美化</p>
<ul>
<li>
<p>本次界面美化包括首页、菜单栏、侧边栏、分类页、标签页、书籍页、归档页和友链页等。</p>
<ul>
<li>首先在next主题配置文件中开启自定义数据文件夹(source/_data/styles.styl)</li>
<li>关于<a href="https://cdn.jsdelivr.net/gh/shuguang2000/cdn/scripts/styles.styl" rel="external nofollow noreferrer">styles.styl</a>文件参考代码<br>
<br></li>
</ul>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_39974578/article/details/114172260" rel="external nofollow noreferrer">彩色标签</a><br>
<br></p>
</li>
<li>
<p>自定义404页面</p>
<ul>
<li>自定义或参考网上制作404页面然后放在source目录下。<br>
<br></li>
</ul>
</li>
<li>
<p>菜单栏站点地图</p>
<ul>
<li>启用Next主题配置文件<br>
<br></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
  - 安装站点地图插件：`npm install hexo-generator-sitemap --save`
<br>
<ul>
<li>侧边栏RSS
<ul>
<li>
<p>RSS 是一种内容聚合的工具，它有rss 和 atom 两种协议，xml为基础协议。</p>
<ul>
<li>关于RSS: <a href="./%E6%B6%88%E6%81%AF%E6%9D%A5%E6%BA%90.md">消息来源</a><br>
<br></li>
</ul>
</li>
<li>
<p>Next主题关于RSS的设置在每篇文章的底部添加RSS 链接，但这个显然不符合平常的习惯，所以将其放在左侧侧边栏位置。</p>
<ul>
<li>参考: <a href="https://www.gagahappy.com/hexo-next-theme/" rel="external nofollow noreferrer">https://www.gagahappy.com/hexo-next-theme/</a><br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hexo 插件</p>
<ul>
<li>
<p>文章单词统计（wordcount）</p>
<ul>
<li><a href="https://github.com/theme-next/hexo-symbols-count-time" rel="external nofollow noreferrer">hexo-symbols-count-time</a><br>
<br></li>
</ul>
</li>
<li>
<p>本地搜索（Local Search）</p>
<ul>
<li><a href="https://github.com/theme-next/hexo-generator-search" rel="external nofollow noreferrer">hexo-generator-search</a><br>
<br></li>
</ul>
</li>
<li>
<p>评论系统</p>
<ul>
<li>使用<a href="https://livere.com/login_form" rel="external nofollow noreferrer">来必力</a>
<ul>
<li>注册并登录，获取代码管理页面下的<code>data-uid</code>的值</li>
<li>Next主题配置: livere_uid: # 填入&lt;your_uid&gt;<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>图片预览</p>
<ul>
<li><a href="https://github.com/theme-next/theme-next-fancybox3" rel="external nofollow noreferrer">theme-next-fancybox3</a><br>
<br></li>
</ul>
</li>
<li>
<p>脚注</p>
<ul>
<li><a href="https://github.com/kchen0x/hexo-reference" rel="external nofollow noreferrer">hexo-reference</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p>更换Markdown渲染引擎</p>
<ul>
<li>支持Markdown、GFM和CommonMark</li>
<li><a href="https://github.com/hexojs/hexo-renderer-markdown-it" rel="external nofollow noreferrer">hexo-renderer-markdown-it</a>
<ul>
<li>广泛的配置</li>
<li>比默认渲染器(hexo-renderer-marked)更快</li>
<li>标题的安全 ID</li>
<li>带有 ID 的标题的锚点</li>
<li>…<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>绑定自定义域名（<strong>可选</strong>）</p>
<ul>
<li>去域名商<a href="https://www.godaddy.com/" rel="external nofollow noreferrer">Godaddy</a>或<a href="https://www.namesilo.com/" rel="external nofollow noreferrer">Namesilo</a>买域名</li>
<li>关于域名的使用，参考这篇：<a href="./GitHub%20Pages%20%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F.md">GitHub Pages自定义域</a></li>
</ul>
</li>
</ul>
<hr>
<h5 id="性能优化"><a class="header-anchor" href="#性能优化">#</a>性能优化</h5>
<ul>
<li>
<p>SEO 优化（网站推广）</p>
<ul>
<li>
<p>让搜索引擎收录你的站点</p>
<ul>
<li>优先级
<ul>
<li>主动推送 &gt; 自动推送 &gt; 提交sitemap</li>
</ul>
</li>
<li><a href="https://www.bing.com/webmasters/" rel="external nofollow noreferrer">Bing收录</a></li>
<li><a href="https://search.google.com/search-console/" rel="external nofollow noreferrer">google收录</a></li>
</ul>
</li>
<li>
<p>关于使用 Github Pages 搭建的个人博客无法被百度收录</p>
<ul>
<li>官方给出原因是，百度爬虫爬得太狠，影响了 Github Pages 服务的正常使用<br>
<br></li>
</ul>
</li>
<li>
<p>优化description、keyword和title</p>
<ul>
<li>调查显示只有20%的网页用到“关键字”与“描述”标签（即keyword, description）</li>
<li>description
<ul>
<li>Next主题默认将摘要部分作为文章的description, 所以只需要添加keyword。</li>
<li>description 的描述长度更改为介于 25 到 160 个字符之间（中文大概12到60个字符）。</li>
</ul>
</li>
<li>keywords
<ul>
<li>首页推荐承载3-5个关键词
<ul>
<li>每个关键词有唯一的主目标业务需求性页面并且与首页相互链接。</li>
</ul>
</li>
<li>内页推荐承载1-3个长尾关键词</li>
<li>添加1-2个关键词到title中</li>
<li>可使用<a href="http://lsigraph.com" rel="external nofollow noreferrer">LSI</a>找相关关键词</li>
</ul>
</li>
<li>关于使用
<ul>
<li>
<p>在文章Front-matter中添加description字段，多个用逗号隔开，并以逗号结尾。</p>
</li>
<li>
<p>在<code>themes\next\layout\_partials\head\</code>下的head.swing添加如下代码<br>
<br></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">%-</span> <span class="string">if</span> <span class="string">page.keywords</span> <span class="string">and</span> <span class="string">page.keywords.length</span> <span class="string">%</span>&#125;</span><br><span class="line">  <span class="string">&lt;meta</span> <span class="string">name=&quot;keywords&quot;</span> <span class="string">content=&quot;&#123;&#123;</span> <span class="string">page.keywords</span> <span class="string">&#125;&#125;,&#123;&#123;</span> <span class="string">config.keywords</span> <span class="string">&#125;&#125;&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">&#123;<span class="string">%-</span> <span class="string">endif</span> <span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p>优化站点的URL</p>
<ul>
<li>搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面。</li>
<li>修改站点的永久链接，如:<code>permalink: :category/:name/</code><br>
<br></li>
</ul>
</li>
<li>
<p>优化相关链接，外链自动添加nofollow</p>
<ul>
<li>做好站内各类页面之间的相关链接。</li>
<li>Google推荐使用nofollow，告诉搜索引擎爬虫无需抓取目标页，同时告诉搜索引擎无需将的当前页的Pagerank传递到目标页。（也不需要全部都加上，添加至少2个站外链接到相关的权威网站）</li>
<li><a href="https://github.com/hexojs/hexo-filter-nofollow" rel="external nofollow noreferrer">hexo-filter-nofollow</a><br>
<br></li>
</ul>
</li>
<li>
<p>丰富站点内容</p>
<ul>
<li>扩展站点内容，增强专业性</li>
<li>增加部分原创内容<br>
<br></li>
</ul>
</li>
<li>
<p>关于使用子域名还是子目录</p>
<ul>
<li>需要遵守的原则是：<strong>宁缺勿滥</strong>
<ul>
<li>目录内容庞大  -&gt;  子域名</li>
<li>能够提供足够多的内容  -&gt;  子域名</li>
<li>搜索引擎的处罚机制  -&gt;  滥用子域名<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>网站预加载JS脚本</p>
<ul>
<li>instant.page:提高网站页面加载速度
<ul>
<li>
<p>PC端</p>
<ul>
<li>在用户单击链接之前，他们将鼠标悬停在该链接上。当用户悬停65ms时，有两个用户中的一个会单击该链接，因此instant.page此时开始预加载，平均留给页面预加载的时间超过300 ms。</li>
<li>另一个选项是，当用户开始按下鼠标时，在释放鼠标之前进行预加载。这使得几乎没有未使用的请求，同时页面负载平均提高了80毫秒。<br>
<br></li>
</ul>
</li>
<li>
<p>移动端</p>
<ul>
<li>用户在释放显示器之前开始触摸显示器，平均留出90毫秒供页面预加载。</li>
<li>另一个选择是在链接可见时立即预加载它们。</li>
</ul>
</li>
<li>
<p>Dependencies: <a href="https://github.com/instantpage/instant.page" rel="external nofollow noreferrer">https://github.com/instantpage/instant.page</a></p>
</li>
</ul>
</li>
<li>通过安装minify压缩JS文件
<ul>
<li>安装minify: <code>npm i minify -g</code></li>
<li>压缩JS文件: <code>minify Instant.js &gt; Instant.min.js</code><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>文章压缩</p>
<ul>
<li><a href="https://github.com/rozbo/hexo-neat" rel="external nofollow noreferrer">hexo-neat</a><br>
<br></li>
</ul>
</li>
<li>
<p>优化图片加载</p>
<ul>
<li>图片无损压缩
<ul>
<li>Dependencies: <a href="https://github.com/meowtec/Imagine" rel="external nofollow noreferrer">https://github.com/meowtec/Imagine</a><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>图床工具（PicGo图床+CDN）</p>
<ul>
<li>
<p>使用图床，能缓解站点的压力的，并生成图片的唯一链接，同时也方便管理图片。</p>
<ul>
<li><a href="https://github.com/shuguang2000/cdn/blob/main/README.md" rel="external nofollow noreferrer">使用教程</a><br>
<br></li>
</ul>
</li>
<li>
<p><strong>PicGo图床</strong></p>
<ul>
<li><a href="https://picgo.github.io/PicGo-Doc/" rel="external nofollow noreferrer">官方文档</a><br>
<br></li>
</ul>
</li>
<li>
<p><strong>CDN</strong></p>
<ul>
<li>CDN的全称是Content Delivery Network，即内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载，提高用户访问响应速度和命中率。<br>
<br></li>
<li>使用CDN加速来优化网站打开速度，jsDelivr + GitHub便是免费且好用的CDN。<br>
<br></li>
<li>GitHub使用对应仓库的资源即可: <code>https://cdn.jsdelivr.net/gh/github_username/your_repository@main</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="致谢"><a class="header-anchor" href="#致谢">#</a>致谢</h5>
<ul>
<li>
<p><a href="https://www.cnblogs.com/LyShark/p/11834144.html" rel="external nofollow noreferrer">Hexo之Next主题美化代码</a><br>
<br></p>
</li>
<li>
<p><a href="https://www.gagahappy.com/hexo-next-theme/" rel="external nofollow noreferrer">Next主题侧边栏RSS</a><br>
<br></p>
</li>
<li>
<p><a href="https://mizeri.github.io/2021/04/18/hexo-sitemap-google/" rel="external nofollow noreferrer">Hexo博客站点地图配置</a><br>
<br></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_39974578/article/details/114172260" rel="external nofollow noreferrer">彩色标签</a><br>
<br></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/210428775" rel="external nofollow noreferrer">如何进行SEO优化</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>环境搭建</title>
    <url>/Blog/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>本次环境搭建过程涉及<strong>工具安装</strong>，<strong>搭建仓库并生成SSH Key</strong>，<strong>初始化本地博客</strong>和<strong>部署博客到远程GitHub</strong>四个过程。</li>
</ul>
<span id="more"></span>
<h3 id="工具简述"><a class="header-anchor" href="#工具简述">#</a>工具简述</h3>
<ol>
<li>
<p><strong>Node.Js</strong></p>
<ul>
<li>
<p>Node.js 是一个开源和跨平台的 JavaScript 运行  时环境，用来支持 JavaScript 代码的执行。几乎是任何类型项目的流行工具。<br>
<br></p>
</li>
<li>
<p><strong>npm</strong></p>
<ul>
<li>npm（全称Node Package Manager），是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的，能解决Node.js代码部署上的很多问题，相当于前端的Maven 。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>Hexo和Node.js关系</strong></p>
<ul>
<li>Hexo是基于Node.js开发。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Git</strong></p>
<ul>
<li>
<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。（如：版本迭代）<br>
<br></p>
</li>
<li>
<p><a href="https://git-scm.com/book/zh/v2" rel="external nofollow noreferrer">Git中文文档</a><br>
<br></p>
</li>
<li>
<p>版本控制（补充）</p>
<ul>
<li>
<p>是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。<br>
<br></p>
</li>
<li>
<p>版本控制的作用</p>
<ul>
<li>将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，可以比较文件的变化细节等。<br>
<br></li>
</ul>
</li>
<li>
<p>版本控制的分类</p>
<ul>
<li>
<p>本地版本控制系统</p>
<ul>
<li>采用某种简单的数据库来记录文件的历次更新差异。<br>
<br></li>
</ul>
</li>
<li>
<p>集中式版本控制系统（协同工作，如SVN）</p>
<ul>
<li>使用单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人都通过客户端连到这台服务器，取出最新的文件或者提交更新。（缺点：容易单点故障、受网络影响大）<br>
<br></li>
</ul>
</li>
<li>
<p>分布式版本控制系统(Git)</p>
<ul>
<li>客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。</li>
<li>协同工作时，每个客户端都是完整的版本库。（缺点：每个客户端拥有全部的代码，有安全隐患。）<br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Hexo</strong></p>
<ul>
<li>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章。<br>
<br></p>
</li>
<li>
<p><a href="https://hexo.io/zh-cn/docs/" rel="external nofollow noreferrer">Hexo中文文档</a><br>
<br></p>
</li>
</ul>
</li>
<li>
<p>Hexo 和 Typecho 的区别（扩展）</p>
<ul>
<li>“静态和动态”：主要是指其对数据处理的方式
<ul>
<li>Typecho：通过数据库来动态的查询、调用、展示的叫“动态”，</li>
<li>Hexo：直接生成纯.html网页文件来供浏览的叫“静态”</li>
</ul>
</li>
<li>Hexo
<ul>
<li>基于Node.js，不过多的依赖于常见的 LNMP 生产环境，只需要一个域名和一个免费托管平台。</li>
</ul>
</li>
<li>Typecho
<ul>
<li>比Hexo成熟，但是域名、服务器，后台等都需要自己管理。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-工具安装"><a class="header-anchor" href="#1-工具安装">#</a>1. 工具安装</h4>
<ol>
<li>
<p><a href="https://nodejs.org/en/" rel="external nofollow noreferrer">安装Node.Js</a></p>
<ul>
<li>以<strong>管理员模式</strong>打开命令提示符</li>
<li>检查Node.Js安装：<code>node -v</code></li>
<li>查看Node.Js安装路径：<code>where node</code>
<ul>
<li>检查npm安装：<code>npm -v</code></li>
<li><code>npm</code>包管理工具
<ul>
<li>更改npm全局包安装路径
<ul>
<li>npm有两种安装方式
<ul>
<li>安装在当前项目路径中：<code>npm install</code>
<ul>
<li>修改全局包的安装路径
<ul>
<li>全局包的安装路径：<code>npm config set prefix &quot;E:/nodejs/npm_global&quot;</code></li>
<li>全局包的缓存路径：<code>npm config set cache &quot;E:/nodejs/npm_cache&quot;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>全局安装：<code>npm install -g</code>（推荐）
<ul>
<li>全局路径一般默认在：C:\Users\计算机名\AppData\Roaming\npm</li>
</ul>
</li>
<li>查看是否配置成功：<code>npm config ls -l</code></li>
</ul>
</li>
<li>更换淘宝镜像源：<code>npm config set registry http://registry.npmmirror.com/</code></li>
<li>检查是否更换成功：<code>npm config get registry</code></li>
<li>添加环境变量
<ul>
<li>新建变量名NODE_PATH， 值为上述添加的npm_global路径下(如：      E:\nodejs\npm_global\node_modules)</li>
<li>将E:\nodejs\npm_global添加到path变量中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>补充：解决Git bash找不到Hexo环境解决方法，
<ul>
<li>检查 Node.js 和 npm 是否已安装：<code>node -v</code>和<code>npm -v</code></li>
<li>Hexo 的路径在环境变量中：
<ul>
<li>控制面板” → “系统和安全” → “系统” → “高级系统设置”。点击“环境变量”。通常是:<code>&lt;blog_folder&gt;/node_modules/.bin</code><br>
<br></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://git-scm.com/downloads" rel="external nofollow noreferrer">安装Git</a></p>
<ul>
<li>检查Git安装: <code>git --version</code></li>
<li>配置全局用户名和邮箱：
<ul>
<li><code>git config --global user.name “github’s Name”</code></li>
<li><code>git config --global user.email “github@xx.com”</code></li>
<li><code>git config --list</code> //然后查看自己的配置<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>安装Hexo</p>
<ul>
<li><code>npm install hexo-cli -g</code></li>
<li>检查安装：<code>hexo -v</code><br>
<br></li>
</ul>
</li>
<li>
<p><a href="https://github.com/" rel="external nofollow noreferrer">注册GitHub账户</a></p>
</li>
</ol>
<hr>
<h4 id="2-搭建仓库并生成SSH-Key"><a class="header-anchor" href="#2-搭建仓库并生成SSH-Key">#</a>2. 搭建仓库并生成SSH Key</h4>
<ol>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/28321740" rel="external nofollow noreferrer">搭建博客仓库</a></p>
<ul>
<li>username.github.io仓库就是GitHub为个人账户分配站点仓库。<br>
<br></li>
</ul>
</li>
<li>
<p>将博客部署在项目站点</p>
<ul>
<li>新建一个公开的username.github.io仓库（站点主页：导航）</li>
<li>新建一个私人的pages仓库（博客的写作站点：备份）<br>
<br></li>
</ul>
</li>
<li>
<p>生成SSH Key</p>
<ul>
<li><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></li>
<li>复制公钥（路径<code>C:\Users\UserName\.ssh\id_rsa.pub</code>）到添加到GitHub账户</li>
<li>测试SSH连接
<ul>
<li><code>ssh -T git@github.com</code><br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p>扩展（可选）</p>
<ul>
<li>
<p>For 同时也使用 Git 管理站点目录</p>
<ul>
<li>如果同时使用Git管理站点目录，应当注意部署分支应当不同于写作分支。(Hexo每次部署会<strong>完全覆盖</strong>该分支下的内容)</li>
<li>一个好的实践是：将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，也就是使用Github Actions<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="CI/CD 平台指的是持续集成（Continuous Integration）和持续交付/部署（Continuous Delivery/Deployment）的工具和服务，旨在自动化软件开发过程。CI 通过频繁集成代码，确保代码在共享环境中正常工作，而 CD 则自动化将软件交付到生产环境的过程，提升发布频率和软件质量。常见的 CI/CD 平台有 Jenkins、GitLab CI、CircleCI 和 Travis CI 等。
">[1]</span></a></sup> ，然后手动提交并推送你的写作分支，这样就可以有效避免相互覆盖。<br>
<br></li>
</ul>
</li>
<li>
<p>关于域名到期谷歌浏览器自动重定向旧域名：</p>
<ul>
<li>浏览器输入<code>chrome://history/</code>，删除全部数据。</li>
</ul>
</li>
<li>
<p>可以放弃使用SSH，转而使用令牌</p>
<ul>
<li>新建令牌注意保存密码，密码只会显示一次。</li>
<li>远程部署时再输入用户名和密码。<br>
<br></li>
</ul>
</li>
<li>
<p>使用SSH私钥密码（可以保护 SSH 密钥并配置身份验证代理）</p>
<ul>
<li><code>ssh-keygen -p -f ~/.ssh/id_rsa</code><br>
<br></li>
</ul>
</li>
<li>
<p>在Git for Windows上自动启动ssh-agent</p>
<ul>
<li><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/working-with-ssh-key-passphrases#auto-launching-ssh-agent-on-git-for-windows" rel="external nofollow noreferrer">参考Github文档</a></li>
<li>需要提示的是<code>.profile</code>文件在Git安装目录的/etc/下。<br>
<br></li>
</ul>
</li>
<li>
<p>关于使用443端口代替22端口进行ssh连接github</p>
<ul>
<li>解决使用代理无法连接22端口</li>
<li><code>C:\Users\Your_user_name\.ssh</code>创建Config文件, 内容如下：</li>
</ul>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line"><span class="string">User</span> <span class="string">you_github_email@xxx.com</span></span><br><span class="line"><span class="string">Hostname</span> <span class="string">ssh.github.com</span></span><br><span class="line"><span class="string">PreferredAuthentications</span> <span class="string">publickey</span></span><br><span class="line"><span class="string">IdentityFile</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">Port</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-初始化本地博客内容"><a class="header-anchor" href="#3-初始化本地博客内容">#</a>3. 初始化本地博客内容</h4>
<ul>
<li>
<p>新建本地博客文件夹（如：blog）<br>
<br></p>
</li>
<li>
<p>初始化Hexo到本地文件夹： <code>hexo init</code></p>
<ul>
<li>
<p>这个命令做了两步：</p>
<ul>
<li>
<p>Git clone <a href="https://github.com/hexojs/hexo-starter" rel="external nofollow noreferrer">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape" rel="external nofollow noreferrer">hexo-theme-landscape</a> 主题到当前目录或指定目录。</p>
</li>
<li>
<p>使用 <a href="https://classic.yarnpkg.com/lang/en/" rel="external nofollow noreferrer">Yarn 1</a>、<a href="https://pnpm.js.org/" rel="external nofollow noreferrer">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install" rel="external nofollow noreferrer">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。<br>
<br></p>
</li>
</ul>
</li>
<li>
<p>安装Next主题</p>
<ul>
<li>通过git指令下载NexT最新的主题文件：<code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></li>
<li>修改本地博客下文件夹下的_config.yml文件</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"><span class="attr">theme_config:</span> </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p>生成本地服务器下的hexo 静态文件：<code>hexo server</code><br>
<br></p>
</li>
<li>
<p>访问本地博客：<a href="http://localhost:4000" rel="external nofollow noreferrer">http://localhost:4000</a></p>
<ul>
<li>更改本地服务器端口号：·<code>hexo server -p 5000</code> 或者 _config.yml中添加下面代码：<br>
<br></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="4-部署博客到GitHub"><a class="header-anchor" href="#4-部署博客到GitHub">#</a>4. 部署博客到GitHub</h4>
<ul>
<li>
<p>基于SSH或者token连接GitHub</p>
</li>
<li>
<p>修改本地博客下文件夹下的_config.yml文件<br>
<br></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 设置站点URL及根目录</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://username.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/Folder/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 设置部署源（注意仓库地址的选择）</span></span><br><span class="line"><span class="comment"># 基于SSH就使用SSH克隆地址 / 基于token就使用HTTP克隆地址</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">git@github.com:username</span> <span class="string">或</span> <span class="string">username.github.io.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<ul>
<li>安装一键部署工具hexo-deployer-git：<code>npm install hexo-deployer-git --save</code></li>
<li>生成完毕后自动部署到网站：<code>hexo clean &amp;&amp; hexo deploy</code></li>
<li>访问博客：<code>https://username.github.io</code></li>
</ul>
<hr>
<h5 id="5-致谢"><a class="header-anchor" href="#5-致谢">#</a>5. 致谢</h5>
<ul>
<li>
<p><a href="https://blog.mikelyou.com/2020/07/22/github-pages-project-sites/" rel="external nofollow noreferrer">如何拥有多个GitHub Pages</a><br>
<br></p>
</li>
<li>
<p><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/working-with-ssh-key-passphrases#auto-launching-ssh-agent-on-git-for-windows" rel="external nofollow noreferrer">使用SSH密钥密码</a></p>
</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">CI/CD 平台指的是持续集成（Continuous Integration）和持续交付/部署（Continuous Delivery/Deployment）的工具和服务，旨在自动化软件开发过程。CI 通过频繁集成代码，确保代码在共享环境中正常工作，而 CD 则自动化将软件交付到生产环境的过程，提升发布频率和软件质量。常见的 CI/CD 平台有 Jenkins、GitLab CI、CircleCI 和 Travis CI 等。<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建指南</title>
    <url>/Blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>基于 <strong>Hexo</strong> 和 <strong>GitHub Pages</strong> 博客搭建指南，并使用 <strong>Git</strong> 进行版本控制。</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a>
<ul>
<li><a href="#github-pages-%E5%92%8C-hexo--%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B">GitHub Pages 和 Hexo &amp; 原理简介</a>
<ul>
<li><a href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">1. 环境搭建</a></li>
<li><a href="#2-%E7%86%9F%E6%82%89%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">2. 熟悉常用操作</a></li>
<li><a href="#3-%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96">3. 博客优化</a></li>
<li><a href="#4-%E6%89%A9%E5%B1%95%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E7%AB%99%E7%82%B9">4. 扩展其他项目站点</a></li>
<li><a href="#5-%E5%90%8E%E7%BB%AD%E6%9B%B4%E6%96%B0">5. 后续更新</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h2>
<ul>
<li>
<p>最近一直感觉自己已经被<strong>异化</strong>的得很严重了，<strong>学习</strong>本来应该是基于环境和自身需要的<strong>自发行为</strong>，但是如今却一直让我感觉很痛苦。<br>
<br></p>
</li>
<li>
<p>人与动物的最大区别是：人的学习依靠一种<strong>象征体系</strong>(主动)，而不是一套新的<strong>生理反应</strong>（被动）。<br>
<br></p>
</li>
<li>
<p>人固然需要<strong>正反馈</strong>满足情绪的需要，这是学习一切开始的动力<strong>基础</strong>，然后更重要的是由此建立一套<strong>自律系统</strong>（我倾向于称之为<strong>情绪管理系统</strong>，也可以叫<strong>行为控制系统</strong>）<br>
<br></p>
</li>
<li>
<p>人不可能学完所有知识，也不可能一次学好所有知识，之前的学习行为消耗了太多热情，这也是写博客的<strong>初衷</strong>。</p>
</li>
</ul>
<hr>
<h3 id="GitHub-Pages-和-Hexo-原理简介"><a class="header-anchor" href="#GitHub-Pages-和-Hexo-原理简介">#</a>GitHub Pages 和 Hexo &amp; 原理简介</h3>
<ul>
<li>
<p><strong>GitHub Pages</strong></p>
<ul>
<li>
<p>关于GitHub Pages</p>
<ul>
<li><a href="https://docs.github.com/cn/pages/getting-started-with-github-pages/about-github-pages" rel="external nofollow noreferrer">GitHub Pages</a>是一项静态站点托管服务，它直接从 GitHub 上的<strong>仓库</strong>获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，让我们可以在 GitHub 仓库里托管和发布自己的<strong>网站</strong>。<br>
<br></li>
</ul>
</li>
<li>
<p>域名和GitHub Pages</p>
<ul>
<li>
<p>GitHub Pages</p>
<ul>
<li>GitHub 只为每个帐户创建一个用户或组织站点（也就是<code>username|organization.github.io</code>，需先创建仓库<code>username.github.io</code>）；但是账户的项目站点可以有多个（也就是子路径可以有多个，如：<code>username|organization.github.io</code>）<br>
<br></li>
</ul>
</li>
<li>
<p>自定义域名</p>
<ul>
<li>
<p>GitHub Pages支持自定义域, 可以去域名商 <a href="https://www.godaddy.com/" rel="external nofollow noreferrer">GoDaddy</a>或<a href="https://www.namesilo.com/" rel="external nofollow noreferrer">Namesilo</a>购买。<br>
<br></p>
</li>
<li>
<p>购买的域名只是一个网址，由DNS服务器（需要去DNS服务商注册DNS服务）与 GitHub Pages关联（也就是站点<code>username.github.io</code>）<br>
<br></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Hexo</strong></p>
<ul>
<li>
<p>关于Hexo</p>
<ul>
<li>Hexo是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将 Markdown（或其他渲染引擎）文档解析渲染成静态的 HTML 网页。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>Next主题</strong></p>
<ul>
<li>Next是Hexo项目下的一个主题模板，提供可高度定制的页面外观。<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Hexo + GitHub 发布文章原理</strong></p>
<ul>
<li>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 的仓库上，再由 GitHub 获取仓库的文件发布到站点。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-环境搭建"><a class="header-anchor" href="#1-环境搭建">#</a>1. 环境搭建</h4>
<ul>
<li>
<p><strong>技术选择</strong></p>
<ul>
<li>使用Hexo + GitHub</li>
<li>使用Next作为Hexo主题</li>
<li>使用GitHub Pages托管和发布网站</li>
<li>使用Git进行版本控制[可选]<br>
<br></li>
</ul>
</li>
<li>
<p><strong>具体步骤</strong></p>
<ul>
<li><a href="./%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">环境搭建</a></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-熟悉常用操作"><a class="header-anchor" href="#2-熟悉常用操作">#</a>2. 熟悉常用操作</h4>
<ul>
<li>
<p><strong>目标</strong></p>
<ul>
<li>熟悉Hexo配置和使用</li>
<li>熟悉Next主题相关配置和插件</li>
<li>熟悉Git基础操作</li>
<li>掌握Hexo常用操作<br>
<br></li>
</ul>
</li>
<li>
<p><strong>具体流程</strong></p>
<ul>
<li><a href="./Hexo%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.md">Hexo 常用操作</a><br>
<br></li>
<li><a href="./%E5%85%B3%E4%BA%8E%20Git%20%E7%9A%84%E4%BD%BF%E7%94%A8.md">关于 Git 的使用</a></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-博客优化"><a class="header-anchor" href="#3-博客优化">#</a>3. 博客优化</h4>
<ul>
<li>
<p><strong>背景</strong></p>
<ul>
<li>确认任务的可执行性</li>
<li>权衡价值判断和具体用途</li>
<li>根据布局和内容确定优化部分</li>
<li>逐步优化已确定设计和内容</li>
<li>将难以实现内容摒弃或加入待完成计划<br>
<br></li>
</ul>
</li>
<li>
<p><strong>模板优化</strong></p>
<ul>
<li>界面美化</li>
<li>彩色标签</li>
<li>自定义404页面</li>
<li>菜单栏站点地图</li>
<li>侧边栏RSS</li>
<li>Hexo 插件
<ul>
<li>文章单词统计（wordcount）</li>
<li>本地搜索（Local Search）</li>
<li>评论系统</li>
<li>图片预览</li>
<li>脚注</li>
<li>更换Markdown渲染引擎</li>
</ul>
</li>
<li>绑定自定义域名（<strong>可选</strong>）<br>
<br></li>
</ul>
</li>
<li>
<p><strong>性能优化</strong></p>
<ul>
<li>SEO 优化（网站推广）
<ul>
<li>让搜索引擎收录你的站点</li>
<li>优化description、keyword和title</li>
<li>优化站点的URL</li>
<li>优化相关链接，外链自动添加nofollow</li>
<li>丰富站点内容</li>
<li>关于使用子域名还是子目录</li>
</ul>
</li>
<li>网站预加载JS脚本</li>
<li>文章压缩插件</li>
<li>优化图片加载
<ul>
<li>图片无损压缩</li>
</ul>
</li>
<li>图床工具
<ul>
<li>jsDelivr + GitHub + PicGo<br>
<br></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>自定义使用 swig 模板</strong></p>
<ul>
<li>默认情况下 Markdown 文件中的 Front-matter 中指定<code>layout: &quot;books&quot;</code>时，意味着 hexo 会根据该文件的路由寻找文件名为books的swig模板文件（即books.swig）来渲染该Markdown文件。</li>
</ul>
</li>
<li>
<p><strong>具体流程</strong></p>
<ul>
<li><a href="./%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96.md">界面优化</a></li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-扩展其他项目站点"><a class="header-anchor" href="#4-扩展其他项目站点">#</a>4. 扩展其他项目站点</h4>
<ul>
<li>
<p><strong>主页</strong></p>
<ul>
<li>使用 VuePress + Github Pages 搭建主页站点，主要做内容聚合。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>代理工具</strong></p>
<ul>
<li>主要使用 <a href="https://github.com/shadowsocks/shadowsocks/blob/master/README.md" rel="external nofollow noreferrer">Shadowsocks</a> 搭建。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>AI工具</strong></p>
<ul>
<li>暂定。<br>
<br></li>
</ul>
</li>
<li>
<p><strong>游戏</strong></p>
<ul>
<li>使用 Mkdocs 生成文档。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-后续更新"><a class="header-anchor" href="#5-后续更新">#</a>5. 后续更新</h4>
<ul>
<li><strong>更换图床</strong>
<ul>
<li>Github 作为一个代码托管平台，用来托管图片并不是很道德，但是我们又不希望购买服务器来搭建图床。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>Git</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>消息来源</title>
    <url>/Blog/%E6%B6%88%E6%81%AF%E6%9D%A5%E6%BA%90/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li><strong>消息来源</strong>：用于向用户提供频繁更新的内容的数据格式（如：新闻订阅，网源等），网站可透过它将最新信息传递给用户。<br>
<br></li>
</ul>
<span id="more"></span>
<hr>
<h3 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h3>
<ul>
<li>
<p><strong>消息来源</strong>（web feed、news feed、syndicated feed）是一种资料格式，网站可透过它将最新信息传播给用户，用户能够订阅网站的先决条件<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="在计算机编程中，先决条件或先验条件指在执行一段代码前必须成立的条件。
">[1]</span></a></sup>是网站可提供持续更新的信息。<br>
<br></p>
</li>
<li>
<p><strong>RSS</strong>：是一系列网络订阅源格式，也是一种内容聚合的工具，有RSS 和 Aotm 两种协议，XML<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言。XML是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。
">[4]</span></a></sup>为基础协议。<br>
<br></p>
</li>
<li>
<p><strong>Aotm</strong>（标准）：用于网络源的可扩展标记语言，借鉴了RSS的经验。<br>
<br></p>
</li>
</ul>
<hr>
<h3 id="关于消息来源"><a class="header-anchor" href="#关于消息来源">#</a>关于消息来源</h3>
<ul>
<li>
<p>常用的feed格式有RSS、Atom两种。由于RSS是较早通行的格式，一些网站虽然提供了两种格式，但只称为RSS。feed传播给用户的内容种类通常是HTML（网页内容）或通往网页的链接。<br>
<br></p>
</li>
<li>
<p>将feed汇流于一处称为聚合（aggregation），而用于聚合的软件称为聚合器（aggregator）。对最终用户而言，聚合器是专门用来订阅网站的软件，一般亦称为RSS阅读器、feed阅读器、新闻阅读器等。<br>
<br></p>
</li>
<li>
<p>网站feed虽然看似将内容推送给用户，但事实上它采用的是拉取技术（pull technology），这点不同于电子邮件则是客户端与邮件服务器进行交互。<br>
<br></p>
</li>
<li>
<p>除了网页之外，feed内容也可以是通往其他数字多媒体的链接。供用户订阅的内容若是音频或视频等多媒体信息，则称为播客（podcast）（如：在线电台）。<br>
<br></p>
</li>
</ul>
<hr>
<h4 id="RSS简述"><a class="header-anchor" href="#RSS简述">#</a>RSS简述</h4>
<ul>
<li>
<p>RSS（英文全称：RDF Site Summary<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="“资源描述框架站点摘要”（RDF Site Summary）即 RSS 的英文原意。
">[2]</span></a></sup> 或 Really Simple Syndication<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="后来通过逆向首字母缩略词变更为“Really Simple Syndication”（简易信息聚合）。
">[3]</span></a></sup>），中文译作<strong>简易信息聚合</strong>，也称<strong>聚合内容</strong>，是一种<strong>消息来源</strong>格式规范，用以聚合多个网站更新的内容并自动通知网站订阅者。<br>
<br></p>
</li>
<li>
<p>使用 RSS 后，网站订阅者便无需再手动查看网站是否有新的内容，同时 RSS 可将多个网站更新的内容进行整合，以摘要的形式呈现，有助于订阅者快速获取重要信息，并选择性地点阅查看。<br>
<br></p>
</li>
<li>
<p>RSS 模块的主要目标是延伸基本的 XML<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言。XML是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。
">[4]</span></a></sup> 概要来获得更健全的内容汇集。此种传承允许更多的变化却又能够符合标准，在不用更改 RSS 核心之下执行。为了达成此项延伸，严密规范的字汇（在 RSS 中为“模块”；XML 中为“概要”）通过 XML namesspace 命名各种概念之中的概念。<br>
<br></p>
</li>
</ul>
<hr>
<h4 id="Atom简述"><a class="header-anchor" href="#Atom简述">#</a>Atom简述</h4>
<ul>
<li>
<p>Atom是一对彼此相关的标准。Atom供稿格式（Atom Syndication Format）是用于网站消息来源，基于XML的文档格式；而Atom出版协定（Atom Publishing Protocol，简称AtomPub或APP）是用于新增及修改网络资源，基于HTTP的协议。<br>
<br></p>
</li>
<li>
<p>Atom借鉴了各种版本RSS的使用经验，被许多的聚合工具广泛使用在发布和使用上。Atom供稿格式设计作为RSS的替代品；而Atom出版协定用来取代现有的多种发布方式（如Blogger API和LiveJournal XML-RPC Client/Server Protocol）。Google提供的多种服务正在使用Atom。Google Data API（GData）亦基于Atom。<br>
<br></p>
</li>
<li>
<p>Atom是<a href="https://zh.m.wikipedia.org/wiki/IETF" rel="external nofollow noreferrer">IETF</a>的“建议标准”，Atom供稿格式列为<a href="http://tools.ietf.org/html/rfc4287" rel="external nofollow noreferrer">RFC 4287</a></p>
</li>
</ul>
<h4 id="聚合器"><a class="header-anchor" href="#聚合器">#</a>聚合器</h4>
<ul>
<li>
<p>RSS阅读器会将不同订阅源整合并定期检阅网站是否有更新，然后下载至监看用户界面。<br>
<br></p>
</li>
<li>
<p>自用RSS阅读器</p>
<ul>
<li>Windows
<ul>
<li><a href="https://github.com/yang991178/fluent-reader/releases" rel="external nofollow noreferrer">Fluent Reader</a></li>
</ul>
</li>
<li>Android
<ul>
<li><a href="https://github.com/LeetaoGoooo/RSSAid/releases" rel="external nofollow noreferrer">RSSAid</a></li>
<li><a href="https://github.com/yang991178/fluent-reader-lite/releases" rel="external nofollow noreferrer">Fluent Reader</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="RSS和平台的内容聚合区别"><a class="header-anchor" href="#RSS和平台的内容聚合区别">#</a>RSS和平台的内容聚合区别</h4>
<ul>
<li>
<p><strong>从内容聚合的对象角度看</strong></p>
<ul>
<li>
<p>RSS的内容聚合：聚合的是每个订阅源的作者希望传达的所有信息，不受平台监管和推荐权重的影响，也不受信息分类的影响（信息之间可以很方便的关联），每条订阅源信息的使用由读者自行选择和使用。可以说每个RSS的订阅源的背后都是一个活生生存在的人，不倾向于搞学科化的人为割裂。<br>
<br></p>
</li>
<li>
<p>平台的内容聚合：聚合的是特定主题（topic）的内容，通过人为的将信息分类，再将信息人为聚合的方式，信息之间关联性弱，并且信息易受推荐算法、人为监管、环境范围等方式的影响，信息的传递过程定向且可控。可以说平台的订阅源背后都是人为操纵的信息，信息<strong>极易出现</strong>片面性、倾向性、不真实性。<br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>从信息的流动性角度看</strong></p>
<ul>
<li>
<p>RSS的内容聚合：信息在作者和读者之间单向流动，缺少及时沟通的桥梁。</p>
</li>
<li>
<p>平台的内容聚合：信息在作者和读者之间双向流动，信息能快速和频繁的流动。<br>
<br></p>
</li>
</ul>
</li>
<li>
<p><strong>从实用范围的的角度看</strong></p>
<ul>
<li>
<p>RSS的内容聚合：适合真实的、客观的和流动性不强内容。</p>
</li>
<li>
<p>平台的内容聚合：适合虚拟的、情绪化的和流动性强的内容。<br>
<br></p>
</li>
</ul>
</li>
<li>
<p>总结</p>
<ul>
<li>虽然RSS让创作者和读者之间缺乏沟通的桥梁，但是却能绕过平台的推荐机制，能有效避免接受的信息同质化，导致自身视野受限。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="RSS源"><a class="header-anchor" href="#RSS源">#</a>RSS源</h4>
<ul>
<li>
<p>公共RSS源</p>
<ul>
<li><a href="http://rss.mk/RSS" rel="external nofollow noreferrer">公共 RSS 订阅源</a></li>
<li><a href="https://rss-source.com/" rel="external nofollow noreferrer">订阅源推荐</a></li>
<li><a href="https://getpodcast.xyz/" rel="external nofollow noreferrer">播客 Feed 订阅</a></li>
<li><a href="https://trello.com/b/lvMGhlNB/" rel="external nofollow noreferrer">RSS源共享</a></li>
<li><a href="https://rss.mifaw.com/" rel="external nofollow noreferrer">RSS屋</a></li>
<li><a href="https://blackwinmin.github.io/posts/law_rss/" rel="external nofollow noreferrer">一些法律相关信息的 RSS 订阅地址</a></li>
<li><a href="https://github.com/zhengjim/Chinese-Security-RSS/" rel="external nofollow noreferrer">国内安全资讯</a></li>
<li><a href="https://github.com/Gracker/Rss-IT" rel="external nofollow noreferrer">一些科技人的 Blog 地址</a></li>
<li><a href="https://shimo.im/docs/iwRFK7VNmZIxnuL7/" rel="external nofollow noreferrer">A君私藏的超好用 RSS 订阅源</a><br>
<br></li>
</ul>
</li>
<li>
<p>利用<a href="https://docs.rsshub.app/" rel="external nofollow noreferrer">RSSHub</a>生成源</p>
<ul>
<li>解决 RSSHub 域名问题（被墙了）
<ul>
<li><a href="https://uneasy.win/rsshubserver/" rel="external nofollow noreferrer">其他自建RSSHub</a></li>
<li>搜索其他自建RSSHub（Welcome to RSSHub!）</li>
</ul>
</li>
<li><a href="https://docs.qq.com/doc/DYWhCdURBTFBEVGFl" rel="external nofollow noreferrer">用Github+Vercel来一键部署RSSHub</a><br>
<br></li>
</ul>
</li>
<li>
<p><a href="https://github.com/DIYgod/RSSHub-Radar/" rel="external nofollow noreferrer">RSSHub Rader</a></p>
<ul>
<li>RSSHub Radar 是 RSSHub 的衍生项目，是一个可以帮助你快速发现和订阅当前网站 RSS 和 RSSHub 的浏览器扩展</li>
<li>在进入一个新页面时，RSSHub Radar 会自动检测当前页面有没有 RSS 和 RSSHub 支持，检测到则会在右下角显示一个角标，点击就能复制 RSS 源了</li>
<li><a href="https://greasyfork.org/zh-CN/scripts/373252" rel="external nofollow noreferrer">RSS+脚本补充显示所有网站RSS</a></li>
</ul>
</li>
</ul>
<hr>
<h4 id="致谢"><a class="header-anchor" href="#致谢">#</a>致谢</h4>
<ul>
<li>
<p><a href="https://www.zhihu.com/question/28808592/answer/42374627" rel="external nofollow noreferrer">RSS阅读器</a><br>
<br></p>
</li>
<li>
<p><a href="https://zh.m.wikipedia.org/wiki/RSS" rel="external nofollow noreferrer">RSS-维基百科</a><br>
<br></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/349349861" rel="external nofollow noreferrer">知道RSS的人越少，我就越希望它能被人知道！</a><br>
<br></p>
</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">在计算机编程中，先决条件或先验条件指在执行一段代码前必须成立的条件。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">“资源描述框架站点摘要”（RDF Site Summary）即 RSS 的英文原意。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">后来通过逆向首字母缩略词变更为“Really Simple Syndication”（简易信息聚合）。<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言。XML是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。<a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>RSS</tag>
        <tag>Aotm</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用教程</title>
    <url>/Tools/Markdown%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul>
<li>关于Markdown常用语法的使用的梳理，主要是方便自己总结和回顾使用，也可以自行通过<a href="https://markdown.com.cn/" rel="external nofollow noreferrer">Markdown官网</a>来学习。</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li><a href="#markdown%E7%AE%80%E4%BB%8B">Markdown简介</a>
<ul>
<li><a href="#markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">Markdown基础语法</a>
<ul>
<li><a href="#%E6%A0%87%E9%A2%98">标题</a></li>
<li><a href="#%E6%AE%B5%E8%90%BD">段落</a></li>
<li><a href="#%E6%8D%A2%E8%A1%8C">换行</a></li>
<li><a href="#%E5%BC%BA%E8%B0%83%E8%AF%AD%E6%B3%95">强调语法</a></li>
<li><a href="#%E5%9D%97%E5%BC%95%E7%94%A8">块引用</a></li>
<li><a href="#%E6%9C%89%E5%BA%8F%E5%92%8C%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">有序和无序列表</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
<li><a href="#%E5%88%86%E5%89%B2%E7%BA%BF">分割线</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li>
<li><a href="#%E5%9B%BE%E7%89%87">图片</a></li>
<li><a href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%8F%8D%E6%96%9C%E6%9D%A0">转义字符反斜杠</a></li>
<li><a href="#%E5%86%85%E5%B5%8Chtml%E6%A0%87%E7%AD%BE">内嵌HTML标签</a></li>
</ul>
</li>
<li><a href="#markdown%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">Markdown扩展语法</a>
<ul>
<li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li>
<li><a href="#%E5%9B%B4%E6%A0%8F%E4%BB%A3%E7%A0%81%E5%9D%97">围栏代码块</a></li>
<li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li>
<li><a href="#%E6%A0%87%E9%A2%98%E7%BC%96%E5%8F%B7">标题编号</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8">定义列表</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E7%BA%BF">删除线</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8">任务列表</a></li>
<li><a href="#emoji%E8%A1%A8%E6%83%85">Emoji表情</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E7%BD%91%E5%9D%80%E9%93%BE%E6%8E%A5">自动网址链接</a></li>
<li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF">下划线</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6">链接本地文件</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95">生成目录</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E7%9B%AE%E5%BD%95">返回目录</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Markdown简介"><a class="header-anchor" href="#Markdown简介">#</a>Markdown简介</h3>
<ol>
<li>
<p>Markdown 的简述</p>
<ul>
<li>
<p>Markdown 是一种轻量级的<strong>标记语言</strong><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="标记语言: 是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码
">[1]</span></a></sup>，可用于在纯文本文档中添加格式化元素。<br>
<br></p>
</li>
<li>
<p>Markdown 的<strong>语法</strong>被设计为<strong>可读性强</strong>且不显眼，因此即使 Markdown 文件中的文本未经过渲染也易于阅读。<br>
<br></p>
</li>
<li>
<p>Markdown 优点</p>
<ol>
<li><strong>专注于文字</strong>内容；</li>
<li><strong>纯文本，易读易写</strong>，可以方便地纳入版本控制；</li>
<li><strong>语法简单</strong>，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。<br>
<br></li>
</ol>
</li>
</ul>
</li>
<li>
<p>使用 Markdown 原因</p>
<ul>
<li>Markdown 的语法是可读性强且不显眼的</li>
<li>Markdown 是纯文本可移植的</li>
<li>Markdown 是独立于平台的</li>
<li>Markdown 能适应未来的变化<br>
<br></li>
</ul>
</li>
<li>
<p>Markdown 的工作原理</p>
<ul>
<li>Markdown 应用程序使用一种称为 Markdown 处理器（也通常称为“解析器”或“实现”）的东西将获取到的 <strong>Markdown 格式</strong>的文本输出为 <strong>HTML 格式</strong></li>
<li><strong>注意</strong>： Markdown 应用程序和处理器是两个单独的组件（解析，渲染）。<br>
<br></li>
</ul>
</li>
<li>
<p>Markdown 的用途</p>
<ul>
<li>做笔记、为网站创建内容以及生成可打印文档的快速、简便的方法（书籍、网站、文档、笔记等）<br>
<br></li>
</ul>
</li>
<li>
<p>Markdown 的其它资源</p>
<ul>
<li><a href="https://daringfireball.net/projects/markdown/" rel="external nofollow noreferrer">John Gruber’s Markdown documentation</a>. Markdown 的创建者编写的原始指南。</li>
<li><a href="https://www.markdowntutorial.com/" rel="external nofollow noreferrer">Markdown Tutorial</a>. 一个开源网站，你能用浏览器在这个网站上尝试 Markdown。</li>
<li><a href="https://github.com/mundimark/awesome-markdown" rel="external nofollow noreferrer">Awesome Markdown</a>. Markdown 工具和学习资源列表。</li>
<li><a href="https://dave.autonoma.ca/blog/2019/05/22/typesetting-markdown-part-1" rel="external nofollow noreferrer">Typesetting Markdown</a>. 这是一个系列教程，介绍了使用 pandoc 和 ConTeXt 对 Markdown 文档进行排版的系统。<br>
<br></li>
</ul>
</li>
<li>
<p>推荐的关于Markdown的VSCode插件</p>
<ul>
<li>全面解析Markdown的VSCode插件，包含很多功能
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one" rel="external nofollow noreferrer">markdown-all-in-one</a></li>
</ul>
</li>
<li>将Markdown文档解析为思维导图的VSCode插件
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=gera2ld.markmap-vscode" rel="external nofollow noreferrer">markmap</a></li>
</ul>
</li>
<li>Markdown文档规范插件
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint" rel="external nofollow noreferrer">markdownlint</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="Markdown基础语法"><a class="header-anchor" href="#Markdown基础语法">#</a>Markdown基础语法</h4>
<h5 id="标题"><a class="header-anchor" href="#标题">#</a>标题</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>为了兼容考虑，请用一个空格在 # 和标题之间进行分隔。

# Heading level 1
## Heading level 2
### Heading level 3
#### Heading level 4
##### Heading level 5
###### Heading level 6

可选语法：

Heading level 1 
==============
Heading level 2
--------------  
</code></pre>
<hr>
<h5 id="段落"><a class="header-anchor" href="#段落">#</a>段落</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>不要用空格（spaces）或制表符（ tabs）缩进段落。

使用一个空白行来表示重新开始一个段落。
</code></pre>
<hr>
<h5 id="换行"><a class="header-anchor" href="#换行">#</a>换行</h5>
<blockquote>
<p>两种用法如下：</p>
</blockquote>
<pre><code>1. 使用两个或两个以上空格（spaces）加上回车（return）。

2. 使用html语法`&lt;br&gt;`（通用）
</code></pre>
<hr>
<h5 id="强调语法"><a class="header-anchor" href="#强调语法">#</a>强调语法</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>由于Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致，为了兼容性，应优先使用*

*斜体文本*  

**粗体文本**  

***粗斜体文本***  

_斜体文本_  

__粗体文本__  

___粗斜体文本___ 
</code></pre>
<hr>
<h5 id="块引用"><a class="header-anchor" href="#块引用">#</a>块引用</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>块引用: 
在段落开头使用 &gt; 符号, 后面紧跟一个空格。

多个段落的块引用：
为段落之间的空白行添加一个 &gt; 符号。

嵌套块引用: 
&gt; &gt; 加上空格代表二级嵌套, 依此类推。  

块引用中使用其它元素：
1. 块引用中使用列表: 先使用区块，再使用列表。  
2. 列表中的块引用: 在`&gt;`前面缩进四个空格或者一个制表符(Tab键)。
3. 块引用中使用粗体、斜体、粗斜体。

应用举例：

1.块的引用
&gt; Markdown区块

2. 多个段落的块引用
&gt; 第一段
&gt; 
&gt; 第二段

3. 块引用的嵌套
&gt; 最外层
&gt; &gt; 第一层嵌套
&gt; &gt; &gt; 第二层嵌套

4.块引用中使用列表
&gt; 区块中使用列表
&gt; 1. 第一项
&gt; 2. 第二项
&gt; 3. 第三项

&gt; - 第一项
&gt; - 第二项
&gt; - 第三项
&gt;   - 第四项

5.列表中的块引用
- 第一项
    &gt; 第一项第一个元素
    &gt; 第一项第二个元素

- 第二项
    &gt; 第二项第一个元素
    &gt; 第二项第二个元素
</code></pre>
<hr>
<h5 id="有序和无序列表"><a class="header-anchor" href="#有序和无序列表">#</a>有序和无序列表</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>有序列表：有序列表使用数字并加上 . 号来表示列表标记。数字不必按数学顺序排列，但是列表应当以数字 1 起始。

无序列表：使用星号(*),加号(+)或是破折号号(-) 作为列表标记。（每篇文章最好只使用一种符号）

列表嵌套其他元素：只需在子列表中的添加四个空格或者一个制表符(Tab键)。

列表中的代码块|图片：代码块|图片通常采用四个空格或一个制表符缩进。在列表中时应该缩进八个空格或两个制表符。（使用前后还需留有空白行）

为了兼容性，不要在同一个列表中混合和匹配分隔符 ，选择一个并坚持使用它。

1. 有序列表
    1. 第一项
    2. 第二项
    3. 第三项

2. 无序列表
    + 第一项
    + 第二项
    + 第三项

    - 第一项
    - 第二项
    - 第三项

    * 第一项
    * 第二项
    * 第三项
   
3. 列表嵌套
    1. First item
    2. Second item
    3. Third item
        1. Indented item
        2. Indented item
    4. Fourth item

    - First item
    - Second item
    - Third item
        - Indented item
        - Indented item
    - Fourth ite

    1. First item
    2. Second item
    3. Third item
        - Indented item
        - Indented item
    4. Fourth item

4. 列表中的代码块
- 第一项

        &lt;HTML&gt;
        &lt;head&gt;
        &lt;title&gt;Test&lt;/title&gt;
        &lt;/head&gt;
        &lt;/HTML&gt;

- 第二项

1. 列表中的图片
- 第一项

    ![马克思](https://bkimg.cdn.bcebos.com/pic/a8ec8a13632762d04187f99baeec08fa513dc65d?x-bce-process=image/resize,m_lfit,w_536,limit_1/format,f_jpg)

- 第二项
</code></pre>
<hr>
<h5 id="代码"><a class="header-anchor" href="#代码">#</a>代码</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>函数或代码片段：使用反引号(`)包裹起来  

转义反引号：使用双反引号(``)为代码的单词或短语中包含一个或多个反引号

代码块：缩进 4 个空格或者一个制表符(Tab 键)  

1. 函数或片段代码 
`printf()` 函数  

2. 转义反引号
``Use `code` in your Markdown file.``

3. 代码块  
制表符或者4个空格 + 文本数据。

    &lt;html&gt;
      &lt;head&gt;
      &lt;/head&gt;
    &lt;/html&gt;  
</code></pre>
<hr>
<h5 id="分割线"><a class="header-anchor" href="#分割线">#</a>分割线</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>在一行中使用：三个及以上的星号(***)、破折号(---) 、下划线 (___) 建立分割线。

或者使用HTML中的&lt;hr&gt;标签

为了兼容性，在分隔线的前后均添加空白行。

***

* * *

*****

---

- - -

------

_ _ _

___

______
</code></pre>
<hr>
<h5 id="链接"><a class="header-anchor" href="#链接">#</a>链接</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>语法：[链接名称](链接地址 &quot;超链接title&quot;)

对应的HTML代码：&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;

补充：链接title是当鼠标悬停在链接上时会出现的文字，title是可选的。

可点击的链接：使用尖括号可以很方便地把URL或者email地址变成可点击的链接。

带格式的链接： 

1. 强调链接：在链接语法前后增加星号。（双星号粗体链接，单星号斜体链接）
2. 将链接表示为代码：在方括号中添加反引号。

引用类型链接：用脚注的方式书写链接，换言之链接也可以用变量代替。（引用位置可以放在Markdown文档中的任何位置。例如：尾注或脚注）

Tips：不同的 Markdown 应用程序处理URL中间的空格方式不一样。为了兼容性，尽量使用%20代替空格 

1. 超链接
这是一个链接[谷歌](http://www.google.com)
这是一个带Title的链接[谷歌](http://www.google.com &quot;好的浏览器&quot;)

2. 可点击的链接（网址和Email地址）
&lt;http://www.google.com&gt;
&lt;fake@example.com&gt; 

3. 带格式化的链接

    强调链接：
    
    双星号：粗体
    I love supporting the **[EFF](https://eff.org)**.
    单星号：斜体
    This is the *[Markdown Guide](https://www.markdownguide.org)*.

    将链接表示为代码：
    See the section on [`https://markdown.com.cn/`](#code).

4. 引用类型链接

用变量（标签）来代替文档末尾附带变量（标签）、链接(可以选择将其括在尖括号中)和链接的可选标题（可以将其括在双引号，单引号或括号中）：

这个链接用 1 作为网址变量 [Google] [1]
这个链接用 chrome 作为网址变量 [Google] [chrome]
这个链接用 to 作为网址变量 [Google] [to]

然后在文档的结尾为变量赋值（链接）
[1]: http://www.google.com/ &quot;Google&quot;
[chrome]: http://www.google.com/ 'Google'
[to]: &lt;http://www.google.com/&gt; (Google)
</code></pre>
<hr>
<h5 id="图片"><a class="header-anchor" href="#图片">#</a>图片</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>1. 语法
![alt 属性文本](图片地址)  

![alt 属性文本](图片地址 &quot;图片的可选标题&quot;)
对应的HTML代码：&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;  

2.链接图片
将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。

[![Avatar]([/assets/img/shiprock.jpg](https://shuguang2000.github.io/blog/images/avatar.jpg) &quot;Avatar&quot;)](https://shuguang2000.github.io/blog/)

3. 给图片添加引用链接
这个链接用 1 作为网址变量 [Avatar][1].

[1]: https://shuguang2000.github.io/blog/images/avatar.jpg
</code></pre>
<hr>
<h5 id="转义字符反斜杠"><a class="header-anchor" href="#转义字符反斜杠">#</a>转义字符反斜杠</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>要显示原本用于格式化 Markdown 文档的字符，在字符前面添加反斜杠字符 \ 。

1. 实例：
**文本加粗** 
\*\* 正常显示星号 \*\*  

2. Markdown 支持使用反斜杠字符转译以下符号
\   反斜线
`   反引号
*   星号
_   下划线
&#123;&#125;  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号

3. 特殊字符自动转义

在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。

Markdown 允许你直接使用这些符号，它帮你自动转义字符。如果你使用 &amp; 符号的作为 HTML 实体的一部分(比如：“&lt;u&gt;”作为HTML标签)，那么它不会被转换，而在其它情况下（比如：“4 &lt; 5”），它则会被转换成 &amp;lt;。

Tips: 需要特别注意的是，在 Markdown 的块级元素和内联元素中， &lt; 和 &amp; 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML。（但在 HTML 语法中，你要手动把所有的 &lt; 和 &amp; 都转换为 HTML 实体。）
</code></pre>
<hr>
<h5 id="内嵌HTML标签"><a class="header-anchor" href="#内嵌HTML标签">#</a>内嵌HTML标签</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>注意: 出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。

对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。

1. 行级内联标签（内联元素也叫行内元素）
HTML 的行级内联标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt;、&lt;strong&gt; 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。

Tips：HTML 行级内联标签和区块标签不同，在内联标签的范围内， Markdown 的语法是可以解析的。

&lt;strong&gt;*word*&lt;/strong&gt;

2. 区块标签
区块元素──比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行，以便于内容区分。

而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 &lt;p&gt; 标签。

Tips：Markdown 语法在 HTML 区块标签中将不会被进行处理。

This is a regular paragraph.

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

This is another regular paragraph.
</code></pre>
<hr>
<h4 id="Markdown扩展语法"><a class="header-anchor" href="#Markdown扩展语法">#</a>Markdown扩展语法</h4>
<ul>
<li>
<p>并非所有Markdown应用程序都支持扩展语法元素。</p>
</li>
<li>
<p>轻量标记语言：有几种轻量级标记语言是Markdown的超集。</p>
<ul>
<li><a href="https://commonmark.org/" rel="external nofollow noreferrer">CommonMark</a></li>
<li><a href="https://github.github.com/gfm/" rel="external nofollow noreferrer">GitHub Flavo red Markdown (GFM)</a></li>
<li><a href="https://michelf.ca/projects/php-markdown/extra/" rel="external nofollow noreferrer">Markdown Extra</a></li>
<li><a href="https://michelf.ca/projects/php-markdown/extra/" rel="external nofollow noreferrer">MultiMarkdown</a></li>
<li><a href="https://rmarkdown.rstudio.com/" rel="external nofollow noreferrer">R Markdown</a><br>
<br></li>
</ul>
</li>
<li>
<p>Markdown 处理器：</p>
<ul>
<li>有许多<a href="https://github.com/markdown/markdown.github.com/wiki/Implementations" rel="external nofollow noreferrer">Markdown处理器</a> 可用。它们中的许多允许添加启用扩展语法元素的扩展。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="表格"><a class="header-anchor" href="#表格">#</a>表格</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>使用三个或多个连字符（---）创建每列的标题，并使用管道（|）分隔每列。

使用连字符和管道创建表可能很麻烦。为了加快该过程，请尝试使用Markdown Tables Generator &lt;https://www.tablesgenerator.com/markdown_tables&gt; 创建列表。

1. 语法
| Syntax      | Description |
| ----------- | ----------- |
| Header      | Title       |
| Paragraph   | Text        |
 
2. 单元格宽度可以变化
| Syntax | Description |
| --- | ----------- |
| Header | Title |
| Paragraph | Text |

3. 对齐
-: 设置内容和标题栏居右对齐。
:- 设置内容和标题栏居左对齐。
:-: 设置内容和标题栏居中对齐。 

| 左对齐 | 右对齐 | 居中对齐 |
| :----- | ----:  | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |

4. 格式化表格中的文字
可以在表格中设置文本格式。例如：

添加：链接，代码（仅反引号（`）中的单词或短语，而不是代码块）和强调。

不能添加：标题，块引用，列表，水平规则，图像或HTML标签。

5. 在表中转义管道字符
在表中显示竖线（|）字符：使用表格的HTML字符代码（&amp;#124;）。
</code></pre>
<hr>
<h5 id="围栏代码块"><a class="header-anchor" href="#围栏代码块">#</a>围栏代码块</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>使用三个反引号（```）或三个波浪号（~~~）包裹一段代码。

在三个反引号旁边指定一种语言即可实现语法高亮。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre>
<hr>
<h5 id="脚注"><a class="header-anchor" href="#脚注">#</a>脚注</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>[^标识符] 

[^标识符]: My footnote.

标识符可以是数字或单词，但不能包含空格或制表符。

不必在文档末尾添加脚注。可以将它们放在除列表，块引号和表之类的其他元素之外的任何位置。

应用举例：

例子1：
随机存取存储器RAM(Random Access Memory)[^sola]。

[^sola]:又称作“随机存储器”，是与CPU直接交换数据的内部存储器，也叫主存(一般指的是电脑的内存)  

例子2：
只读存储器(Read Only Memory，ROM)[^sola1]。 

[^sola1]: ROM所存数据，一般是装入整机前事先写好的，整机工作过程中只能读出，而不像随机存储器那样能快速地、方便地加以改写。
</code></pre>
<hr>
<h5 id="标题编号"><a class="header-anchor" href="#标题编号">#</a>标题编号</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>许多Markdown处理器支持标题的自定义ID，一些Markdown处理器会自动添加它们。

添加自定义ID：允许直接链接到标题并使用CSS对其进行修改。

自定义标题ID：在与标题相同的行上用大括号括起该自定义ID。

应用举例：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">### My Great Heading &#123;#custom-id&#125;</span><br><span class="line">对应html代码:</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;custom-id&quot;</span>&gt;</span>My Great Heading<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接到标题ID(#headid)：</span><br><span class="line"></span><br><span class="line">[Heading-ids](#heading-ids)</span><br><span class="line"></span><br><span class="line">对应html代码：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#heading-ids&quot;</span>&gt;</span>Heading-ids<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

作用：通过将自定义标题ID添加到网页的完整URL，能快速链接到网页标题内容，作用类似于书签。

&lt;https://markdown.com.cn/extended-syntax/heading-ids.html#headid&gt;
</code></pre>
<hr>
<h5 id="定义列表"><a class="header-anchor" href="#定义列表">#</a>定义列表</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>一些Markdown处理器允许您创建术语及其对应定义的定义列表。

在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。

First Term
: This is the definition of the first term.

Second Term
: This is one definition of the second term.
: This is another definition of the second term.

对应HTML代码:

&lt;dl&gt;
    &lt;dt&gt;First Term&lt;/dt&gt;
    &lt;dd&gt;This is the definition of the first term.&lt;/dd&gt;
    &lt;dt&gt;Second Term&lt;/dt&gt;
    &lt;dd&gt;This is one definition of the second term. &lt;/dd&gt;
    &lt;dd&gt;This is another definition of the second term.&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>
<hr>
<h5 id="删除线"><a class="header-anchor" href="#删除线">#</a>删除线</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>在单词前后使用两个波浪号~~。

BAIDU.COM  
~~BAIDU.COM~~
</code></pre>
<hr>
<h5 id="任务列表"><a class="header-anchor" href="#任务列表">#</a>任务列表</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>任务列表使您可以创建带有复选框的项目列表。

破折号+空格+方括号（方括号中必须有空格（未完成）或者x（已完成））

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure>
</code></pre>
<hr>
<h5 id="Emoji表情"><a class="header-anchor" href="#Emoji表情">#</a>Emoji表情</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>将表情符号复制并粘贴到Markdown格式的文本中，或者键入emoji shortcodes。

1. 复制和粘贴表情符号

    从Emojipedia: &lt;https://emojipedia.org/&gt; 等来源复制表情符号并将其粘贴到文档中。

    Tip: 如果使用的是静态网站生成器，确保将HTML页面编码为UTF-8。

2. 使用表情符号简码

    一些Markdown应用程序允许通过键入表情符号短代码来插入表情符号

    去露营了！ :tent: 很快回来。
    真好笑！ :joy:

    注意：可以使用此表情符号简码列表:&lt;https://gist.github.com/rxaviers/7360908&gt;，表情符号简码因应用程序而异。
</code></pre>
<hr>
<h5 id="自动网址链接"><a class="header-anchor" href="#自动网址链接">#</a>自动网址链接</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>许多Markdown处理器会自动将URL转换为链接，即使未使用方括号。
http://www.example.com

禁用自动URL链接(也就是改写为代码)
`http://www.example.com`
</code></pre>
<hr>
<h5 id="下划线"><a class="header-anchor" href="#下划线">#</a>下划线</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>使用HTML的`&lt;u&gt;`标签 

&lt;u&gt;带下划线文本&lt;/u&gt;
</code></pre>
<hr>
<h5 id="链接本地文件"><a class="header-anchor" href="#链接本地文件">#</a>链接本地文件</h5>
<blockquote>
<p>用法如下：</p>
</blockquote>
<pre><code>​[Markdown使用教程](./Markdown使用教程.md)
</code></pre>
<hr>
<h5 id="生成目录"><a class="header-anchor" href="#生成目录">#</a>生成目录</h5>
<blockquote>
<p>两种用法如下：</p>
</blockquote>
<pre><code>1. 自动生成目录
  1.1 直接使用语法TOC (Table of Content)
    - 部分平台支持直接使用 [toc]
      - Typora支持
      - Visual Studio Code + TOC 扩展插件支持
    - 要在TOC排除一个标题：在其后面添加 &#123;ignore=true&#125;
  1.2 使用快捷键快速生成目录
    - 使用 Visual Studio Code + vscode-Markdown All in One插件（生成与手写目录基本一样，都是id选择器）
    - 用法：
      - 快捷键 Ctrl + Shift + P -&gt; 运行任务 Create table of contents 
      - 推荐给 Create table of contents 任务设置快捷键为 Ctrl + Alt + T 这样就可以直接使用快捷键直接插入目录。

2. 手动书写目录
    - 手写目录
      - 用法：[目录名](#标题链接)
      - 注意：
        - 标题链接中大写字母用小写字母代替
        - 标题链接中空格用 - 代替
</code></pre>
<hr>
<h5 id="返回目录"><a class="header-anchor" href="#返回目录">#</a>返回目录</h5>
<blockquote>
<p>两种用法如下：</p>
</blockquote>
<pre><code>1. 以目录为锚点进行跳转
[加入跳转的文字](#目录)

2. 结合 html 语法

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#目录&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top_e&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../Resource/Top.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:fixed;right:30px;bottom:40px;</span></span></span><br><span class="line"><span class="string"><span class="tag">        cursor:pointer;</span></span></span><br><span class="line"><span class="string"><span class="tag">        width:40px;</span></span></span><br><span class="line"><span class="string"><span class="tag">        height:40px;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">标记语言: 是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
